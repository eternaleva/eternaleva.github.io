<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false,"width":240},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术">
<meta property="og:url" content="http://yoursite.com/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="Maktub">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/1.jpg">
<meta property="og:image" content="http://yoursite.com/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/exception-architechture-java.png">
<meta property="article:published_time" content="2021-03-04T07:54:29.000Z">
<meta property="article:modified_time" content="2024-04-21T15:46:34.587Z">
<meta property="article:author" content="Tian">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/1.jpg">

<link rel="canonical" href="http://yoursite.com/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java核心技术 | Maktub</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Maktub</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我忘记了悲剧，看见的都是奇迹</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">49</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">17</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2.jpeg">
      <meta itemprop="name" content="Tian">
      <meta itemprop="description" content="May you found your worth in the waking world">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maktub">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java核心技术
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-04 15:54:29" itemprop="dateCreated datePublished" datetime="2021-03-04T15:54:29+08:00">2021-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-21 23:46:34" itemprop="dateModified" datetime="2024-04-21T23:46:34+08:00">2024-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/1.jpg"></p>
<span id="more"></span>

<h1 id="Java基本程序设计结构"><a href="#Java基本程序设计结构" class="headerlink" title="Java基本程序设计结构"></a>Java基本程序设计结构</h1><p><strong><em>基于Java核心技术书籍的重点总结</em></strong></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><hr>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ol>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
</ol>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><ol>
<li>float</li>
<li>double</li>
</ol>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>char</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>boolean</p>
<h3 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换"></a>数据类型之间的转换</h3><br>

<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><hr>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><br>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr>
<h3 id="基础运算符"><a href="#基础运算符" class="headerlink" title="基础运算符"></a>基础运算符</h3><h3 id="结合赋值运算符"><a href="#结合赋值运算符" class="headerlink" title="结合赋值运算符"></a>结合赋值运算符</h3><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><h3 id="运算优先级问题"><a href="#运算优先级问题" class="headerlink" title="运算优先级问题"></a>运算优先级问题</h3><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><br>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><hr>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><ol>
<li>+</li>
<li>Java11新增：repeated方法</li>
<li>join方法</li>
</ol>
<h3 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h3><p>优点：<br>缺点：</p>
<h3 id="字符串判等"><a href="#字符串判等" class="headerlink" title="字符串判等"></a>字符串判等</h3><p>s1.equals(s2)</p>
<div class="note info">
            <p>字符串不能用 ==，字符串是对象不是值</p>
          </div>

<h3 id="空串和null串"><a href="#空串和null串" class="headerlink" title="空串和null串"></a>空串和null串</h3><p>空串是一个空的字符串，有地址；null串则是连地址空间都没有的</p>
<h3 id="码点和代码单元"><a href="#码点和代码单元" class="headerlink" title="码点和代码单元"></a>码点和代码单元</h3><p>码点：一个“字符”所需要的编码二进制<br>码元：一次读取所对应的码位</p>
<h3 id="String的API"><a href="#String的API" class="headerlink" title="String的API"></a>String的API</h3><h3 id="字符串的构造"><a href="#字符串的构造" class="headerlink" title="字符串的构造"></a>字符串的构造</h3><p>字符串构造器：StringBuffer、StringBuilder<br>StringBuffer是数据安全的，有同步机制，因此性能较差<br>StringBuilder是数据不安全的，可以异步进行，性能较好</p>
<div class="note info">
            <p>一般开发使用StringBuilder，基本都是new一个新类，独占一个StringBuilder。所以不存在安全性问题。</p>
          </div>

<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><ol>
<li>构造方法<br>new StringBuffer()：长度 = 16<br>new StringBuffer(int capacity)：长度 = capacity<br>new StringBuffer(String string)：长度 = string + 16</li>
<li>操作<br>append(String string)<br>delectCharAt(index)<br>insert()<br>reverse()<br>replace()<br>…</li>
<li>扩容原理<br>如果新增后的长度超过原来的长度，将（原来长度 * 2 ）+ 2，如果超过最大长度，就返回能支持的最大长度。</li>
</ol>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h2><h3 id="标准输入-输出"><a href="#标准输入-输出" class="headerlink" title="标准输入/输出"></a>标准输入/输出</h3><p>读取输入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.Scanner</span><br><span class="line">java.lang.System</span><br><span class="line"><span class="function"><span class="keyword">static</span> Console <span class="title">console</span><span class="params">()</span></span></span><br><span class="line"><span class="function">java.io.Console	<span class="comment">//从控制台读取信息或密码</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>[] <span class="title">readPassword</span><span class="params">(String prompt, Object...args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readLine</span><span class="params">(String prompt, Object...args)</span></span></span><br></pre></td></tr></table></figure>

<p>标准输出： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(x) </span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%xxx&quot;</span>,xxx) </span><br></pre></td></tr></table></figure>

<h3 id="文件输入-输出"><a href="#文件输入-输出" class="headerlink" title="文件输入/输出"></a>文件输入/输出</h3><p>读取文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(Path.of(<span class="string">&quot;name.txt&quot;</span>), StandardCharsets.UTF_8) </span><br></pre></td></tr></table></figure>
<p>写入文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;name.txt&quot;</span>, StandardCharsets.UTF_8)</span><br></pre></td></tr></table></figure>
<p>注意路径的定位，绝对路径和相对路径</p>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>块是由若干java语句组成的结构，由大括号括起，确定了变量的作用域。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>if else</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>while/do…while</p>
<h3 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h3><p>for/for each</p>
<h3 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h3><p>switch</p>
<h3 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h3><p>break/continue</p>
<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><p><strong>java.math.BigInteger</strong><br>add()、subtract()、multiply()、divide()、sqrt()、mod()、compareTo()、valueOf()<br><strong>java.math.BigDecimal</strong></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] &#x3D; new int[num];</span><br><span class="line">int a[] &#x3D; new int[]&#123;num1, num2...&#125;;</span><br><span class="line">new int[] &#123;num1, num2...&#125;;		&#x2F;&#x2F;匿名数组</span><br></pre></td></tr></table></figure>

<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>访问数组需要根据数组下标访问。数组名为一个地址，指向数组的第0个位置的内容。</p>
<h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (variable : collection) statement;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>打印数组所有的值：使用Arrays.toString(s)，会把数组元素，用逗号分隔，连同括号一起输出</p>
          </div>

<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p>Java中，如果把一个数组变量赋值给另一个数组变量，则他们指向同一个引用。所以，如果需要拷贝数组，则需要使用Arrays类的copyOf方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] copy &#x3D; Arrays.copyOf(base, base.length);</span><br><span class="line">&#x2F;&#x2F;第二个参数是新数组的大小，因此也可以用来扩大数组容量</span><br><span class="line">int[] increase &#x3D; Arrays.copyOf(base, base.length &lt; 2);</span><br></pre></td></tr></table></figure>

<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>Java需要用到某个类时，如果该类未被加载到内存中，系统会进行加载、连接、初始化，实现对类的加载。</p>
<ol>
<li>加载：通过类的全限定名获取类的二进制字节流；之后在内存中生存一个代表该类的Class对象，作为方法区的该类各个数据的访问入口。</li>
<li>连接：1）验证，确保类加载的正确性。2）准备，为类的静态变量分配内存，并设置默认初始值。3）解析，将类中符号引用替换为直接引用（就是替换成内存地址）。</li>
<li>初始化：给静态变量赋初值，执行静态代码块内容。</li>
</ol>
<div class="note info">
            <ol><li>验证中，在class文件字节码，前4个字节，是Magic Number，判断是不是class文件。</li><li>初始化语句，在类加载的初始化阶段才会进行。</li></ol>
          </div>

<h3 id="类加载的时机："><a href="#类加载的时机：" class="headerlink" title="类加载的时机："></a>类加载的时机：</h3><ol>
<li>首次创建类</li>
<li>首次访问静态变量</li>
<li>首次调用静态方法</li>
<li>使用反射强制创造某个类或接口的对应java.lang.class对象</li>
<li>初始化某个类的子类，会先触发父类的加载</li>
<li>直接使用java.exe来运行某个main类</li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ol>
<li>Bootstrap ClassLoader 根类加载器：Java核心类的加载，JDK中JRE的lib下的rt.jar</li>
<li>Extension ClassLoader 拓展类加载器：JRE拓展目录中jar包的加载，JDK中JRE的lib下的ext目录</li>
<li>System ClassLoader 系统类加载器：复杂加载自定义的类</li>
</ol>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ol>
<li>通过对象获取<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Object中</span><br><span class="line">Class getClass()</span><br></pre></td></tr></table></figure></li>
<li>通过字面值常量（但是不是完整的类加载，没有初始化过程，且必须是全类名）</li>
<li>通过Class类的静态方法：Class.forName(String className) （常用）</li>
</ol>
<div class="note info">
            <p>一般开发都是用config文件</p>
          </div>

<h3 id="利用Properties对象读取配置"><a href="#利用Properties对象读取配置" class="headerlink" title="利用Properties对象读取配置"></a>利用Properties对象读取配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis &#x3D; new FileInputStream(&quot;config.properties&quot;);</span><br><span class="line">Properties prop &#x3D; new Properties();</span><br><span class="line">prop.load(fis);</span><br><span class="line">String className &#x3D; properties.getProperty(&quot;className&quot;);</span><br><span class="line">return className;</span><br></pre></td></tr></table></figure>

<h3 id="获取类中定义的构造方法"><a href="#获取类中定义的构造方法" class="headerlink" title="获取类中定义的构造方法"></a>获取类中定义的构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] getConstructors()		&#x2F;&#x2F;获取所有public方法</span><br><span class="line">Constructor[] getDeclaredConstructors()		&#x2F;&#x2F;获取所有方法</span><br><span class="line"></span><br><span class="line">Constructor getConstructor(Class... parameterTypes)		&#x2F;&#x2F;获取指定public方法</span><br><span class="line">Constructor getDeclaredConstructor(Class... parameterTypes)		&#x2F;&#x2F;获取指定的任意方法</span><br><span class="line">&#x2F;&#x2F;参数类型是其对应的Class对象</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>可变参数只能有一个，且必须在参数的末尾：public void show(int a, double… b)</p>
          </div>

<p>可以使用获取的构造方法来创建对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor.newInstance(Object... initArgs);</span><br><span class="line"></span><br><span class="line">constructor.setAccessible(true);	&#x2F;&#x2F;针对private的权限，告诉JVM绕过权限检查</span><br></pre></td></tr></table></figure>

<h3 id="获取类中成员变量的方法"><a href="#获取类中成员变量的方法" class="headerlink" title="获取类中成员变量的方法"></a>获取类中成员变量的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Field[] getFields()		&#x2F;&#x2F;获得子类和父类的public成员变量</span><br><span class="line">Fieled[] getDeclaredFields()		&#x2F;&#x2F;获得自己的所有成员变量</span><br><span class="line"></span><br><span class="line">Field getField(String name)		&#x2F;&#x2F;获取指定的public成员变量，先子类再父类查找</span><br><span class="line">Field getDeclaredField(String name)		&#x2F;&#x2F;获取自己任意的成员变量</span><br></pre></td></tr></table></figure>
<p>获取成员变量的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">field.get(Object obj);</span><br><span class="line">void set(Object obj, Object value);</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>为什么不用obj.fieldName来获取成员变量值？ 因为该方式涉及一个权限问题，使用反射可以越过权限访问(通过setAceessible)</p>
          </div>

<div class="note info">
            <p>关于静态成员变量：</p><ol><li>静态变量的对象获取与普通是相同的。</li><li>但是因为静态成员不依赖于对象，所以获取值的时候，传递的要是一个null。</li></ol>
          </div>


<h3 id="获得类中成员方法的方法"><a href="#获得类中成员方法的方法" class="headerlink" title="获得类中成员方法的方法"></a>获得类中成员方法的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method[] getMethods();		&#x2F;&#x2F;自己及父类的public方法</span><br><span class="line">Method[] getDeclaredMethods();		&#x2F;&#x2F;自己的所有方法</span><br><span class="line"></span><br><span class="line">Method getMethod(String name, Class&lt;?&gt;... parameterTypes);		&#x2F;&#x2F;获取自己及父类指定public成员方法</span><br><span class="line">Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);		&#x2F;&#x2F;获取自己的所有指定方法</span><br><span class="line"></span><br><span class="line">Object invoke(Object obj, Object... args);</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>关于静态方法：</p><ol><li>静态方法对象获取与普通是相同的。</li><li>静态方法不依赖于对象，调用传的值也要传递一个null。</li></ol>
          </div>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>为我们在代码中添加信息，提供了一种形式化的方法，使我们可以在稍后的某个时刻非常方便的使用这些信息(通过代码来获取，并使用这些定义的额外信息)。并且在JVM进行编译的时候，对其视而不见。只有固定语法，没有标准形式？</p>
<h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>注解的定义，和类、接口的定义十分类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface MyInterface&#123;</span><br><span class="line">	&#x2F;&#x2F;第一条信息</span><br><span class="line">	&#x2F;&#x2F;第二条信息</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <ol><li>注解内信息直接是有标准的。</li><li>每一个信息，都有自己的名字（方法名），都有自己的数据类型（方法返回值）。</li><li>@ 一定不能丢。</li><li>注解不能继承。</li><li>数据类型不能是自定义类</li></ol>
          </div>

<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>注解类型（类）和注解实例（对象）。注解的实质，是创建一个注解实例，并且给该实例的各个成员变量赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@MyInterface(maxAge &#x3D; 25, minAge &#x3D; 18)</span><br></pre></td></tr></table></figure>
<p>注解可以在定义时，设置默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MyInterface&#123;</span><br><span class="line">	int length() default 5;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <ol><li>注解对象必须有值</li><li>引用类型不允许默认声明为null（比如String）</li><li>简化版注解：仅有一个变量名，且为value，注解实例可以直接写数值。 @MyInterface(100)</li></ol>
          </div>

<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>使用工厂类</p>
<div class="note info">
            <p>isAnnotationPresent(Class targetAnnotation) 判断该成员变量是否有注解<br>getAnnotation(Class targetAnnotation) 获取该变量的注解对象</p>
          </div>

<h3 id="注解的保留级别"><a href="#注解的保留级别" class="headerlink" title="注解的保留级别"></a>注解的保留级别</h3><ol>
<li>SOURCE：注解将被编译器丢弃（class文件中没有）</li>
<li>CLASS：注解可以在Class文件，但是会被JVM丢弃（不会在内存中）</li>
<li>RUNTIME：在内存中一样保存。</li>
</ol>
<div class="note info">
            <p>默认保留级别是CLASS</p>
          </div>

<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解：注解的注解。</p>
<ol>
<li>@Target        作用范围，多个对象用大括号包起来。</li>
<li>@Retention        保留级别<br>修改注解的保留级别：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@MyInterface(....)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>isAnnotation(Class type)<br>getAnnotation(Class type)</p>
          </div>

</li>
</ol>
<h3 id="注解的使用场景"><a href="#注解的使用场景" class="headerlink" title="注解的使用场景"></a>注解的使用场景</h3><p>配置文件和注解的区别。<br>如果配置和代码直接相关，使用注解。比如相关开源组件：Junit、Servlet、Spring。<br>如何配置和代码运行环境有关，使用配置文件。</p>
<div class="note info">
            <p>硬编码：把变量值，直接写在代码里。</p>
          </div>




<h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><p>lambda函数是个匿名函数，可以理解为一段可以传递的代码。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><hr>
<h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p><img src="/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/exception-architechture-java.png" alt="xxx"><br>Exception还分为：编译时异常(Checkable Exception)、运行时异常(Runtime Exception)</p>
<h3 id="异常的实质"><a href="#异常的实质" class="headerlink" title="异常的实质"></a>异常的实质</h3><p>提供了一致性的错误报告模型，使得类的构建者和使用者之间可以进行可靠的沟通</p>
<h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><p>数组越界<br>空指针</p>
<h3 id="声明检查异常"><a href="#声明检查异常" class="headerlink" title="声明检查异常"></a>声明检查异常</h3><p>告诉编译器可能发生什么错误<br>4种抛出异常的情况：</p>
<ol>
<li>调用抛出检查型异常的方法</li>
<li>检测到一个错误</li>
<li>程序出现错误</li>
<li>java虚拟机或者运行时库出现内部错误</li>
</ol>
<div class="note info">
            <p>子类覆盖超类的方法时，可以抛出更特定的异常，或者根本不抛出异常。另外，超类不抛出异常，子类更不能抛出异常</p>
          </div>

<h3 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h3><ol>
<li>throws<br>在方法定义时，多个异常用逗号( , )分隔<br>throws表示抛出一种可能性，并不一定发生，且由调用者来处理异常</li>
<li>throw<br>在方法内抛出异常类，可以由方法体内来处理<br>throw则是必定抛出一个异常<br>tip：抛出编译时异常，必须使用throws</li>
</ol>
<h3 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h3><p>定义一个派生于Exception的类（Throwable是所有异常的基类（父类）） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable:</span><br><span class="line">Throwable() </span><br><span class="line">Throwable(String message)</span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><hr>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h3><ul>
<li>捕获单个异常</li>
<li>捕获多个异常; 并列处理,同一处理方式可以合并</li>
</ul>
<h3 id="再次抛出异常和异常链"><a href="#再次抛出异常和异常链" class="headerlink" title="再次抛出异常和异常链"></a>再次抛出异常和异常链</h3><p>可以在catch中再次抛出一个异常（就是希望改变异常类型）</p>
<ol>
<li>使用这样的包装细节，可以在子系统抛出高层异常时，不丢失原始异常的细节。</li>
<li>想记录一个异常，可以将他重新抛出。</li>
</ol>
<div class="note info">
            <p>如果一个方法发生检查型异常，但是该方法不允许抛出检查型异常，可以包装成运行时异常。 </p>
          </div>

<div class="note warning">
            <p>如果异常被捕获，而没有被处理或抛出，则异常会被忽略</p>
          </div>

<h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><p>代码抛出异常后，就会停止处理这个方法中剩余的代码，并退出。</p>
<ol>
<li>有时代码要求必须执行的内容（比如关闭流等），可以用finally子句（finally子句必定被执行）</li>
<li>try语句可以没有catch，只搭配finally。</li>
<li>嵌套try，内层try可以执行finally，确保一些工作，外层负责报告错误。</li>
<li>java7之后的可替代方案：try-with-resources</li>
</ol>
<div class="note warning">
            <p>finally里如果使用return，这个返回值会遮蔽原来的返回值</p>
          </div> 

<h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>要求资源属于AutoCloseable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = ...) &#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//try块结束的时候，res会自动释放</span></span><br></pre></td></tr></table></figure>

<p>Java9中,可以在try首部中提供之前声明的事实最终变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">(String[] lines, PrintWriter out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (out) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">            out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	<span class="comment">//结束后自动out.close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>try-with-resources也可以有自己的catch子句或者finally子句，关闭资源后会执行子句。</p>
          </div>


<h3 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h3><p><strong>堆栈轨迹(stack trace)</strong> 是程序执行过程中某个特定点上挂起的方法调用的一个列表。当java程序因为一个未捕获的异常而终止时，就会显示堆栈轨迹。<br>主要是调用Throwable类的printStackTrace方法<br>更为灵活的是使用StackWalker类，每一个实例描述一个栈帧。利用StackWalker.StackFrame类的一些方法可以得到所执行代码的文件名和行号，以及类对象和方法名。<br>相关类：StackWalker、StackFrame、StackTraceElement</p>
<h3 id="使用异常的技巧"><a href="#使用异常的技巧" class="headerlink" title="使用异常的技巧"></a>使用异常的技巧</h3><ol>
<li>异常处理不能代替简单的测试: 因为异常捕获非常消耗性能</li>
<li>不要过分细化异常</li>
<li>充分利用异常的层级结构</li>
<li>不要压制异常</li>
<li>检测错误时，苛刻比放任更好</li>
<li>不要羞于传递异常</li>
</ol>
<div class="note info">
            <p>早抛出，晚捕获</p>
          </div>


<h2 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h2><h3 id="断言的概念"><a href="#断言的概念" class="headerlink" title="断言的概念"></a>断言的概念</h3><p>假如确信某个属性符合要求，并且代码的执行依赖这个属性，且不想要大量检测的代码保留在程序中，可以使用断言。断言机制允许在测试期间向代码插入一些检查，而在生产代码的时候会自动删除这些检查。</p>
<div class="note info">
            <p>即assert是负责检查绝对不可以出现的情况</p>
          </div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert condition;</span><br><span class="line">assert condition : expression;</span><br></pre></td></tr></table></figure>

<h3 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h3><p>断言默认是禁用。</p>
<ol>
<li>启用：运行时使用 -enableassertions 或 -ea 开启。</li>
<li>禁用：运行时使用 -disableassertions 或 -da 开启。</li>
</ol>
<div class="note info">
            <p>不必重新编译程序来启用或禁用，因为这是类加载器的功能。禁用断言时，类加载器会去除断言代码</p>
          </div>
<p>断言也可以某个类或这个包中启用。</p>
<div class="note info">
            <p>-ea和-da对那些没有类加载类的“系统类”无效，需要用-enablesystemassertions/-esa 开关断言</p>
          </div>

<h3 id="使用断言完成参数检查"><a href="#使用断言完成参数检查" class="headerlink" title="使用断言完成参数检查"></a>使用断言完成参数检查</h3><p>Java中提供了三种处理系统错误的机制：</p>
<ol>
<li>抛出一个异常</li>
<li>日志</li>
<li>使用断言</li>
</ol>
<p>以下情况要使用断言：</p>
<ol>
<li>断言失败是致命的、不可恢复的错误</li>
<li>断言检查只是在开发和测试阶段打开</li>
</ol>
<p>因此不应该使用断言向程序的其他部分通知发生了可通知性错误，或者，不应用利用断言与程序用户沟通问题。断言只应该用于测试阶段确定程序内部错误的位置。</p>
<p><em>前置条件</em>：程序所必须具有的约定。比如约定一个参数a不能为null</p>
<h3 id="使用断言提供假设文档"><a href="#使用断言提供假设文档" class="headerlink" title="使用断言提供假设文档"></a>使用断言提供假设文档</h3><p>……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader</span><br><span class="line">	void setDefaultAssertionStatus(boolean b)</span><br><span class="line">	&#x2F;&#x2F;为通过类加载器的类启动或禁用类</span><br><span class="line">	void setClassAssertionStatus(String className, boolean b)</span><br><span class="line">	&#x2F;&#x2F;为给定的类和它的内部类启用或禁用断言</span><br><span class="line">	void setPackageAssertionStatus(String packageName, boolean b)</span><br><span class="line">	&#x2F;&#x2F;为给定包及其子包的所有类启用或禁用断言</span><br><span class="line">	void clearAssertionStatus()</span><br><span class="line">	&#x2F;&#x2F;删除所有显式的类和包断言状态设置，并禁用通过这个类加载器加载所有类的断言</span><br></pre></td></tr></table></figure>

<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志API的主要优点:</p>
<ol>
<li>可以很容易地取消全部日志记录，或者仅仅取消某个级别以下的日志，而且很容易地再次打开开关。</li>
<li>可以很简单的禁止日志记录，因此，将这些日志代码留在程序中的开销很小。</li>
<li>日志记录可以被定向到不同的处理器，如在控制台显示、写至文件，等等。</li>
<li>日志记录器和处理器都可以对记录进行过滤。过滤器可以根据过滤器实现器指定的标准丢弃那些无用的记录项。</li>
<li>日志记录可以采用不同的方式格式化，例如，纯文本或者XML</li>
<li>应用程序可以使用多个日志记录器，他们使用与包名类似的有层次的结构名字</li>
<li>日志系统的配置由配置文件控制</li>
</ol>
<div class="note info">
            <p>但是现在工程化管理，多数使用Log4J2等一些日志框架</p>
          </div>

<h3 id="基本日志"><a href="#基本日志" class="headerlink" title="基本日志"></a>基本日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().info(&quot;xxx&quot;);</span><br><span class="line">&#x2F;&#x2F;&#x2F;生成简单的日志记录</span><br><span class="line">Logger.getGlobal().setLevel(Level.OFF);</span><br><span class="line">&#x2F;&#x2F;取消所有日志</span><br></pre></td></tr></table></figure>

<h3 id="高级日志"><a href="#高级日志" class="headerlink" title="高级日志"></a>高级日志</h3><p>在很多程序中，我们并不希望所有日志都记录在一个全局日志中。因此可以定义自己的日志记录器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;调用getLogger方法创建或获取日志记录器：</span><br><span class="line">private static final Logger myLogger &#x3D; Logger.getLogger(&quot;com.myCompany.myApp&quot;)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>为什么定义为final？是因为未被任何变量引用的日志记录器可能会被垃圾回收，因此需要定义为final</p>
          </div>

<p>日志记录器的层次性更强，父与子之间会共享某些属性，比如日志级别。<br>日志分为7个级别：</p>
<ol>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logger.setLevel(Level.FINE)</span><br><span class="line">&#x2F;&#x2F;默认只记录前三个级别，也可以自行设置，这样，FINE及以上的日志都会记录</span><br><span class="line">&#x2F;&#x2F;Level.ALL全部开启，Level.OFF全部关闭</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>INFO及更高级别的日志会被默认记录，因此，应该使用CONFIG、FINE、FINER、FINEST来记录有助于诊断，但意义不大的调试信息</p>
          </div>

<div class="note warning">
            <p>如果修改日志记录级别比INFO低，还需要修改日志处理器的配置。因为日志处理器会抑制低于INFO的消息。</p>
          </div>

<p>默认的日志记录将显示调用堆栈得出的包含日志调用的类名和方法名。如果虚拟机对执行过程进行了优化，就会得不到准确的调用信息。因此需要使用**<em>logp**</em>方法获得调用类和方法确切的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void logp(Level l, String className, String methodName, String message)</span><br></pre></td></tr></table></figure>
<p>还有一些跟踪执行流的便利方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void entering(String className, String methodName)</span><br><span class="line">void entering(String className, STring methodName, Object param)</span><br><span class="line">void entering(String className, String methodName, Object[] params)</span><br><span class="line">void exiting(String className, String methodName)</span><br><span class="line">void exiting(String className, String methodName, Object result)</span><br></pre></td></tr></table></figure>

<p>在记录中包含异常的描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void throwing(String className, String methodName, Throwable t)</span><br><span class="line">void log(Level l, String message, Throwable t)</span><br></pre></td></tr></table></figure>

<h3 id="修改日志管理器配置"><a href="#修改日志管理器配置" class="headerlink" title="修改日志管理器配置"></a>修改日志管理器配置</h3><p>默认情况下，配置文件位于: conf/logging.properties（Java9之前，位于jre/lib/logging.properties）<br>编辑配置文件，修改.level=级别。<br>如果要自定义日志记录器级别，在日志记录器后面加.level=级别，比如 com.myCompany.myApp.level=FINE</p>
<h3 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h3><p>…..</p>
<h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>…..</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>…..</p>
<h3 id="格式化器"><a href="#格式化器" class="headerlink" title="格式化器"></a>格式化器</h3><p>….</p>
<h3 id="日志技巧"><a href="#日志技巧" class="headerlink" title="日志技巧"></a>日志技巧</h3><p>….</p>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><h1 id="重要的类"><a href="#重要的类" class="headerlink" title="重要的类"></a>重要的类</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>File类是文件和目录路径名的抽象表达形式<br>File的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String pathname)</span><br><span class="line">File(String parent, String child)</span><br><span class="line">File(File parent, String child)</span><br></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建：</span><br><span class="line">public boolean createNewFile()</span><br><span class="line">public boolean mkdir()</span><br><span class="line">public boolean mkdirs()</span><br><span class="line">&#x2F;&#x2F;删除</span><br><span class="line">public boolean delete()</span><br><span class="line">&#x2F;&#x2F;重命名</span><br><span class="line">public boolean renameTo(File dest)</span><br><span class="line">&#x2F;&#x2F;判断</span><br><span class="line">public boolean isFile()</span><br><span class="line">public boolean isDirectory()</span><br><span class="line">public boolean exists()</span><br><span class="line">public boolean canRead()</span><br><span class="line">public boolean canWrite()</span><br><span class="line">public boolean isHidden()</span><br><span class="line">&#x2F;&#x2F;基础属性获取</span><br><span class="line">public File getAbsolutePath()</span><br><span class="line">public String getPath()</span><br><span class="line">public String getName()</span><br><span class="line">public long length()</span><br><span class="line">public long lastModified()</span><br><span class="line">&#x2F;&#x2F;高级属性获取</span><br><span class="line">public String[] list()  &#x2F;&#x2F;返回一个字符串数组，这些字符串指定此抽象路径名表示的目录</span><br><span class="line">中的文件和目录。</span><br><span class="line">public File[] listFiles() &#x2F;&#x2F;返回一个File数组，这些路径名表示此抽象路径名表示的目录中的文件或者目录</span><br><span class="line">&#x2F;&#x2F;如果返回的是一个null，表示该路径名下是一个文件</span><br><span class="line">&#x2F;&#x2F;自定义获取</span><br><span class="line">File[] listFiles(FileFilter filter)</span><br></pre></td></tr></table></figure>

<h3 id="过滤器接口"><a href="#过滤器接口" class="headerlink" title="过滤器接口"></a>过滤器接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface FileFilter &#123;</span><br><span class="line">  boolean accept(File pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例如写一个只接收txt文件后缀的文件过滤器</span><br><span class="line">FileFilter filter &#x3D; new FileFilter() &#123;</span><br><span class="line">  &#x2F;&#x2F; 过滤条件就是在这里实现的</span><br><span class="line">  @Override</span><br><span class="line">  public boolean accept(File targetFile) &#123;</span><br><span class="line">    if (targetFile.isDirectory()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是目录，不满足条件</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  String name &#x3D; targetFile.getName();</span><br><span class="line">  &#x2F;&#x2F; 判断如果是txt文件返回true，否则返回false</span><br><span class="line">    return name.endsWith(&quot;txt&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><h2 id="为什么要定义泛型"><a href="#为什么要定义泛型" class="headerlink" title="为什么要定义泛型"></a>为什么要定义泛型</h2><p>泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。</p>
<h3 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h3><p>使用类型参数可以用来指定元素的类型：</p>
<ol>
<li>使代码具有更好的可读性</li>
<li>编译器可以充分利用这个类型信息，获取值时不用强制类型转换</li>
<li>更加安全，防止插入错误类型的对象</li>
</ol>
<h3 id="谁想成为泛型程序员"><a href="#谁想成为泛型程序员" class="headerlink" title="谁想成为泛型程序员"></a>谁想成为泛型程序员</h3><p>要预计泛型类所有的可能用法，是很困难的。<br>Java语言设计者发明了一个具有独创性的新概念，**<em>标识通配符类型**</em><br>泛型程序设计分为三个类型：</p>
<ol>
<li>仅仅使用泛型类</li>
<li>混合使用不同的泛型类，需要对Java泛型有足够的了解</li>
<li>实现自己的泛型类和泛型方法</li>
</ol>
<h2 id="定义简单的泛型类"><a href="#定义简单的泛型类" class="headerlink" title="定义简单的泛型类"></a>定义简单的泛型类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>一般E表示集合元素类型，K和V分别表示键和值的类型，T（U、S）表示任意类型</p>
          </div>
<p>可以用具体的类型替换变量来实例化泛型类型</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>定义一个带有类型参数的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ArrayAlg &#123;</span><br><span class="line">  public static &lt;T&gt; T getMiddle(T ... a) &#123;</span><br><span class="line">    return a[a.length &#x2F; 2];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>泛型类型放在返回类型的前面</p>
          </div>
<div class="note success">
            <p>如果想知道编译器对一个范型方法的调用最终判断出哪种类型，可以故意引入一个错误，然后分析错误信息。</p>
          </div>

<h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>有时候类或方法需要类型变量加以约束，可以对类型变量T设置一个限定来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&gt; T min(T[] a) ...</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>为什么用extends？是因为T应该是限定类型的子类型。T和限定类型可以是类，也可以是接口。</p>
          </div>
<p>一个类型变量或通配符可以有多个限定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends Comparable &amp; Serializable</span><br></pre></td></tr></table></figure>
<p>限定类型用”&amp;”分隔，类型变量用”,”分隔</p>
<h2 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h2><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>原始类型：无论何时定义一个泛型类型，都会自动提供一个相应的原始类型（即去掉类型参数后的泛型类型名）<br>类型擦除：泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换成它们非泛型上界。</p>
<h3 id="转换泛型表达式"><a href="#转换泛型表达式" class="headerlink" title="转换泛型表达式"></a>转换泛型表达式</h3><p>编写泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。<br>当访问一个泛型字段时也要插入强制类型转换。</p>
<h3 id="转换泛型方法"><a href="#转换泛型方法" class="headerlink" title="转换泛型方法"></a>转换泛型方法</h3><p>类型擦除也会出现在泛型方法中。类型擦除后，会与多态发生冲突。继而引出桥方法（bridge method），来解决这个问题: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setSecond(Object second) &#123;</span><br><span class="line">  setSecond((LocalDate) second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之Java泛型的转换，需要记住以下几个事实：</p>
<ol>
<li>虚拟机中没有泛型，只有普通类和方法</li>
<li>所有的类型参数都会替换为它们的限定类型</li>
<li>会合成桥方法来保持多态</li>
<li>为保持类型安全性，必要时会插入强制类型转换</li>
</ol>
<h3 id="调用遗留代码"><a href="#调用遗留代码" class="headerlink" title="调用遗留代码"></a>调用遗留代码</h3><h2 id="限制和局限性"><a href="#限制和局限性" class="headerlink" title="限制和局限性"></a>限制和局限性</h2><h3 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h3><h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><h3 id="Varargs-警告"><a href="#Varargs-警告" class="headerlink" title="Varargs 警告"></a>Varargs 警告</h3><h1 id="Java-I-O流"><a href="#Java-I-O流" class="headerlink" title="Java I/O流"></a>Java I/O流</h1><h2 id="I-O流概念"><a href="#I-O流概念" class="headerlink" title="I/O流概念"></a>I/O流概念</h2><p>I/O流：I/O流用来处理JVM和外部设备之间的数据传输，Java通过流(Stream)的方式，完成数据的传输过程。</p>
<h2 id="I-O的分类"><a href="#I-O的分类" class="headerlink" title="I/O的分类"></a>I/O的分类</h2><h3 id="按照数据流向"><a href="#按照数据流向" class="headerlink" title="按照数据流向"></a>按照数据流向</h3><p>输入流：读入数据<br>输出流：写出数据</p>
<h3 id="按照数据类型"><a href="#按照数据类型" class="headerlink" title="按照数据类型"></a>按照数据类型</h3><p>字节流：数据是一连串二进制<br>字符流：数据是字符序列</p>
<div class="note info">
            <p>文本数据用字符流，如果不确定数据类型，一律用字节流</p>
          </div>

<h2 id="I-O流常用基类"><a href="#I-O流常用基类" class="headerlink" title="I/O流常用基类"></a>I/O流常用基类</h2><p>字节流抽象基类：</p>
<ol>
<li>InputStream</li>
<li>OutputStream</li>
</ol>
<p>字符流抽象基类：</p>
<ol>
<li>Reader</li>
<li>Writer</li>
</ol>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节流写数据"><a href="#字节流写数据" class="headerlink" title="字节流写数据"></a>字节流写数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造方法</span><br><span class="line">FileInputStream(File file)</span><br><span class="line">FileInputStream(String fileName)</span><br><span class="line">&#x2F;&#x2F;方法</span><br><span class="line">public void write(int b)</span><br><span class="line">public void write(byte[] b)</span><br><span class="line">public void write(byte[] b,int off,int len)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>字节流写数据的问题</p><ol><li>创建字节输出流时，JVM会首先到操作系统中，查找目标文件。<br> a. 当发现目标文件不存在的时候，JVM会首先创建该目标文件(内容为空)<br> b. 当发现目标文件存在的时候, JVM默认会首先清空目标文件内容，最好准备让FileOutputStream,从文件头开始写入数据</li><li>如果要实现换行，核心是需要换行符<br> a. 类linux: ‘\n’<br> b. windows: ‘\r’ +’\n’</li><li>数据写成功后，是要close()，因为要关闭此输出流，并且释放与此相关的系统资源</li><li>实现追加写入一定要新创建输出流对象，在两个不同的输出流对象上，向同一个文件写入数据，对文件的追加写入。<br> FileOutputStream(File file, boolean append)<br> //创建一个向指定 File 对象表示的文件中写入数据的文件输出流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处</li></ol>
          </div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前系统的换行操作符</span><br><span class="line">String s &#x3D; System.lineSeparator();</span><br></pre></td></tr></table></figure>

<h3 id="字节流读数据"><a href="#字节流读数据" class="headerlink" title="字节流读数据"></a>字节流读数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造方法</span><br><span class="line">FileOutputStream(File file)</span><br><span class="line">FileOutputStream(String fileName)</span><br><span class="line">&#x2F;&#x2F;方法</span><br><span class="line">public int read()			&#x2F;&#x2F;返回读取一个字节数据，末尾则返回-1</span><br><span class="line">public int read(byte[] b)		&#x2F;&#x2F;返回读取的字节总数，末尾则返回-1</span><br><span class="line">public int read(byte[] b, int offset, int length)	&#x2F;&#x2F;读取保存在数组的[offset, offset + length)的区间</span><br></pre></td></tr></table></figure>

<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>字节流一次读取一个字节数组明显比一次读取一个字节的速度快的多，这是因为加了缓冲区的效果，减少了I/O操作次数，因此Java也提供了字节缓冲流。Read和Write都是在缓冲区进行交流。<br>字节缓冲输出流：BufferedOutputStream<br>字节缓冲输入流：BufferedInputStream</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>在某些情况下，使用字节流操作中文不方便。主要是因为数据单位不一致，因此可以采用将一个字符作为一个单位操作的I/O流。</p>
<div class="note info">
            <p>字符流 = 字节流 + 编码表</p>
          </div>

<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><p>编码表是字符与数值对应的关系表<br>常见编码表：</p>
<ol>
<li>ASCII/Unicode 字符集</li>
<li>ISO-8859-1 -&gt; Latin-1</li>
<li>GBK：2个字符表示一个中文 （JDK默认用GBK）</li>
<li>UTF-8：一般3个字符表示一个中文（IDEA默认用UTF-8）</li>
<li>UTF-16：一个字符固定占16位，中文也占16位 （JVM保存字符的默认格式）</li>
</ol>
<p>编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] getBytes(String charsetName)</span><br></pre></td></tr></table></figure>
<p>解码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(byte[], int length, String charsetName)</span><br></pre></td></tr></table></figure>


<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>要利用Writer或者Reader向文本中写入中文字符串，而Writer和Reader是抽象类，无法直接实例化，所以需要用其子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;OutputStreamWriter的实例化</span><br><span class="line">public OutputStreamWriter(OutputStream out)</span><br><span class="line">public OutputStreamWriter(OutputStream out, String charsetName)</span><br><span class="line">&#x2F;&#x2F;Writer写字符数据的方法</span><br><span class="line">public void write(int c)		&#x2F;&#x2F;写入一个字符，32位int只保留低位的16倍作为字符数据</span><br><span class="line">public void write(char[] cbuff)		&#x2F;&#x2F;将cbuff数组的内容写出</span><br><span class="line">public void write(char[] cbuff, cbuff int, int off, int len)</span><br><span class="line">public void write(String str)</span><br><span class="line">public void write(String str, int off, int len)</span><br><span class="line">&#x2F;&#x2F;InputStreamReader的实例化</span><br><span class="line">public InputStreamReader(InputStream in)</span><br><span class="line">public InputStreamReader(InputStream in, String charsetName)</span><br><span class="line">&#x2F;&#x2F;Reader读数据的方法</span><br><span class="line">public int read()</span><br><span class="line">public int read(char[] cbuff)		&#x2F;&#x2F;将读取的数据放入cbuff数组中</span><br><span class="line">public int read(char[] cbuff, int off, int len)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>字符流的为了实现编解码，自带缓冲区，如果不刷新或者关闭流时，是不会在目标文件上输出</p>
          </div>
<div class="note info">
            <p>flush()强制清空缓冲区并写出所有缓冲区，close()则是直接关闭整个流，会先调用flush()，再关闭流</p>
          </div>

<h3 id="简便文本输入输出流"><a href="#简便文本输入输出流" class="headerlink" title="简便文本输入输出流"></a>简便文本输入输出流</h3><p>因为转换流过于麻烦，于是Java提供了简化的字符输入输出包装流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;FileReader</span><br><span class="line">public FileReader(String fileName)</span><br><span class="line">public FileReader(File file)</span><br><span class="line">&#x2F;&#x2F;FileWriter</span><br><span class="line">public FileWriter(String fileName)</span><br><span class="line">public FileWriter(String fileName, boolean append)</span><br><span class="line">public FileWriter(File file)</span><br><span class="line">public FileWriter(File file, boolean append)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>这两个类不提供指定编解码值</p>
          </div>


<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>字符缓冲流定义了字符缓冲流独有的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用默认大小输入&#x2F;输出字符流</span><br><span class="line">BufferedWriter(Writer writer)</span><br><span class="line">BufferedReader(Reader reader)</span><br><span class="line">&#x2F;&#x2F;BufferedWriter子类独有的方法</span><br><span class="line">void newLine()		&#x2F;&#x2F;写入一个对应系统的换行符</span><br><span class="line">&#x2F;&#x2F;BufferedReader独有</span><br><span class="line">String readLine() 	&#x2F;&#x2F;不读取换行符</span><br></pre></td></tr></table></figure>

<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>单个程序看起来在同时完成多个任务，每一个任务在线程中执行。</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>一个进程代表一个运行的程序，而线程则是从进程中划分的最小任务并发执行单元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable target)</span><br><span class="line">void start()</span><br><span class="line">void run()</span><br><span class="line">static void sleep(long millis)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>不要调用Thread类或Runnable对象的run方法。直接调用会在同一个线程中执行，而没启动新的线程。如果要执行run方法的新线程，应该使用Thread.start方法。</p>
          </div>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ol>
<li>New</li>
<li>Runnable</li>
<li>Blocked</li>
<li>Waiting</li>
<li>Timed waiting</li>
<li>Terminated</li>
</ol>
<h3 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(Runnable runnable, String name);</span><br></pre></td></tr></table></figure>

<h3 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h3><p>一旦调用start方法，线程就处于可运行状态。可运行状态线程可能运行也可能没有运行。一个线程只有在调用yield()或者被阻塞或等待时才会失去控制权。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void yield()</span><br></pre></td></tr></table></figure>

<h3 id="阻塞和等待线程"><a href="#阻塞和等待线程" class="headerlink" title="阻塞和等待线程"></a>阻塞和等待线程</h3><p>处于以下状态，可能使线程暂时不活动，从而等待特定条件来重新激活运行。</p>
<ol>
<li>当一个线程试图获取一个内部的对象锁，如果锁被其他线程占有，会进入阻塞状态。</li>
<li>当线程等待另一个线程通知调度器出现一个条件时，会进入等待状态。</li>
<li>有几个方法有超时参数，调用这些方法会让线程进入计时等待状态。</li>
</ol>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>线程会由于以下两个原因终止：</p>
<ol>
<li>run方法正常退出，线程自然终止</li>
<li>因为一个没有捕获的异常终止了run方法，使线程意外终止</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void join()</span><br><span class="line">void join(long millis)</span><br><span class="line">Thread.State.getState()		&#x2F;&#x2F;返回值NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</span><br><span class="line">void stop()</span><br><span class="line">void suspend()</span><br><span class="line">void resume()		&#x2F;&#x2F;已被废弃</span><br></pre></td></tr></table></figure>

<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>除了已经废弃的stop方法，没有办法可以强制线程终止。不过interrupt可以用来请求一个终止线程。<br>当调用interrupt方法时候，就会设置线程的中断状态。每个线程都应该不时地检查这个标志，以判断是否可以被中断。<br>要想得出是否设置了中断状态，要先调用静态Thread.currentThread方法获取当前线程，再调用isInterrupted方法来判断。但是如果线程被阻塞，就无法检查中断状态。因而需要引入InterruptedException异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (!Thread.currentThread.isInterrupted() &amp;&amp; work to do) &#123;</span><br><span class="line">  do more work;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>interrupted和isInterrupted两个方法</p>
          </div>

<div class="note danger">
            <p>不要抑制InterruptedException异常，如果想不出catch子句可以做什么有意义的工作，仍然有两个合理的选择：</p><ol><li>在catch子句中调用Thread.currentThread().interrupt()来设置中断，这样调用者就可以检测中断。</li><li>用throws InterruptedException标记你的异常，去掉try语句，调用者就可以捕获这个异常。</li></ol>
          </div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void interrupt()</span><br><span class="line">static boolean interrupted()</span><br><span class="line">boolean isInterrupted()</span><br><span class="line">static Thread currentThread()</span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>可以通过调用 t.setDaemon(true)将一个线程转换为守护线程。守护线程的作用就是为其他线程提供服务，当仅剩下守护线程时，虚拟机就会退出。<br>计时器、清空过时缓存项都是守护线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setDaemon(boolean isDaemon)</span><br></pre></td></tr></table></figure>

<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>不推荐使用，现在基本都是交给操作系统来管理线程。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>两个线程对同一个数据进行写入，结果取决于访问数据的次序。这种情况称为竞态条件。</p>
<h3 id="竞态条件的一个例子"><a href="#竞态条件的一个例子" class="headerlink" title="竞态条件的一个例子"></a>竞态条件的一个例子</h3><p>模拟银行，使用**<em>同步存取**</em></p>
<h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><h3 id="实现方法一：继承Thread"><a href="#实现方法一：继承Thread" class="headerlink" title="实现方法一：继承Thread"></a>实现方法一：继承Thread</h3><p>每一个线程独立拥有自己的独立的字段属性，即各个线程独立运行，互不干扰。</p>
<h3 id="实现方法二：实现Runnable"><a href="#实现方法二：实现Runnable" class="headerlink" title="实现方法二：实现Runnable"></a>实现方法二：实现Runnable</h3><p>适用于数据共享，多个线程共享共同的字段属性。<br>新建一个该Runnable类，使用new Thread(runnable).start()</p>
<h2 id="线程实现问题"><a href="#线程实现问题" class="headerlink" title="线程实现问题"></a>线程实现问题</h2><p>本质都是对共享变量的操作不是原子操作。<br>思路一：对共享变量进行的一组操作，阻止其线程切换。但是抢占式线程调度，代码层面无法控制，因而无法实现。<br>思路二：给共享变量加锁，一组操作进行操作前加锁，直到进行结束时，都不解锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;同步代码块</span><br><span class="line">synchronized(LockObject object) &#123;</span><br><span class="line">	需要同步的代码...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;synchronized也可以修饰方法（类中普通成员方法），将方法作为同步的。该锁对象是个隐式锁对象（其实就是this对象）。所以，哪个对象调用该同步方法，锁对象就是哪个。</span><br><span class="line">privtae synchronized void function() &#123;</span><br><span class="line">  需要同步的代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>synchronized也可以修饰静态方法，但是此时的锁对象就不是this了，而是这个类的class对象</p>
          </div>

<p>锁对象：可以是Java对象中的任意对象。因为：</p>
<ol>
<li>Java的对象内部都有一个标志位，可以作为标记加锁和解锁状态。</li>
<li>锁对象，实际上就是充当“锁”这个角色。</li>
</ol>
<p>执行同步代码的细节：执行同步代码时，尝试对锁对象加锁。</p>
<ol>
<li>如果锁对象未锁，JVM对锁对象设标记位，并在锁对象中记录，哪个线程执行的加锁。加锁成功后开始执行。</li>
<li>如果锁对象有锁，且加锁线程不是当前线程，则系统将当前线程处于阻塞态。直到加锁线程执行完毕，并释放锁。</li>
</ol>
<p>如何释放锁：某一线程执行完毕后，退出同步代码之前，JVM自动清理锁对象标志位，改为未上锁。</p>
<h3 id="多卖"><a href="#多卖" class="headerlink" title="多卖"></a>多卖</h3><h3 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h3><h3 id="双检查（double-check）"><a href="#双检查（double-check）" class="headerlink" title="双检查（double check）"></a>双检查（double check）</h3><p>外部条件检查一次，进入同步代码块时，再检查一次，以确保绝对无误。即解决多卖还解决超卖。</p>
<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>JDK1.5之后提供了Lock锁机制。这种才是真正意义上完整的锁。因为加锁和锁解完全由自己所完成。<br>因为synchronized中的锁状态，仅仅表示锁状态，加锁和解锁完全有JVM隐式完成。</p>
<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock()</span><br><span class="line">unlock()</span><br><span class="line">&#x2F;&#x2F;实现同步代码块</span><br><span class="line">lock锁对象.lock();</span><br><span class="line">同步代码块</span><br><span class="line">lock锁对象.unlock();</span><br><span class="line">&#x2F;&#x2F;Lock的直接实现</span><br><span class="line">new ReentrantLock();</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>仅从构造代码块的角度来讲：推荐使用synchronized + Object。因为自己实现Lock会十分复杂，会出很多意向不到的问题。<br>在JDK文档中，对于Lock对象一定要用finally来进行释放锁。<br>在1.6等版本，两者加放锁效率不同，Lock锁会更快。但是在1.8之后，经过优化，两者相差几乎不多。<br>多线程工具：java.util.concurrent</p>
          </div>

<h2 id="同步的弊端：死锁"><a href="#同步的弊端：死锁" class="headerlink" title="同步的弊端：死锁"></a>同步的弊端：死锁</h2><p>如果同步出现了嵌套锁，可能会出现死锁。</p>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>把锁的执行顺序设置为相同的。</p>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>要么持有所有锁，要么一把锁都不持有。<br>例子：把所有的锁再放到一个锁中，以这个锁作为最终使用的锁。</p>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>/定义在Object中</p>
<ol>
<li>wait()</li>
<li>notify()</li>
<li>notifyAll()</li>
</ol>
<div class="note info">
            <p>wait()：</p><ol><li>使当前线程阻塞，等待其他线程调用此对象notify()或notifyAll()方法来唤醒。</li><li>当前线程必须拥有此对象对象监视器（即当前线程持有一个锁对象，只能在当前线程的锁对象上调用wait()。</li><li>执行时，释放该监视器（锁）的所有权并等待。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object o &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;才能正常运行</span><br><span class="line">synchronized(o) &#123;</span><br><span class="line">  if(condition) &#123;</span><br><span class="line">    o.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>

<div class="note info">
            <p>notify():</p><ol><li>唤醒在此对象监视器上的单个线程，被唤醒时，需要重新获取监视器（锁对象）才能继续执行。</li><li>如果有多个线程阻塞，随机选择一个唤醒。<br>notifyAll():</li><li>唤醒在此对象监视器上的所有线程。</li><li>在多个线程执行的时候，一定要使用该方法。</li><li>在调用notifyAll()时，可能会出现虚假唤醒（就是唤醒了不该唤醒的线程），所以需要在线程执行之前，都进行条件判断，来确认自己是否满足条件。</li></ol>
          </div>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>JDK1.5后提供线程池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService newCacheThreadPool()</span><br><span class="line">&#x2F;&#x2F;针对短期异步任务的线程，可提高程序效率。</span><br><span class="line">&#x2F;&#x2F;如果现有线程没有可用的，创建一个新线程加入到线程池。</span><br><span class="line">&#x2F;&#x2F;终止并从缓存中移除60s中没有运行的线程</span><br><span class="line">ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line">ExecutorService newSingleThreadExecutor()</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>对于线程池而言，可以提交两种类型的线程：</p><ol><li>Runnable子类对象，没有返回值。</li><li>Callable接口，返回范型。</li></ol>
          </div>
<h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>表示异步类计算结果</p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown()</span><br><span class="line">shutdownNow()</span><br></pre></td></tr></table></figure>

<h3 id="线程池的运作原理"><a href="#线程池的运作原理" class="headerlink" title="线程池的运作原理"></a>线程池的运作原理</h3><p>维护一个阻塞队列BlockingQueue。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>Timer，线程安排之后在后台中执行的任务，可安排任务执行一次或定期执行。</p>
<div class="note info">
            <p>与Timer对象对应的是一个后台线程，用于顺序（轮循）执行所有计时器任务。</p>
          </div>

<h3 id="终止定时器"><a href="#终止定时器" class="headerlink" title="终止定时器"></a>终止定时器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Timer下的cancel()</span><br><span class="line">TimerTask下的ancel()</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>TimerTask下的cancel()只针对于自己，将自己（TimerTask对象）从计时器中移出，所以只有在运行的时候才能cancel()</p>
          </div>


<h1 id="GC管理"><a href="#GC管理" class="headerlink" title="GC管理"></a>GC管理</h1><h2 id="JavaMemoery"><a href="#JavaMemoery" class="headerlink" title="JavaMemoery"></a>JavaMemoery</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>很小的内存区域，是线程私有的内存空间，是当前线程所执行的字节码行号指示器。</p>
<div class="note info">
            <p>每个线程都有一个程序计数器</p>
          </div>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>描述的是Java方法执行的内存模型，每个方法执行时都会生成一个栈帧，存储局部变量表，操作栈，动态链接，方法出口等信息。栈内存是线程私有的，局部变量不会被共享。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>此内存区域的唯一目的就是存放对象，一个JVM实例只存在一个堆，堆内存的大小是可以调节的。堆内存是线程共享的</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量等数据。</p>
<h2 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h2><h3 id="显式内存管理（C-C-）"><a href="#显式内存管理（C-C-）" class="headerlink" title="显式内存管理（C/C++）"></a>显式内存管理（C/C++）</h3><p>malloc、free。</p>
<div class="note warning">
            <p>野指针：<br>内存泄漏：</p>
          </div>
<h3 id="隐式内存管理（JAVA-其他）"><a href="#隐式内存管理（JAVA-其他）" class="headerlink" title="隐式内存管理（JAVA/其他）"></a>隐式内存管理（JAVA/其他）</h3><h2 id="如何判断垃圾"><a href="#如何判断垃圾" class="headerlink" title="如何判断垃圾"></a>如何判断垃圾</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>查看对象是否能被访问到：采用引用计数法。</p>
<ol>
<li>每个对象添加一个引用计数器。</li>
<li>当有个地方引用他的时候，引用计数器+1。</li>
<li>当引用失效的时候，引用计数器-1。</li>
<li>当计数器值为0的时候，对象无法被引用，表面对象不存在。<div class="note info">
            <p>当两个对象循环引用的时候，引用计数法无法判断是否存在垃圾</p>
          </div>
<h3 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h3>GC Roots包含的对象：</li>
<li>虚拟机栈中引用的对象。</li>
<li>方法区静态属性引用的对象。<div class="note info">
            <p>这两个对象，都是可以直接访问到的对象，且这两个引用指向的对象，一定可以访问到对象。</p>
          </div>
从GC Roots的节点开始，向下搜索，如果当一个对象无法通过任何一个链搜索到时，则认为该对象是垃圾。</li>
</ol>
<h2 id="如何回收垃圾"><a href="#如何回收垃圾" class="headerlink" title="如何回收垃圾"></a>如何回收垃圾</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>优点：回收很简单。<br>缺点：但是会产生内存碎片。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>在内存分配的时候，保留区域不使用；但是在内存回收的时候，使用他。<br>回收一次后，保留区域变成使用区域，使用区域清空变成空闲区域。<br>优点：没有内存碎片。<br>缺点：内存使用效率低，如果对象过多，回收效率会变慢。</p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>针对堆内存：新生代、老年代。<br>新生代：特点，朝生夕死，所以使用复制算法。8:1:1 eden:survivor:survivor。每次只使用一个survivor作为保留区域。<br>老年代：特点，稳定，持续存在，使用标记整理算法。新生代每经过一次垃圾回收，存活后计数+1，当15次后，即可进入老年代。</p>
<h2 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="GC触发时机"></a>GC触发时机</h2><h3 id="申请堆空间失败时"><a href="#申请堆空间失败时" class="headerlink" title="申请堆空间失败时"></a>申请堆空间失败时</h3><h3 id="系统进入idle后，一段时间后会进行"><a href="#系统进入idle后，一段时间后会进行" class="headerlink" title="系统进入idle后，一段时间后会进行"></a>系统进入idle后，一段时间后会进行</h3><h3 id="主动调用GC"><a href="#主动调用GC" class="headerlink" title="主动调用GC"></a>主动调用GC</h3><p>System.gc</p>
<h2 id="GC相关概念"><a href="#GC相关概念" class="headerlink" title="GC相关概念"></a>GC相关概念</h2><h3 id="Shallow-Size"><a href="#Shallow-Size" class="headerlink" title="Shallow Size"></a>Shallow Size</h3><p>对象本身占用内存大小，对象头+成员变量内存</p>
<h3 id="Retained-Size"><a href="#Retained-Size" class="headerlink" title="Retained Size"></a>Retained Size</h3><p>该对象的Shallow Size + 仅可以从自身访问的对象的Shallow Size总和。</p>
<div class="note info">
            <p>注意仅这个字，实际上就是回收该对象，总共会回收的内存大小。</p>
          </div>
<div class="note info">
            <p>内存泄漏不一定导致内存溢出。</p>
          </div>

    </div>

    
    
    

      <div>
        
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------希望对您有所帮助------</div>
    
</div>
        
      </div>

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>
	
        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/22/Zookeeper/" rel="prev" title="Zookeeper">
      <i class="fa fa-chevron-left"></i> Zookeeper
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/06/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="Java面试题">
      Java面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">Java基本程序设计结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">字符型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.4.</span> <span class="nav-text">布尔类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.5.</span> <span class="nav-text">数据类型之间的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text">变量和常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">枚举类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.1.</span> <span class="nav-text">基础运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.2.</span> <span class="nav-text">结合赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.3.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.4.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.5.</span> <span class="nav-text">运算优先级问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.6.</span> <span class="nav-text">数学函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB"><span class="nav-number">1.4.1.</span> <span class="nav-text">String类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E4%B8%B2"><span class="nav-number">1.4.2.</span> <span class="nav-text">子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5"><span class="nav-number">1.4.3.</span> <span class="nav-text">拼接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.4.4.</span> <span class="nav-text">不可变字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E7%AD%89"><span class="nav-number">1.4.5.</span> <span class="nav-text">字符串判等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E4%B8%B2%E5%92%8Cnull%E4%B8%B2"><span class="nav-number">1.4.6.</span> <span class="nav-text">空串和null串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%81%E7%82%B9%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83"><span class="nav-number">1.4.7.</span> <span class="nav-text">码点和代码单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%9A%84API"><span class="nav-number">1.4.8.</span> <span class="nav-text">String的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">1.4.9.</span> <span class="nav-text">字符串的构造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer"><span class="nav-number">1.4.9.1.</span> <span class="nav-text">StringBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuilder"><span class="nav-number">1.4.9.2.</span> <span class="nav-text">StringBuilder</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="nav-number">1.5.</span> <span class="nav-text">输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="nav-number">1.5.1.</span> <span class="nav-text">标准输入&#x2F;输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">1.5.2.</span> <span class="nav-text">格式化输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="nav-number">1.5.3.</span> <span class="nav-text">文件输入&#x2F;输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">控制流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.6.1.</span> <span class="nav-text">块作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.6.2.</span> <span class="nav-text">条件语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.6.3.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.6.4.</span> <span class="nav-text">确定循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.6.5.</span> <span class="nav-text">多重循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6"><span class="nav-number">1.6.6.</span> <span class="nav-text">中断控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0"><span class="nav-number">1.7.</span> <span class="nav-text">大数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.8.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84"><span class="nav-number">1.8.1.</span> <span class="nav-text">声明数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.8.2.</span> <span class="nav-text">访问数组元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-each%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.8.3.</span> <span class="nav-text">for each循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.8.4.</span> <span class="nav-text">数组拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">1.8.5.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.6.</span> <span class="nav-text">数组排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="nav-number">1.9.</span> <span class="nav-text">对象和类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.9.1.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.9.2.</span> <span class="nav-text">类加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA%EF%BC%9A"><span class="nav-number">1.9.3.</span> <span class="nav-text">类加载的时机：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.9.4.</span> <span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.9.5.</span> <span class="nav-text">获取Class对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8Properties%E5%AF%B9%E8%B1%A1%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="nav-number">1.9.6.</span> <span class="nav-text">利用Properties对象读取配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.7.</span> <span class="nav-text">获取类中定义的构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.8.</span> <span class="nav-text">获取类中成员变量的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.9.</span> <span class="nav-text">获得类中成员方法的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.10.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.10.1.</span> <span class="nav-text">注解的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.10.2.</span> <span class="nav-text">使用注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.10.3.</span> <span class="nav-text">注解处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BF%9D%E7%95%99%E7%BA%A7%E5%88%AB"><span class="nav-number">1.10.4.</span> <span class="nav-text">注解的保留级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.10.5.</span> <span class="nav-text">元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.10.6.</span> <span class="nav-text">注解的使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.</span> <span class="nav-text">lambda函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">2.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">2.1.</span> <span class="nav-text">处理错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.1.1.</span> <span class="nav-text">异常的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%AE%9E%E8%B4%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">异常的实质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="nav-number">2.1.3.</span> <span class="nav-text">常见异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="nav-number">2.1.4.</span> <span class="nav-text">声明检查异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">2.1.5.</span> <span class="nav-text">如何抛出异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-number">2.1.6.</span> <span class="nav-text">创建异常类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-number">2.2.</span> <span class="nav-text">捕获异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#try-catch"><span class="nav-number">2.2.1.</span> <span class="nav-text">try&#x2F;catch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E6%AC%A1%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%92%8C%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="nav-number">2.2.2.</span> <span class="nav-text">再次抛出异常和异常链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally%E5%AD%90%E5%8F%A5"><span class="nav-number">2.2.3.</span> <span class="nav-text">finally子句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-with-resources"><span class="nav-number">2.2.4.</span> <span class="nav-text">try-with-resources</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E5%A0%86%E6%A0%88%E8%BD%A8%E8%BF%B9%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.5.</span> <span class="nav-text">分析堆栈轨迹元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="nav-number">2.2.6.</span> <span class="nav-text">使用异常的技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80"><span class="nav-number">2.3.</span> <span class="nav-text">使用断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.3.1.</span> <span class="nav-text">断言的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E6%96%AD%E8%A8%80"><span class="nav-number">2.3.2.</span> <span class="nav-text">启用和禁用断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80%E5%AE%8C%E6%88%90%E5%8F%82%E6%95%B0%E6%A3%80%E6%9F%A5"><span class="nav-number">2.3.3.</span> <span class="nav-text">使用断言完成参数检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80%E6%8F%90%E4%BE%9B%E5%81%87%E8%AE%BE%E6%96%87%E6%A1%A3"><span class="nav-number">2.3.4.</span> <span class="nav-text">使用断言提供假设文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">2.4.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%97%A5%E5%BF%97"><span class="nav-number">2.4.1.</span> <span class="nav-text">基本日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%97%A5%E5%BF%97"><span class="nav-number">2.4.2.</span> <span class="nav-text">高级日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">2.4.3.</span> <span class="nav-text">修改日志管理器配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="nav-number">2.4.4.</span> <span class="nav-text">本地化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">2.4.5.</span> <span class="nav-text">处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">2.4.6.</span> <span class="nav-text">过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%99%A8"><span class="nav-number">2.4.7.</span> <span class="nav-text">格式化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%8A%80%E5%B7%A7"><span class="nav-number">2.4.8.</span> <span class="nav-text">日志技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">2.5.</span> <span class="nav-text">调试技巧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">重要的类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.1.</span> <span class="nav-text">基本概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.1.3.</span> <span class="nav-text">过滤器接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.</span> <span class="nav-text">泛型程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">为什么要定义泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">4.1.1.</span> <span class="nav-text">类型参数的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%81%E6%83%B3%E6%88%90%E4%B8%BA%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E5%91%98"><span class="nav-number">4.1.2.</span> <span class="nav-text">谁想成为泛型程序员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">4.2.</span> <span class="nav-text">定义简单的泛型类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E9%99%90%E5%AE%9A"><span class="nav-number">4.4.</span> <span class="nav-text">类型变量的限定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">4.5.</span> <span class="nav-text">泛型代码和虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">4.5.1.</span> <span class="nav-text">类型擦除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B3%9B%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.5.2.</span> <span class="nav-text">转换泛型表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">4.5.3.</span> <span class="nav-text">转换泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%81%97%E7%95%99%E4%BB%A3%E7%A0%81"><span class="nav-number">4.5.4.</span> <span class="nav-text">调用遗留代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">4.6.</span> <span class="nav-text">限制和局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">4.6.1.</span> <span class="nav-text">不能用基本类型实例化类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.6.2.</span> <span class="nav-text">运行时类型查询只适用于原始类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">4.6.3.</span> <span class="nav-text">不能创建参数化类型的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Varargs-%E8%AD%A6%E5%91%8A"><span class="nav-number">4.6.4.</span> <span class="nav-text">Varargs 警告</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-I-O%E6%B5%81"><span class="nav-number">5.</span> <span class="nav-text">Java I&#x2F;O流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E6%B5%81%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">I&#x2F;O流概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">5.2.</span> <span class="nav-text">I&#x2F;O的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91"><span class="nav-number">5.2.1.</span> <span class="nav-text">按照数据流向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.2.</span> <span class="nav-text">按照数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E6%B5%81%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%B1%BB"><span class="nav-number">5.3.</span> <span class="nav-text">I&#x2F;O流常用基类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">5.4.</span> <span class="nav-text">字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-number">5.4.1.</span> <span class="nav-text">字节流写数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">5.4.2.</span> <span class="nav-text">字节流读数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">5.4.3.</span> <span class="nav-text">字节缓冲流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">5.5.</span> <span class="nav-text">字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="nav-number">5.5.1.</span> <span class="nav-text">编码表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-number">5.5.2.</span> <span class="nav-text">转换流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BE%BF%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">5.5.3.</span> <span class="nav-text">简便文本输入输出流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">5.5.4.</span> <span class="nav-text">字符缓冲流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">6.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.1.</span> <span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">6.2.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.2.1.</span> <span class="nav-text">新建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.2.2.</span> <span class="nav-text">可运行线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.2.3.</span> <span class="nav-text">阻塞和等待线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">6.2.4.</span> <span class="nav-text">线程终止</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">6.3.</span> <span class="nav-text">线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.3.1.</span> <span class="nav-text">中断线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.3.2.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">6.3.3.</span> <span class="nav-text">线程优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">6.4.</span> <span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="nav-number">6.4.1.</span> <span class="nav-text">竞态条件的一个例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.5.</span> <span class="nav-text">线程实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread"><span class="nav-number">6.5.1.</span> <span class="nav-text">实现方法一：继承Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable"><span class="nav-number">6.5.2.</span> <span class="nav-text">实现方法二：实现Runnable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E9%97%AE%E9%A2%98"><span class="nav-number">6.6.</span> <span class="nav-text">线程实现问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%8D%96"><span class="nav-number">6.6.1.</span> <span class="nav-text">多卖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E5%8D%96"><span class="nav-number">6.6.2.</span> <span class="nav-text">超卖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%A3%80%E6%9F%A5%EF%BC%88double-check%EF%BC%89"><span class="nav-number">6.6.3.</span> <span class="nav-text">双检查（double check）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="nav-number">6.7.</span> <span class="nav-text">线程锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.7.1.</span> <span class="nav-text">Lock接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E5%BC%8A%E7%AB%AF%EF%BC%9A%E6%AD%BB%E9%94%81"><span class="nav-number">6.8.</span> <span class="nav-text">同步的弊端：死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80"><span class="nav-number">6.8.1.</span> <span class="nav-text">解决方案一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="nav-number">6.8.2.</span> <span class="nav-text">解决方案二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.9.</span> <span class="nav-text">生产者-消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">6.9.1.</span> <span class="nav-text">线程间通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.10.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors"><span class="nav-number">6.10.1.</span> <span class="nav-text">Executors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.10.2.</span> <span class="nav-text">Future接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.10.3.</span> <span class="nav-text">关闭线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">6.10.4.</span> <span class="nav-text">线程池的运作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">6.11.</span> <span class="nav-text">定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">6.11.1.</span> <span class="nav-text">定时任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">6.11.2.</span> <span class="nav-text">终止定时器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC%E7%AE%A1%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">GC管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaMemoery"><span class="nav-number">7.1.</span> <span class="nav-text">JavaMemoery</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">7.1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">7.1.2.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">7.1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%A0%86"><span class="nav-number">7.1.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">7.1.5.</span> <span class="nav-text">方法区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">内存管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88C-C-%EF%BC%89"><span class="nav-number">7.2.1.</span> <span class="nav-text">显式内存管理（C&#x2F;C++）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88JAVA-%E5%85%B6%E4%BB%96%EF%BC%89"><span class="nav-number">7.2.2.</span> <span class="nav-text">隐式内存管理（JAVA&#x2F;其他）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9E%83%E5%9C%BE"><span class="nav-number">7.3.</span> <span class="nav-text">如何判断垃圾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">7.3.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.2.</span> <span class="nav-text">根搜索算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE"><span class="nav-number">7.4.</span> <span class="nav-text">如何回收垃圾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.1.</span> <span class="nav-text">标记清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.3.</span> <span class="nav-text">标记整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-number">7.5.</span> <span class="nav-text">GC触发时机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E5%A0%86%E7%A9%BA%E9%97%B4%E5%A4%B1%E8%B4%A5%E6%97%B6"><span class="nav-number">7.5.1.</span> <span class="nav-text">申请堆空间失败时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%BF%9B%E5%85%A5idle%E5%90%8E%EF%BC%8C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%90%8E%E4%BC%9A%E8%BF%9B%E8%A1%8C"><span class="nav-number">7.5.2.</span> <span class="nav-text">系统进入idle后，一段时间后会进行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8GC"><span class="nav-number">7.5.3.</span> <span class="nav-text">主动调用GC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">7.6.</span> <span class="nav-text">GC相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Shallow-Size"><span class="nav-number">7.6.1.</span> <span class="nav-text">Shallow Size</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Retained-Size"><span class="nav-number">7.6.2.</span> <span class="nav-text">Retained Size</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tian"
      src="/images/2.jpeg">
  <p class="site-author-name" itemprop="name">Tian</p>
  <div class="site-description" itemprop="description">May you found your worth in the waking world</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/eternaleva" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eternaleva" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tian</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">223k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>
</html>
