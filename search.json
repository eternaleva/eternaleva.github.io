[{"title":"AutoWired注解方式不推荐","url":"/2021/09/08/AutoWired%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E4%B8%8D%E6%8E%A8%E8%8D%90/","content":"<h1 id=\"不推荐\"><a href=\"#不推荐\" class=\"headerlink\" title=\"不推荐\"></a>不推荐</h1><p>每次都是使用@Autowired，用习惯。直到有次发现注解报错，上面写着不推荐使用该注解。</p>\n<p>Filed注入的缺点：</p>\n<ol>\n<li>不能像构造器一样注入不可变的对象</li>\n<li>依赖对外部不可见，外界可以看到构造器和setter，但是无法看到私有字段，自然无法了解所需依赖。</li>\n<li>会导致组件和IoC容器紧耦合，离开了IoC容器就无法使用，注入依赖时也变得困难</li>\n<li>单元测试也必须使用IoC容器</li>\n<li>依赖过多时，构造器注入会显得庞大</li>\n</ol>\n<h1 id=\"官方推荐\"><a href=\"#官方推荐\" class=\"headerlink\" title=\"官方推荐\"></a>官方推荐</h1><h2 id=\"构造器注入\"><a href=\"#构造器注入\" class=\"headerlink\" title=\"构造器注入\"></a>构造器注入</h2><p>强依赖性（必须使用此依赖），不变性（依赖不会变动）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">final UserDao userDao</span><br><span class=\"line\"></span><br><span class=\"line\">public UserServiceImpl(UserDao userDao) &#123;</span><br><span class=\"line\">  this.userDao &#x3D; userDao;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Setter注入\"><a href=\"#Setter注入\" class=\"headerlink\" title=\"Setter注入\"></a>Setter注入</h2><p>弱依赖性（没有此依赖也可以工作），可变性（依赖可以变动）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private UserDao userdao;</span><br><span class=\"line\"></span><br><span class=\"line\">public void setUserDao(UserDao userDao) &#123;</span><br><span class=\"line\">  this.userDao &#x3D; userDao;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Resource注入\"><a href=\"#Resource注入\" class=\"headerlink\" title=\"@Resource注入\"></a>@Resource注入</h2>","categories":["框架"],"tags":["Spring"]},{"title":"BugList","url":"/2020/08/21/BugList/","content":"<p>Java相关的Bug清单和问题汇总</p>\n<h1 id=\"DispatcherServlet-noHandlerFound-No-mapping-for-GET-index-html\"><a href=\"#DispatcherServlet-noHandlerFound-No-mapping-for-GET-index-html\" class=\"headerlink\" title=\"DispatcherServlet.noHandlerFound No mapping for GET /index.html\"></a>DispatcherServlet.noHandlerFound No mapping for GET /index.html</h1><p>因为html是静态页面，DispatcherServlet的视图处理语言是JavaScript，无法读取html，所以需要处理Jsp文件<br>MVC没有配置静态资源处理<br>处理方法</p>\n<ul>\n<li>可以使用动态转发或重定向到View视图<br>动态处理返回视图</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;index&quot;)</span><br><span class=\"line\">public String index()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn &quot;&#x2F;WEB-INF&#x2F;index.jsp&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<ul>\n<li>配置静态资源处理:比如静态资源映射</li>\n</ul>\n<h1 id=\"Error-creating-bean-with-name-‘multipartResolver’\"><a href=\"#Error-creating-bean-with-name-‘multipartResolver’\" class=\"headerlink\" title=\"Error creating bean with name ‘multipartResolver’\"></a>Error creating bean with name ‘multipartResolver’</h1><p>可能是没有成功导入依赖，再重新导入下</p>\n<h1 id=\"请求的静态资源一直406\"><a href=\"#请求的静态资源一直406\" class=\"headerlink\" title=\"请求的静态资源一直406\"></a>请求的静态资源一直406</h1><p>排查发现是文件名字和对应的handler的mapping重复，修改文件名称即可</p>\n<h1 id=\"请求静态资源404\"><a href=\"#请求静态资源404\" class=\"headerlink\" title=\"请求静态资源404\"></a>请求静态资源404</h1><p>如果代码配置正确，则可能idea的artifact中没有正确导入静态资源，手动导入即可</p>\n<h1 id=\"注意juniper和junit的区别\"><a href=\"#注意juniper和junit的区别\" class=\"headerlink\" title=\"注意juniper和junit的区别\"></a>注意juniper和junit的区别</h1><p>注释改变，结构改变</p>\n<h1 id=\"Loading-class-‘com-mysql-jdbc-Driver’-This-is-deprecated-The-new-driver-class-is-‘com-mysql-cj-jdb\"><a href=\"#Loading-class-‘com-mysql-jdbc-Driver’-This-is-deprecated-The-new-driver-class-is-‘com-mysql-cj-jdb\" class=\"headerlink\" title=\"Loading class ‘com.mysql.jdbc.Driver’. This is deprecated. The new driver class is ‘com.mysql.cj.jdb\"></a>Loading class ‘com.mysql.jdbc.Driver’. This is deprecated. The new driver class is ‘com.mysql.cj.jdb</h1><h1 id=\"如何在MyBatis的mappers-class中返回List\"><a href=\"#如何在MyBatis的mappers-class中返回List\" class=\"headerlink\" title=\"如何在MyBatis的mappers class中返回List\"></a>如何在MyBatis的mappers class中返回List</h1><p>写一个JavaBean<br>接口返回类型为List<br>接口映射文件xml中，映射id增加 parameterType=”HashMap” resultType=”JavaBean的全类名”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class=\"line\">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class=\"line\">&lt;!--namespace就是该映射文件的唯一id，映射文件的namespace(命名空间)不能重复--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;mapper namespace&#x3D;&quot;homework.mybatis_test.UserMapper&quot;&gt;</span><br><span class=\"line\">    &lt;select id&#x3D;&quot;selectUser&quot; parameterType&#x3D;&quot;HashMap&quot; resultType&#x3D;&quot;homework.mybatis_test.User&quot;&gt;</span><br><span class=\"line\">        select userId, userName, password from user where userName &#x3D; #&#123;userName&#125; and password &#x3D; #&#123;password&#125;</span><br><span class=\"line\">    &lt;&#x2F;select&gt;</span><br><span class=\"line\">    &lt;insert id&#x3D;&quot;insertUser&quot;&gt;</span><br><span class=\"line\">        insert into user (userName, password) value (#&#123;userName&#125;, #&#123;password&#125;)</span><br><span class=\"line\">    &lt;&#x2F;insert&gt;</span><br><span class=\"line\">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Parameter-‘stock’-not-found-Available-parameters-are-arg1-arg0-param1-param2\"><a href=\"#Parameter-‘stock’-not-found-Available-parameters-are-arg1-arg0-param1-param2\" class=\"headerlink\" title=\"Parameter ‘stock’ not found. Available parameters are [arg1, arg0, param1, param2]\"></a>Parameter ‘stock’ not found. Available parameters are [arg1, arg0, param1, param2]</h1><p>Mybatis的mappers class 传递多个参数会不知道哪个参数对应哪个，需要在接口中，使用@Param(“参数名”)的注释</p>\n<h1 id=\"Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-SQL-Mapper-Configuration-Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-Mapper-XML-The-XML-location-is-‘mapper-ArmyMapper-xml’-Cause-java-lang-IllegalStateException-Mapping-is-missing-column-attribute-for-property-ArmyId\"><a href=\"#Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-SQL-Mapper-Configuration-Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-Mapper-XML-The-XML-location-is-‘mapper-ArmyMapper-xml’-Cause-java-lang-IllegalStateException-Mapping-is-missing-column-attribute-for-property-ArmyId\" class=\"headerlink\" title=\"### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is ‘mapper/ArmyMapper.xml’. Cause: java.lang.IllegalStateException: Mapping is missing column attribute for property ArmyId\"></a>### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is ‘mapper/ArmyMapper.xml’. Cause: java.lang.IllegalStateException: Mapping is missing column attribute for property ArmyId</h1><p>result标签没有添加columu属性</p>\n<h1 id=\"Mybatis写好了resultMap，但是提示class-not-found\"><a href=\"#Mybatis写好了resultMap，但是提示class-not-found\" class=\"headerlink\" title=\"Mybatis写好了resultMap，但是提示class not found\"></a>Mybatis写好了resultMap，但是提示class not found</h1><p>可能是select标签的resultMap写成了resultType</p>\n<h1 id=\"No-‘Access-Control-Allow-Origin’-header-is-present-on-the-requested-resource\"><a href=\"#No-‘Access-Control-Allow-Origin’-header-is-present-on-the-requested-resource\" class=\"headerlink\" title=\"No ‘Access-Control-Allow-Origin’ header is present on the requested resource.\"></a>No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</h1><p>没进行跨域处理<br>Spring进行配置CorsFilter，Servlet则进行Filter处理</p>\n<h1 id=\"SpringBoot相关\"><a href=\"#SpringBoot相关\" class=\"headerlink\" title=\"SpringBoot相关\"></a>SpringBoot相关</h1><h2 id=\"SpringBootApplication找不到组件\"><a href=\"#SpringBootApplication找不到组件\" class=\"headerlink\" title=\"SpringBootApplication找不到组件\"></a>SpringBootApplication找不到组件</h2><p>解决方法：包路径下要包括所有组件；或者使用@ComponentScan(“包路径”)扫描获得</p>\n<h2 id=\"java-lang-String-out-of-START-ARRAY-token\"><a href=\"#java-lang-String-out-of-START-ARRAY-token\" class=\"headerlink\" title=\"java.lang.String out of START_ARRAY token\"></a><code>java.lang.String</code> out of START_ARRAY token</h2><p>因为String不能为null，使用Object来接收</p>\n<h2 id=\"ArrayList-can-not-to-String\"><a href=\"#ArrayList-can-not-to-String\" class=\"headerlink\" title=\"ArrayList can not to String\"></a>ArrayList can not to String</h2><p>使用.toString</p>\n<h2 id=\"Vo返回值封装失败\"><a href=\"#Vo返回值封装失败\" class=\"headerlink\" title=\"Vo返回值封装失败\"></a>Vo返回值封装失败</h2><p>看看mapper.xml的标签里有没有加resultMap</p>\n<h2 id=\"RequestBody的使用需要加载MappingJackson2HttpMessageConverter，但是SpringBoot的官方文档提到，这个是默认已经加载的了，而且json字符串和javabean也没有书写的错误\"><a href=\"#RequestBody的使用需要加载MappingJackson2HttpMessageConverter，但是SpringBoot的官方文档提到，这个是默认已经加载的了，而且json字符串和javabean也没有书写的错误\" class=\"headerlink\" title=\"@RequestBody的使用需要加载MappingJackson2HttpMessageConverter，但是SpringBoot的官方文档提到，这个是默认已经加载的了，而且json字符串和javabean也没有书写的错误\"></a>@RequestBody的使用需要加载MappingJackson2HttpMessageConverter，但是SpringBoot的官方文档提到，这个是默认已经加载的了，而且json字符串和javabean也没有书写的错误</h2><h1 id=\"数组输出\"><a href=\"#数组输出\" class=\"headerlink\" title=\"数组输出\"></a>数组输出</h1><p>Arrays.toString<br>Arrays.asList</p>\n<h1 id=\"com-fasterxml-jackson-databind-exc-InvalidDefinitionException-No-serializer-found-for-class-com-cskaoyan-bean-vo-RoleVo-and-no-properties-discovered-to-create-BeanSerializer\"><a href=\"#com-fasterxml-jackson-databind-exc-InvalidDefinitionException-No-serializer-found-for-class-com-cskaoyan-bean-vo-RoleVo-and-no-properties-discovered-to-create-BeanSerializer\" class=\"headerlink\" title=\"com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class com.cskaoyan.bean.vo.RoleVo and no properties discovered to create BeanSerializer\"></a>com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class com.cskaoyan.bean.vo.RoleVo and no properties discovered to create BeanSerializer</h1><p>没有增加@Data注解，所以封装失败</p>\n<h1 id=\"Mybatis-typeHandler没有执行\"><a href=\"#Mybatis-typeHandler没有执行\" class=\"headerlink\" title=\"Mybatis typeHandler没有执行\"></a>Mybatis typeHandler没有执行</h1><p>resultMap中需要转换的属性添加typeHandler</p>\n<p>对应xml的mysql语句，标签写上对应的resultMap</p>\n<h1 id=\"uri-后跟的参数不能通过-RequestBody获取\"><a href=\"#uri-后跟的参数不能通过-RequestBody获取\" class=\"headerlink\" title=\"uri?后跟的参数不能通过@RequestBody获取\"></a>uri?后跟的参数不能通过@RequestBody获取</h1><h1 id=\"TypeHandler处理Integer\"><a href=\"#TypeHandler处理Integer\" class=\"headerlink\" title=\"TypeHandler处理Integer\"></a>TypeHandler处理Integer</h1><p>要使用ArrayList范型的数据类型</p>\n<h1 id=\"Mysql连表不返回一边的null\"><a href=\"#Mysql连表不返回一边的null\" class=\"headerlink\" title=\"Mysql连表不返回一边的null\"></a>Mysql连表不返回一边的null</h1><p>使用WHERE</p>\n<h1 id=\"gitignore不生效\"><a href=\"#gitignore不生效\" class=\"headerlink\" title=\".gitignore不生效\"></a>.gitignore不生效</h1><p>.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，或者用git status查看状态，想要忽略的文件还是显示被追踪状态。<br>原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，<br>这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。</p>\n<h1 id=\"SpringBoot无法返回视图\"><a href=\"#SpringBoot无法返回视图\" class=\"headerlink\" title=\"SpringBoot无法返回视图\"></a>SpringBoot无法返回视图</h1><p>参考StackOverFlow: <img src=\"https://stackoverflow.com/questions/49364084/spring-boot-cannot-resolve-view-page\"></p>\n<h1 id=\"树莓派root账户无法登陆sftp怎么办\"><a href=\"#树莓派root账户无法登陆sftp怎么办\" class=\"headerlink\" title=\"树莓派root账户无法登陆sftp怎么办\"></a>树莓派root账户无法登陆sftp怎么办</h1><p>默认不允许root通过ssh登录，而且一般复制数据也不需要root用，你用普通用户复制上去，再登录ssh去修改所属即可。<br>当然，实在需要，其实可以配置ssh服务，<br>修改/etc/ssh/sshd_config 文件，<br>修改 #PermitRootLogin prohibit-password 为 PermitRootLogin yes<br>注意要取消前面的#号的。<br>然后 sudo /etc/init.d/ssh restart 来重启sshd服务即可。</p>\n<h1 id=\"Npm的前端换环境运行错误\"><a href=\"#Npm的前端换环境运行错误\" class=\"headerlink\" title=\"Npm的前端换环境运行错误\"></a>Npm的前端换环境运行错误</h1><p>需要把npm环境依赖删掉，重新使用npm构建依赖，然后运行</p>\n<h1 id=\"vmess\"><a href=\"#vmess\" class=\"headerlink\" title=\"vmess\"></a>vmess</h1><p>{浏览器} &lt;–(socks)–&gt; {V2Ray 客户端 inbound &lt;-&gt; V2Ray 客户端 outbound} &lt;–(VMess)–&gt;  {V2Ray 服务器 inbound &lt;-&gt; V2Ray 服务器 outbound} &lt;–(Freedom)–&gt; {目标网站}</p>\n<h1 id=\"dubbo-No-qualifying-bean-of-type\"><a href=\"#dubbo-No-qualifying-bean-of-type\" class=\"headerlink\" title=\"dubbo No qualifying bean of type\"></a>dubbo No qualifying bean of type</h1><p>consumer和provider的API接口class全类名一定要相同</p>\n<h1 id=\"Spring配置好-Component，但是报No-qualifying-bean-of-type\"><a href=\"#Spring配置好-Component，但是报No-qualifying-bean-of-type\" class=\"headerlink\" title=\"Spring配置好@Component，但是报No qualifying bean of type\"></a>Spring配置好@Component，但是报No qualifying bean of type</h1><p>可能类名与某些配置名、或自动生成的某些bean名重复，修改类名。</p>\n<h1 id=\"jakarta-servlet-ServletException-xxxServlet不是Servlet等问题\"><a href=\"#jakarta-servlet-ServletException-xxxServlet不是Servlet等问题\" class=\"headerlink\" title=\"jakarta.servlet.ServletException: xxxServlet不是Servlet等问题\"></a>jakarta.servlet.ServletException: xxxServlet不是Servlet等问题</h1><p>Spring集成Tomcat10 Web的Bug，因为Tomcat10使用的Servlet5.0，所使用的包是jakarta.servlet而不是javax.servlet，需要导入另外的依赖。<br><img src=\"/2020/08/21/BugList/Tomcat10%E4%BE%9D%E8%B5%96.png\"></p>\n<div class=\"note info\">\n            <p>如果要开发servlet5.0，要用jakarta的包。</p>\n          </div>\n\n<h1 id=\"Cannot-create-inner-bean-‘-inner-bean-207ea13’-of-type-org-springframework-aop-aspectj-AspectJExpressionPointcut-while-setting-bean-property-‘pointcut’\"><a href=\"#Cannot-create-inner-bean-‘-inner-bean-207ea13’-of-type-org-springframework-aop-aspectj-AspectJExpressionPointcut-while-setting-bean-property-‘pointcut’\" class=\"headerlink\" title=\"Cannot create inner bean ‘(inner bean)#207ea13’ of type [org.springframework.aop.aspectj.AspectJExpressionPointcut] while setting bean property ‘pointcut’\"></a>Cannot create inner bean ‘(inner bean)#207ea13’ of type [org.springframework.aop.aspectj.AspectJExpressionPointcut] while setting bean property ‘pointcut’</h1><p>缺少aspectJ包，导入即可</p>\n<h1 id=\"元素类型为-“configuration”-的内容必须匹配-“-properties-settings-typeAliases-typeHandlers-objectFactory-objectWrapperFactory-reflectorFactory-plugins-environments-databaseIdProvider-mappers-”\"><a href=\"#元素类型为-“configuration”-的内容必须匹配-“-properties-settings-typeAliases-typeHandlers-objectFactory-objectWrapperFactory-reflectorFactory-plugins-environments-databaseIdProvider-mappers-”\" class=\"headerlink\" title=\"元素类型为 “configuration” 的内容必须匹配 “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”\"></a>元素类型为 “configuration” 的内容必须匹配 “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”</h1><p>Mybatis的configuration要根据这个参数顺序来配置。</p>\n<h1 id=\"mysql设置了default值，还是报错not-null\"><a href=\"#mysql设置了default值，还是报错not-null\" class=\"headerlink\" title=\"mysql设置了default值，还是报错not null\"></a>mysql设置了default值，还是报错not null</h1><p>因为表设置为not null，因此没传入值时会进行报错</p>\n<h1 id=\"Java静态添加范型，需要\"><a href=\"#Java静态添加范型，需要\" class=\"headerlink\" title=\"Java静态添加范型，需要\"></a>Java静态添加范型，需要</h1><p><img src=\"/2020/08/21/BugList/%E9%9D%99%E6%80%81%E8%8C%83%E5%9E%8B.png\"></p>\n<h1 id=\"Jackson不支持LocalDateTime\"><a href=\"#Jackson不支持LocalDateTime\" class=\"headerlink\" title=\"Jackson不支持LocalDateTime\"></a>Jackson不支持LocalDateTime</h1><p>在属性上添加注解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@JsonDeserialize(using &#x3D; LocalDateTimeDeserializer.class)</span><br><span class=\"line\">@JsonSerialize(using &#x3D; LocalDateTimeSerializer.class)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"jackson-ObjectMapper的enableDefaultTyping方法过期\"><a href=\"#jackson-ObjectMapper的enableDefaultTyping方法过期\" class=\"headerlink\" title=\"jackson.ObjectMapper的enableDefaultTyping方法过期\"></a>jackson.ObjectMapper的enableDefaultTyping方法过期</h1><p>objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY);</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/zzhongcy/article/details/105813105\">https://blog.csdn.net/zzhongcy/article/details/105813105</a></p>\n<h1 id=\"org-apache-rocketmq-spring-core-RocketMQTemplate’-that-could-not-be-found\"><a href=\"#org-apache-rocketmq-spring-core-RocketMQTemplate’-that-could-not-be-found\" class=\"headerlink\" title=\"org.apache.rocketmq.spring.core.RocketMQTemplate’ that could not be found.\"></a>org.apache.rocketmq.spring.core.RocketMQTemplate’ that could not be found.</h1><p>因为yml配置文件没有配置RocketMq的信息</p>\n<h1 id=\"org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found\"><a href=\"#org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found\" class=\"headerlink\" title=\"org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)\"></a>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</h1><h1 id=\"商城cookie的刷新问题\"><a href=\"#商城cookie的刷新问题\" class=\"headerlink\" title=\"商城cookie的刷新问题\"></a>商城cookie的刷新问题</h1><p>时间到了，会清掉cookie，但是没有清掉redis的缓存。</p>\n<h1 id=\"Mybatis-plus-整合SpringBoot自动填充不生效原因\"><a href=\"#Mybatis-plus-整合SpringBoot自动填充不生效原因\" class=\"headerlink\" title=\"Mybatis-plus 整合SpringBoot自动填充不生效原因\"></a>Mybatis-plus 整合SpringBoot自动填充不生效原因</h1><p>entity的成员变量名和MetaHandler中名字不一致。</p>\n","categories":["Bug"],"tags":["开发记录"]},{"title":"C-疑问集","url":"/2022/05/18/C-%E7%96%91%E9%97%AE%E9%9B%86/","content":"<h1 id=\"一、内存分配\"><a href=\"#一、内存分配\" class=\"headerlink\" title=\"一、内存分配\"></a>一、内存分配</h1><h2 id=\"结构体数组的初始化\"><a href=\"#结构体数组的初始化\" class=\"headerlink\" title=\"结构体数组的初始化\"></a>结构体数组的初始化</h2><ol>\n<li>先定义结构体，再定义数组</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>       </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span> gender;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">stus</span>[16];</span>  </span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>结构体和数组同时定义</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>       </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span> gender;</span><br><span class=\"line\">&#125; stus[<span class=\"number\">16</span>];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"局部指针，如果中途指向了malloc的堆空间，结束的时候会释放吗？\"><a href=\"#局部指针，如果中途指向了malloc的堆空间，结束的时候会释放吗？\" class=\"headerlink\" title=\"局部指针，如果中途指向了malloc的堆空间，结束的时候会释放吗？\"></a>局部指针，如果中途指向了malloc的堆空间，结束的时候会释放吗？</h2><p>不会的，如果指向了堆空间，还是需要自己手动释放。</p>\n<h1 id=\"二、函数\"><a href=\"#二、函数\" class=\"headerlink\" title=\"二、函数\"></a>二、函数</h1><h2 id=\"C如何使用默认参数？\"><a href=\"#C如何使用默认参数？\" class=\"headerlink\" title=\"C如何使用默认参数？\"></a>C如何使用默认参数？</h2><h1 id=\"三、库\"><a href=\"#三、库\" class=\"headerlink\" title=\"三、库\"></a>三、库</h1><h2 id=\"标准库\"><a href=\"#标准库\" class=\"headerlink\" title=\"标准库\"></a>标准库</h2><h3 id=\"stdlib是做什么用？\"><a href=\"#stdlib是做什么用？\" class=\"headerlink\" title=\"stdlib是做什么用？\"></a>stdlib是做什么用？</h3><h3 id=\"string-h\"><a href=\"#string-h\" class=\"headerlink\" title=\"string.h\"></a>string.h</h3><p>复制相关：</p>\n<ol>\n<li>strncpy<br> 功能：字符串复制，指定size<br> 缺点：不复制‘\\0’，会导致缓冲区溢出的问题。</li>\n<li>strcpy<br> 功能：字符串复制，包含‘\\0’<br> 缺点：不检查size和’\\0’是否存不存在，会导致缓冲区溢出的问题。</li>\n<li>strlcpy<br> 功能：修复strncpy的问题<br> 非标准库</li>\n<li>strlcat</li>\n</ol>\n<p>字符串分离：</p>\n<ol>\n<li>strtok<br> 功能：以一个字符串集合中的任一字符作为分隔符来处理。<br> 缺点：非线程安全</li>\n</ol>\n<p>定位：</p>\n<ol>\n<li> <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strchr</span>(<span class=\"keyword\">char</span> *begin, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>);</span><br></pre></td></tr></table></figure></li>\n<li></li>\n</ol>\n<h2 id=\"第三方库\"><a href=\"#第三方库\" class=\"headerlink\" title=\"第三方库\"></a>第三方库</h2><h3 id=\"Redis里的红锁（red-lock）是什么\"><a href=\"#Redis里的红锁（red-lock）是什么\" class=\"headerlink\" title=\"Redis里的红锁（red-lock）是什么?\"></a>Redis里的红锁（red-lock）是什么?</h3><p>红锁是一种分布式锁</p>\n","categories":["编程语言"],"tags":["C","疑问集"]},{"title":"C++疑问集","url":"/2023/09/03/C++%E7%96%91%E9%97%AE%E9%9B%86/","content":"<h1 id=\"一-类定义相关\"><a href=\"#一-类定义相关\" class=\"headerlink\" title=\"一. 类定义相关\"></a>一. 类定义相关</h1><h2 id=\"1-如何理解带有静态属性（static-member）的非静态类（non-static-class）\"><a href=\"#1-如何理解带有静态属性（static-member）的非静态类（non-static-class）\" class=\"headerlink\" title=\"1. 如何理解带有静态属性（static member）的非静态类（non-static class）\"></a>1. 如何理解带有静态属性（static member）的非静态类（non-static class）</h2><p>In C++, a non-static class with a static member means that the class is not static, but it contains a static member.</p>\n<p>A non-static class is a regular class where you can create multiple instances (objects) of the class, and each instance has its own copy of the class’s non-static data members.</p>\n<p>On the other hand, a static member (which can be a variable or a method) belongs to the class itself, not to any specific instance of the class. This means that there is only one copy of the static member, regardless of how many instances of the class you create. All instances of the class share this single copy of the static member.</p>\n<h2 id=\"2-引用做成员和指针做成员有什么区别？\"><a href=\"#2-引用做成员和指针做成员有什么区别？\" class=\"headerlink\" title=\"2. 引用做成员和指针做成员有什么区别？\"></a>2. 引用做成员和指针做成员有什么区别？</h2><p>引用：作为数据成员，必须在构造时初始化。<br>指针：可以在类构造完成后，再进行构造，相对更加灵活。</p>\n<h1 id=\"二、智能指针相关\"><a href=\"#二、智能指针相关\" class=\"headerlink\" title=\"二、智能指针相关\"></a>二、智能指针相关</h1><h2 id=\"1-shared-ptr作为参数，应该使用值传递还是引用传递？\"><a href=\"#1-shared-ptr作为参数，应该使用值传递还是引用传递？\" class=\"headerlink\" title=\"1. shared_ptr作为参数，应该使用值传递还是引用传递？\"></a>1. shared_ptr作为参数，应该使用值传递还是引用传递？</h2><h1 id=\"三、引用和生命周期\"><a href=\"#三、引用和生命周期\" class=\"headerlink\" title=\"三、引用和生命周期\"></a>三、引用和生命周期</h1><h2 id=\"1-引用作为返回值，会创建新的对象吗？\"><a href=\"#1-引用作为返回值，会创建新的对象吗？\" class=\"headerlink\" title=\"1. 引用作为返回值，会创建新的对象吗？\"></a>1. 引用作为返回值，会创建新的对象吗？</h2><p>最佳实践：返回函数的引用去初始化一个新的引用，不会创建新的对象。</p>\n<h1 id=\"STL库相关\"><a href=\"#STL库相关\" class=\"headerlink\" title=\"STL库相关\"></a>STL库相关</h1><h2 id=\"vector为什么可以传递给数组指针？\"><a href=\"#vector为什么可以传递给数组指针？\" class=\"headerlink\" title=\"vector为什么可以传递给数组指针？\"></a>vector为什么可以传递给数组指针？</h2><p>epoll_wait 的 events 参数是一个指向 epoll_event 结构体的指针，用于存储从 epoll 实例接收到的事件。在 C++ 中，std::vector 是一个动态数组，它可以存储任意类型的元素。因此，当你有一个 std::vector<epoll_event> 时，你可以通过获取其数据指针来传递给 epoll_wait。</epoll_event></p>\n<h2 id=\"为什么STL的对象，可以不进行初始化？\"><a href=\"#为什么STL的对象，可以不进行初始化？\" class=\"headerlink\" title=\"为什么STL的对象，可以不进行初始化？\"></a>为什么STL的对象，可以不进行初始化？</h2><h2 id=\"Lower-bound和upper-bound\"><a href=\"#Lower-bound和upper-bound\" class=\"headerlink\" title=\"Lower_bound和upper_bound\"></a>Lower_bound和upper_bound</h2><h3 id=\"结果是什么？\"><a href=\"#结果是什么？\" class=\"headerlink\" title=\"结果是什么？\"></a>结果是什么？</h3><h3 id=\"底层实现是什么？\"><a href=\"#底层实现是什么？\" class=\"headerlink\" title=\"底层实现是什么？\"></a>底层实现是什么？</h3><p>使用的是二分查找</p>\n<h1 id=\"四、设计模式相关\"><a href=\"#四、设计模式相关\" class=\"headerlink\" title=\"四、设计模式相关\"></a>四、设计模式相关</h1><h2 id=\"单例的类作为基类，子类继承它可以生成多种对象吗？\"><a href=\"#单例的类作为基类，子类继承它可以生成多种对象吗？\" class=\"headerlink\" title=\"单例的类作为基类，子类继承它可以生成多种对象吗？\"></a>单例的类作为基类，子类继承它可以生成多种对象吗？</h2>","categories":["编程语言"],"tags":["C++"]},{"title":"Dubbo","url":"/2020/09/13/Dubbo/","content":"<p>dubbo是将服务转变为微服务的框架</p>\n<h1 id=\"Sping-dubbo（阿里版本）\"><a href=\"#Sping-dubbo（阿里版本）\" class=\"headerlink\" title=\"Sping + dubbo（阿里版本）\"></a>Sping + dubbo（阿里版本）</h1><h2 id=\"导包\"><a href=\"#导包\" class=\"headerlink\" title=\"导包\"></a>导包</h2><h2 id=\"Provider-xml配置\"><a href=\"#Provider-xml配置\" class=\"headerlink\" title=\"Provider xml配置\"></a>Provider xml配置</h2><h2 id=\"Consumer-xml配置\"><a href=\"#Consumer-xml配置\" class=\"headerlink\" title=\"Consumer xml配置\"></a>Consumer xml配置</h2><h1 id=\"SpringBoot-dubbo（阿里版本）\"><a href=\"#SpringBoot-dubbo（阿里版本）\" class=\"headerlink\" title=\"SpringBoot + dubbo（阿里版本）\"></a>SpringBoot + dubbo（阿里版本）</h1><p>provider和consumer共同拥有一个继承的接口(要么单独写一个模块，然后共用；要么使用相同的api接口)<br>然后Provider向Spring提供Bean，Consumer从Spring（再通过dubbo）获取Bean。Provider和Consumer的共用类都要同时注册成为Spring组件<br>@EnableDubboConfiguation</p>\n<h1 id=\"SpringBoot-dubbo（apache版本）\"><a href=\"#SpringBoot-dubbo（apache版本）\" class=\"headerlink\" title=\"SpringBoot + dubbo（apache版本）\"></a>SpringBoot + dubbo（apache版本）</h1><h1 id=\"SpringBoot-dubbo-apache-zookeeper\"><a href=\"#SpringBoot-dubbo-apache-zookeeper\" class=\"headerlink\" title=\"SpringBoot + dubbo (apache) + zookeeper\"></a>SpringBoot + dubbo (apache) + zookeeper</h1><h2 id=\"导包-1\"><a href=\"#导包-1\" class=\"headerlink\" title=\"导包\"></a>导包</h2><h2 id=\"配置Provider-Consumer\"><a href=\"#配置Provider-Consumer\" class=\"headerlink\" title=\"配置Provider/Consumer\"></a>配置Provider/Consumer</h2><h2 id=\"运行zkServer\"><a href=\"#运行zkServer\" class=\"headerlink\" title=\"运行zkServer\"></a>运行zkServer</h2><h2 id=\"配置Springboot文件\"><a href=\"#配置Springboot文件\" class=\"headerlink\" title=\"配置Springboot文件\"></a>配置Springboot文件</h2><h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h1 id=\"dubbo的集群\"><a href=\"#dubbo的集群\" class=\"headerlink\" title=\"dubbo的集群\"></a>dubbo的集群</h1><h1 id=\"启动检查\"><a href=\"#启动检查\" class=\"headerlink\" title=\"启动检查\"></a>启动检查</h1><p>@DubboService(check=false, timeout=2000, retries=0)</p>\n","categories":["框架"],"tags":["分布式","微服务"]},{"title":"Docker","url":"/2021/08/17/Docker/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"为什么会出现Docker\"><a href=\"#为什么会出现Docker\" class=\"headerlink\" title=\"为什么会出现Docker\"></a>为什么会出现Docker</h2><p>环境需要开发和上线，两套环境<br>环境配置麻烦，环境问题也会经常出现。<br>所以需要，发布项目的时候，打包的时候把环境一起打包起来。<br>如今开发、打包、部署、上线，一套流程走完。<br>主要是当前技术存在问题，所以需要新的东西来去解决。</p>\n<h2 id=\"Docker历史\"><a href=\"#Docker历史\" class=\"headerlink\" title=\"Docker历史\"></a>Docker历史</h2><p>dotCloud — 做pass的云计算服务，慢慢做了一套linux容器化技术<br>然后将该技术命名为Docker。<br>2013年，公司活不下去，然后宣布开源。<br>使用人越来越多后，每个月更新一个版本。<br>Docker技术之前，比较火的是虚拟机技术，Docker是容器技术，本质其实也是虚拟机技术。<br>Docker基于Go语言开发</p>\n<h2 id=\"官网\"><a href=\"#官网\" class=\"headerlink\" title=\"官网\"></a>官网</h2><p><a href=\"https://www.docker.com/\">https://www.docker.com</a><br>文档地址：<a href=\"https://docs.docker.com/\">https://docs.docker.com</a><br>仓库地址： <a href=\"https://hub.docker.com/\">https://hub.docker.com</a></p>\n<h2 id=\"容器化技术和虚拟机技术的区别\"><a href=\"#容器化技术和虚拟机技术的区别\" class=\"headerlink\" title=\"容器化技术和虚拟机技术的区别\"></a>容器化技术和虚拟机技术的区别</h2><p>虚拟机技术：虚拟一个完整的系统，包含各种硬件，安装和运行应用<br>容器化技术：模拟的不是全部的系统，容器直接运行在宿主机的内核，容器没有自己的内核，也没有虚拟硬件，且容器间是隔离的，互不干扰。</p>\n<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><h2 id=\"应用更快速的开发和部署\"><a href=\"#应用更快速的开发和部署\" class=\"headerlink\" title=\"应用更快速的开发和部署\"></a>应用更快速的开发和部署</h2><h2 id=\"更好的升级和扩缩容\"><a href=\"#更好的升级和扩缩容\" class=\"headerlink\" title=\"更好的升级和扩缩容\"></a>更好的升级和扩缩容</h2><h2 id=\"更简单的系统运维\"><a href=\"#更简单的系统运维\" class=\"headerlink\" title=\"更简单的系统运维\"></a>更简单的系统运维</h2><h2 id=\"更高效的资源利用\"><a href=\"#更高效的资源利用\" class=\"headerlink\" title=\"更高效的资源利用\"></a>更高效的资源利用</h2><h1 id=\"Docker组成\"><a href=\"#Docker组成\" class=\"headerlink\" title=\"Docker组成\"></a>Docker组成</h1><h2 id=\"镜像（image）\"><a href=\"#镜像（image）\" class=\"headerlink\" title=\"镜像（image）\"></a>镜像（image）</h2><p>镜像有点像一个模板，容器可以按照这个模板执行操作。</p>\n<h2 id=\"容器（container）\"><a href=\"#容器（container）\" class=\"headerlink\" title=\"容器（container）\"></a>容器（container）</h2><p>容器，运行的镜像，独立运行一个或一组应用，一个简易的环境。<br>启动、停止、删除等基本命令。</p>\n<h2 id=\"仓库（repository）\"><a href=\"#仓库（repository）\" class=\"headerlink\" title=\"仓库（repository）\"></a>仓库（repository）</h2><p>存放镜像的地方<br>私有仓库、公有仓库。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>见官方文档：<a href=\"https://docs.docker.com/engine/install/\">https://docs.docker.com/engine/install/</a></p>\n<ol>\n<li>卸载旧版本</li>\n<li>安装环境</li>\n<li>配置docker仓库<br>建议配置docker的阿里云仓库</li>\n<li>安装docker引擎</li>\n<li>启动docker<br>systemctl start docker</li>\n<li>运行测试<br>docker run xxx.image<br><img src=\"/2021/08/17/Docker/docker-run.png\"></li>\n<li>查看下载的镜像是否存在<br>docker images</li>\n</ol>\n<div class=\"note info\">\n            <p>docker默认工作路径：/var/lib/docker</p>\n          </div>\n<h2 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h2><h2 id=\"阿里云镜像加速\"><a href=\"#阿里云镜像加速\" class=\"headerlink\" title=\"阿里云镜像加速\"></a>阿里云镜像加速</h2><ol>\n<li>登陆阿里云</li>\n<li>镜像服务——镜像加速期</li>\n</ol>\n<h1 id=\"Docker底层原理\"><a href=\"#Docker底层原理\" class=\"headerlink\" title=\"Docker底层原理\"></a>Docker底层原理</h1><p>C/S结构的系统<br>docker-server接收docker-cli的指令，然后执行这些指令。</p>\n<ol>\n<li>Docker拥有比虚拟机更少的抽象层</li>\n<li>Docker利用宿主的内核</li>\n</ol>\n<h1 id=\"Docker常用命令\"><a href=\"#Docker常用命令\" class=\"headerlink\" title=\"Docker常用命令\"></a>Docker常用命令</h1><p>具体详细命令见文档：</p>\n<h2 id=\"帮助命令\"><a href=\"#帮助命令\" class=\"headerlink\" title=\"帮助命令\"></a>帮助命令</h2><h3 id=\"docker-version\"><a href=\"#docker-version\" class=\"headerlink\" title=\"docker version\"></a>docker version</h3><h3 id=\"docker-info\"><a href=\"#docker-info\" class=\"headerlink\" title=\"docker info\"></a>docker info</h3><h3 id=\"docker-命令-–help\"><a href=\"#docker-命令-–help\" class=\"headerlink\" title=\"docker 命令 –help\"></a>docker 命令 –help</h3><h3 id=\"等等\"><a href=\"#等等\" class=\"headerlink\" title=\"等等\"></a>等等</h3><h2 id=\"镜像命令\"><a href=\"#镜像命令\" class=\"headerlink\" title=\"镜像命令\"></a>镜像命令</h2><h3 id=\"docker-images-可选参数\"><a href=\"#docker-images-可选参数\" class=\"headerlink\" title=\"docker images [可选参数]\"></a>docker images [可选参数]</h3><p>查看本地镜像<br>Repository：镜像仓库源<br>TAG：镜像标签<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小</p>\n<div class=\"note info\">\n            <p>可选参数：<br>  -a：-all<br>  -q：-quiet 只显示id</p>\n          </div>\n<h3 id=\"docker-search-可选参数\"><a href=\"#docker-search-可选参数\" class=\"headerlink\" title=\"docker search [可选参数]\"></a>docker search [可选参数]</h3><p>docker仓库搜索</p>\n<div class=\"note info\">\n            <p>可选参数：<br>  –filter=条件</p>\n          </div>\n<h3 id=\"docker-pull-镜像名-tag\"><a href=\"#docker-pull-镜像名-tag\" class=\"headerlink\" title=\"docker pull [镜像名:tag]\"></a>docker pull [镜像名:tag]</h3><p>下载镜像，如果不写tag，默认是下载latest<br>docker是分层下载，已经拥有的东西不会下载。<br><img src=\"/2021/08/17/Docker/docker-pull.png\"></p>\n<h3 id=\"docker-rmi-id…\"><a href=\"#docker-rmi-id…\" class=\"headerlink\" title=\"docker rmi [id…]\"></a>docker rmi [id…]</h3><ol>\n<li>docker rmi id<br>id可以简写，部分字符即可以确定唯一id镜像</li>\n<li>docker rmi id1 id2 id3<br>删除多个镜像</li>\n<li><code>docker rmi -f $(docker images -aq)</code><br>全部删除镜像（递归删除）</li>\n</ol>\n<h2 id=\"容器命令\"><a href=\"#容器命令\" class=\"headerlink\" title=\"容器命令\"></a>容器命令</h2><h3 id=\"docker-run-可选参数-image\"><a href=\"#docker-run-可选参数-image\" class=\"headerlink\" title=\"docker run [可选参数] image\"></a>docker run [可选参数] image</h3><div class=\"note info\">\n            <p>可选参数：<br>  –name=”name”：指定容器名字l<br>  -d：后台方式运行<br>  -it：-i -t的缩写，使用交互方式运行，进入容器查看内容<br>  -P：指定端口  主机映射端口：容器端口<br>  -p：随机端口</p>\n          </div>\n\n\n<h3 id=\"docker-start-容器id\"><a href=\"#docker-start-容器id\" class=\"headerlink\" title=\"docker start [容器id]\"></a>docker start [容器id]</h3><h3 id=\"docker-restart-容器id\"><a href=\"#docker-restart-容器id\" class=\"headerlink\" title=\"docker restart [容器id]\"></a>docker restart [容器id]</h3><h3 id=\"docker-stop-容器id\"><a href=\"#docker-stop-容器id\" class=\"headerlink\" title=\"docker stop [容器id]\"></a>docker stop [容器id]</h3><h3 id=\"docker-kill-容器id\"><a href=\"#docker-kill-容器id\" class=\"headerlink\" title=\"docker kill [容器id]\"></a>docker kill [容器id]</h3><h3 id=\"docker-ps-可选参数\"><a href=\"#docker-ps-可选参数\" class=\"headerlink\" title=\"docker ps [可选参数]\"></a>docker ps [可选参数]</h3><div class=\"note info\">\n            <p>可选参数：<br>  -a：列出当前正在运行的容器 + 历史运行的容器（所有）<br>  -n=x：显示最近创建的x个容器<br>  -aq：当前所有运行的容器</p>\n          </div>\n\n<h3 id=\"退出容器\"><a href=\"#退出容器\" class=\"headerlink\" title=\"退出容器\"></a>退出容器</h3><p>exit：停止并退出容器<br>ctrl + p + q：退出容器（不停止）</p>\n<h3 id=\"docker-rm-可选参数-容器id\"><a href=\"#docker-rm-可选参数-容器id\" class=\"headerlink\" title=\"docker rm [可选参数]  [容器id]\"></a>docker rm [可选参数]  [容器id]</h3><p>删除容器（不能删除正在运行的）<br>强制删除 <code>docker rm -f $(docker ps -aq)</code></p>\n<h2 id=\"常用其他命令\"><a href=\"#常用其他命令\" class=\"headerlink\" title=\"常用其他命令\"></a>常用其他命令</h2><h3 id=\"docker-run-d-容器名\"><a href=\"#docker-run-d-容器名\" class=\"headerlink\" title=\"docker run -d [容器名]\"></a>docker run -d [容器名]</h3><p>后台启动</p>\n<div class=\"note warning\">\n            <p>docker容器使用后台运行的时候，就必须要有前台进程。而当docker发现没有前台应用的时候，就会自动停止。</p>\n          </div>\n\n<h3 id=\"docker-logs-f-n-num-t-容器id\"><a href=\"#docker-logs-f-n-num-t-容器id\" class=\"headerlink\" title=\"docker logs -f -n num -t [容器id]\"></a>docker logs -f -n num -t [容器id]</h3><p>查看日志<br>-f：Follow log output<br>-t：Show timestamps<br>-n num：Number of lines to show from the end of the logs</p>\n<h3 id=\"docker-top-容器id\"><a href=\"#docker-top-容器id\" class=\"headerlink\" title=\"docker top [容器id]\"></a>docker top [容器id]</h3><p>查看容器内的信息</p>\n<h3 id=\"docker-inspect-容器id\"><a href=\"#docker-inspect-容器id\" class=\"headerlink\" title=\"docker inspect [容器id]\"></a>docker inspect [容器id]</h3><p>查看镜像的元数据</p>\n<h3 id=\"docker-exec-i-t-容器id-bin-bash\"><a href=\"#docker-exec-i-t-容器id-bin-bash\" class=\"headerlink\" title=\"docker exec -i -t [容器id] /bin/bash\"></a>docker exec -i -t [容器id] /bin/bash</h3><p>进入运行的容器，并启动一个新的终端，执行命令。<br>我们有时候需要进入容器，修改一些配置</p>\n<h3 id=\"docker-attach-容器id\"><a href=\"#docker-attach-容器id\" class=\"headerlink\" title=\"docker attach  [容器id]\"></a>docker attach  [容器id]</h3><p>attach 不会在容器中创建进程（终端）执行额外的命令，只是附着到容器上.</p>\n<h3 id=\"docker-cp-容器id-容器内路径-主机路径\"><a href=\"#docker-cp-容器id-容器内路径-主机路径\" class=\"headerlink\" title=\"docker cp 容器id:容器内路径 主机路径\"></a>docker cp 容器id:容器内路径 主机路径</h3><p>复制容器的内容到主机。</p>\n<div class=\"note info\">\n            <p>拷贝是手动，后续可以使用-v 来实现自动管理</p>\n          </div>\n\n<h3 id=\"docker-stats\"><a href=\"#docker-stats\" class=\"headerlink\" title=\"docker stats\"></a>docker stats</h3><p>查看docker运行状态，没有u</p>\n<h1 id=\"Docker官方指导操作\"><a href=\"#Docker官方指导操作\" class=\"headerlink\" title=\"Docker官方指导操作\"></a>Docker官方指导操作</h1><p><a href=\"https://docs.docker.com/get-started/\">https://docs.docker.com/get-started/</a><br>按照步骤来，可以熟悉docker的基本使用</p>\n<h1 id=\"Docker练习\"><a href=\"#Docker练习\" class=\"headerlink\" title=\"Docker练习\"></a>Docker练习</h1><h2 id=\"部署mysql\"><a href=\"#部署mysql\" class=\"headerlink\" title=\"部署mysql\"></a>部署mysql</h2><h2 id=\"部署tomcat\"><a href=\"#部署tomcat\" class=\"headerlink\" title=\"部署tomcat\"></a>部署tomcat</h2><p>官方建议<br>docker run -it –rm tomcat: 版本<br>–rm 用来测试，容器用完之后，就删除容器。（ps 找不到，但是images可以看到）</p>\n<h2 id=\"部署ES-kibana\"><a href=\"#部署ES-kibana\" class=\"headerlink\" title=\"部署ES+kibana\"></a>部署ES+kibana</h2><p>修改es配置文件，-e 配置内容 运行<br>比如-e ES_JAVA_OPTS=”-Xms256m -Xmx1024m”</p>\n<h1 id=\"Portainer和Rancher\"><a href=\"#Portainer和Rancher\" class=\"headerlink\" title=\"Portainer和Rancher\"></a>Portainer和Rancher</h1><p>portainer ： docker图形化管理工具</p>\n<h1 id=\"Docker镜像原理\"><a href=\"#Docker镜像原理\" class=\"headerlink\" title=\"Docker镜像原理\"></a>Docker镜像原理</h1><p>docker镜像是一个独立的软件包，包括代码、运行时、环境库以及变量和配置文件等。</p>\n<h2 id=\"镜像加载原理\"><a href=\"#镜像加载原理\" class=\"headerlink\" title=\"镜像加载原理\"></a>镜像加载原理</h2><p>UnionFS（联合文件系统），分层、轻量级并且高性能的文件系统。<br>支持对文件系统的修改作为一次一次的提交叠加。可以把不同目录的文件挂载到同一个虚拟文件系统下。</p>\n<h3 id=\"BootFS\"><a href=\"#BootFS\" class=\"headerlink\" title=\"BootFS\"></a>BootFS</h3><p>包含bootloader和kernel，容器启动时，会加载BootFS的系统文件。当boot加载完成，容器系统的内核代码均在内存中，然后将内存使用权由bootfs交给内核，此时容器会卸载BootFS</p>\n<h3 id=\"RootFS\"><a href=\"#RootFS\" class=\"headerlink\" title=\"RootFS\"></a>RootFS</h3><p>标准linux的目录和文件系统</p>\n","categories":["运维"],"tags":["容器技术"]},{"title":"ES6","url":"/2021/08/03/ES6/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>ES6 是 ECMAScript6的简写，是JavaScript的下一代前端标准。制定了前端的多种书写规范</p>\n<h1 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h1><h2 id=\"定义变量\"><a href=\"#定义变量\" class=\"headerlink\" title=\"定义变量\"></a>定义变量</h2><p>在body的script下</p>\n<ol>\n<li>var：可以定义多次</li>\n<li>let：局部变量，只在代码块中生效；只能定义一次</li>\n</ol>\n<h2 id=\"定义常量\"><a href=\"#定义常量\" class=\"headerlink\" title=\"定义常量\"></a>定义常量</h2><p>const PI = “3.1415926”</p>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><ol>\n<li>数组解构<br>let [x, y, z] = [1, 2, 3];<br>console.log(x, y, z);<br>就是把1，2，3分别赋值给x，y，z</li>\n<li>对象解构<br>let  {name, age} = user;  //把user的值取出来赋值给name和age（对象的属性名一致）<br>console.log(name, age)</li>\n</ol>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>使用数字1左边的小点 圈起来，里面可以用${}来获取内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &quot;tian&quot;;</span><br><span class=\"line\">let age &#x3D; 26;</span><br><span class=\"line\">let info &#x3D; &#96;$&#123;a&#125; &#x3D; 1, $&#123;age + 1&#125;&#96;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"声明对象简写\"><a href=\"#声明对象简写\" class=\"headerlink\" title=\"声明对象简写\"></a>声明对象简写</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &quot;tian&quot;;</span><br><span class=\"line\">let age &#x3D; 26;</span><br><span class=\"line\">let user &#x3D; &#123;a, age&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象拓展运算符\"><a href=\"#对象拓展运算符\" class=\"headerlink\" title=\"对象拓展运算符\"></a>对象拓展运算符</h2><p>可以用于复制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let person &#x3D; &#123;name:&quot;tian&quot;, age:18&#125;;</span><br><span class=\"line\">let someone &#x3D; &#123;...person&#125;;</span><br><span class=\"line\">console.log(someone);</span><br></pre></td></tr></table></figure>\n\n<p>可以用于合并</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let name &#x3D; &#123;name : &quot;Amy&quot;&#125;;</span><br><span class=\"line\">let age &#x3D; &#123;age : 15&#125;;</span><br><span class=\"line\">let person &#x3D; &#123;...name, ...age&#125;;</span><br><span class=\"line\">console.log(person);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数箭头\"><a href=\"#函数箭头\" class=\"headerlink\" title=\"函数箭头\"></a>函数箭头</h2><p>参数 =&gt; 函数体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var f1 &#x3D; a &#x3D;&gt; a + 4;</span><br><span class=\"line\">console.log(f1(4));</span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["编程语言"],"tags":["前端"]},{"title":"EasyExcel","url":"/2021/08/11/EasyExcel/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>使用Java对Excel进行读写的工具</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"引入依赖\"><a href=\"#引入依赖\" class=\"headerlink\" title=\"引入依赖\"></a>引入依赖</h2><h2 id=\"创建实体类\"><a href=\"#创建实体类\" class=\"headerlink\" title=\"创建实体类\"></a>创建实体类</h2><p>实体属性添加注解@ExcelProperty(“xxx”)</p>\n<h2 id=\"设置文件路径和文件名\"><a href=\"#设置文件路径和文件名\" class=\"headerlink\" title=\"设置文件路径和文件名\"></a>设置文件路径和文件名</h2><h2 id=\"调用方法实现写和读\"><a href=\"#调用方法实现写和读\" class=\"headerlink\" title=\"调用方法实现写和读\"></a>调用方法实现写和读</h2><h3 id=\"写\"><a href=\"#写\" class=\"headerlink\" title=\"写\"></a>写</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeExcel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List userList = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        ExcelModel excelModel = <span class=\"keyword\">new</span> ExcelModel();</span><br><span class=\"line\">        excelModel.setUserId(i);</span><br><span class=\"line\">        excelModel.setPassword(<span class=\"string\">&quot;q123456&quot;</span>);</span><br><span class=\"line\">        userList.add(excelModel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//文件路径</span></span><br><span class=\"line\">    String filePath = <span class=\"string\">&quot;/Users/tian/Documents/EasyExcel.xlsx&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EasyExcel.write(filePath, ExcelModel.class)</span><br><span class=\"line\">    .sheet(<span class=\"string\">&quot;用户信息&quot;</span>)</span><br><span class=\"line\">    .doWrite(userList);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读\"><a href=\"#读\" class=\"headerlink\" title=\"读\"></a>读</h3><p>@ExcelProperty(value=”xxx”, index=x)<br>index是下标对应关系</p>\n<ol>\n<li>设置监听器ExcelListener<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExcelListener</span> <span class=\"keyword\">extends</span> <span class=\"title\">AnalysisEventListener</span>&lt;<span class=\"title\">ExcelModel</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//按行读取，从第二行读取，因为第一行是表头</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">invoke</span><span class=\"params\">(ExcelModel excelModel, AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(excelModel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取表头</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">invokeHeadMap</span><span class=\"params\">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;表头信息&quot;</span> + headMap);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取之后执行</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doAfterAllAnalysed</span><span class=\"params\">(AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>读取文件<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readExcel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//文件路径</span></span><br><span class=\"line\">    String filePath = <span class=\"string\">&quot;/Users/tian/Documents/EasyExcel.xlsx&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EasyExcel.read(filePath, ExcelModel.class, <span class=\"keyword\">new</span> ExcelListener())</span><br><span class=\"line\">       .sheet(<span class=\"string\">&quot;用户信息&quot;</span>)</span><br><span class=\"line\">       .doRead();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":["框架"],"tags":["Excel"]},{"title":"ElasticSearch","url":"/2021/12/01/ElasticSearch/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>强大的搜索开源引擎</p>\n<h1 id=\"正向索引和倒排索引\"><a href=\"#正向索引和倒排索引\" class=\"headerlink\" title=\"正向索引和倒排索引\"></a>正向索引和倒排索引</h1><h2 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h2><ol>\n<li>Document（文档）：每条数据就是一个文档</li>\n<li>term（词条）：将内容按照语义分成词条</li>\n<li>id：数据id</li>\n</ol>\n<p>先分词条，先查词条，再查文档</p>\n<h1 id=\"ES数据格式\"><a href=\"#ES数据格式\" class=\"headerlink\" title=\"ES数据格式\"></a>ES数据格式</h1><p>ElasticSearch是面向文档存储的，文档数据会被序列化为Json格式存储。</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"安装ES\"><a href=\"#安装ES\" class=\"headerlink\" title=\"安装ES\"></a>安装ES</h2><h2 id=\"Kibana\"><a href=\"#Kibana\" class=\"headerlink\" title=\"Kibana\"></a>Kibana</h2><h2 id=\"IK分词器插件\"><a href=\"#IK分词器插件\" class=\"headerlink\" title=\"IK分词器插件\"></a>IK分词器插件</h2><p>IK分词器的两个模式</p>\n<ol>\n<li>ik_smart</li>\n<li>ik_max_word<br>拓展词库</li>\n</ol>\n<h1 id=\"索引库操作\"><a href=\"#索引库操作\" class=\"headerlink\" title=\"索引库操作\"></a>索引库操作</h1><h2 id=\"mapping映射\"><a href=\"#mapping映射\" class=\"headerlink\" title=\"mapping映射\"></a>mapping映射</h2><h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h3><ol>\n<li>字符串：text、keyword</li>\n<li>数值：long、integer、short、byte、double、float</li>\n<li>布尔：boolean</li>\n<li>日期：date</li>\n<li>对象：object</li>\n</ol>\n<p>es自带数组类型，允许一个类型有多个值。</p>\n<h3 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h3><p>是否创建索引、默认true</p>\n<h3 id=\"analyzer\"><a href=\"#analyzer\" class=\"headerlink\" title=\"analyzer\"></a>analyzer</h3><p>分词器</p>\n<h3 id=\"properties\"><a href=\"#properties\" class=\"headerlink\" title=\"properties\"></a>properties</h3><p>一个字段的子字段</p>\n<h2 id=\"DSL操作\"><a href=\"#DSL操作\" class=\"headerlink\" title=\"DSL操作\"></a>DSL操作</h2><p>基本语法</p>\n<h3 id=\"创建索引库\"><a href=\"#创建索引库\" class=\"headerlink\" title=\"创建索引库\"></a>创建索引库</h3><p>PUT /索引库</p>\n<h3 id=\"查询索引库\"><a href=\"#查询索引库\" class=\"headerlink\" title=\"查询索引库\"></a>查询索引库</h3><p>GET /索引库</p>\n<h3 id=\"修改索引库\"><a href=\"#修改索引库\" class=\"headerlink\" title=\"修改索引库\"></a>修改索引库</h3><p>索引库和Mapping一旦建立，无法修改，但是可以添加新的Mapping字段<br>添加字段</p>\n<p><code>PUT /索引库/_mapping</code></p>\n<h3 id=\"删除索引库\"><a href=\"#删除索引库\" class=\"headerlink\" title=\"删除索引库\"></a>删除索引库</h3><p>DELETE /索引库</p>\n<h3 id=\"新增文档\"><a href=\"#新增文档\" class=\"headerlink\" title=\"新增文档\"></a>新增文档</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST &#x2F;索引库&#x2F;_doc&#x2F;文档id</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Json</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查询文档\"><a href=\"#查询文档\" class=\"headerlink\" title=\"查询文档\"></a>查询文档</h3><h3 id=\"删除文档\"><a href=\"#删除文档\" class=\"headerlink\" title=\"删除文档\"></a>删除文档</h3><div class=\"note info\">\n            <p>每次操作（除了GET），都会导致文档版本增加</p>\n          </div>\n\n<h3 id=\"修改文档\"><a href=\"#修改文档\" class=\"headerlink\" title=\"修改文档\"></a>修改文档</h3><ol>\n<li>全量修改<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PUT &#x2F;索引库&#x2F;_doc&#x2F;文档id</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Json</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n删除旧文档，添加新文档</li>\n<li>增量修改<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST &#x2F;索引库&#x2F;_doc&#x2F;文档id</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;doc&quot;:</span><br><span class=\"line\">    &#123;字段&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h1 id=\"RestClient操作索引库\"><a href=\"#RestClient操作索引库\" class=\"headerlink\" title=\"RestClient操作索引库\"></a>RestClient操作索引库</h1><h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><p>copy_to</p>\n<h2 id=\"导包\"><a href=\"#导包\" class=\"headerlink\" title=\"导包\"></a>导包</h2><pre><code>\n\n \n \n</code></pre>\n","categories":["框架"],"tags":["搜索引擎"]},{"title":"Git","url":"/2020/09/04/Git/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h1 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h1><h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name  &quot;xxx&quot;</span><br><span class=\"line\">git config --global user.email &quot;xxx&quot;</span><br><span class=\"line\">git config --global user.password &quot;xxx&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch newBranch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销add\"><a href=\"#撤销add\" class=\"headerlink\" title=\"撤销add\"></a>撤销add</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; --staged 参数就是表示仅仅恢复暂存区的</span><br><span class=\"line\">git restore --staged “file”</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;表示撤销 README.md 文件工作区的的修改</span><br><span class=\"line\">git restore --worktree README.md</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;表示将当前工作区切换到上个 commit 版本</span><br><span class=\"line\">git restore -s HEAD~1 README.md</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;表示将当前工作区切换到指定 commit id 的版本</span><br><span class=\"line\">git restore -s dbv213 README.md</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"直接克隆分支\"><a href=\"#直接克隆分支\" class=\"headerlink\" title=\"直接克隆分支\"></a>直接克隆分支</h1><p><code>git clone -b 分支名 &lt;remote_repo&gt;</code></p>\n<h1 id=\"git-restore-和-git-restore-–staged-的区别\"><a href=\"#git-restore-和-git-restore-–staged-的区别\" class=\"headerlink\" title=\"git restore 和 git restore –staged 的区别\"></a>git restore 和 git restore –staged 的区别</h1><p><code>git restore --staged &lt;file&gt;</code>: 撤销 暂存区<br><code>git restore &lt;file&gt;</code>: 撤销 本地修改</p>\n<h1 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h1>","categories":["版本工具"],"tags":["Git"]},{"title":"Filter","url":"/2021/04/20/Filter/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>过滤器是Servlet规范的高级特性。<br>过滤器（Filter）技术是从Servlet2.3规范开始引入的。过滤器是一种Web应用程序组件，可以部署在Web应用程序中。<br>过滤器由Servlet容器调用，用来拦截以及处理请求和响应。<br>过滤器本身并不能生成请求和响应对象，但是可以对请求和响应对象进行检查和修改。</p>\n<span id=\"more\"></span> \n\n<h1 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h1><p>过滤器介于【客户端】与【Servlet】等相关的资源之间，对于与过滤器关联的Servlet来说，过滤器可以在Servlet被调用之前检查并且修改request对象。在Servlet调用之后检查并修改response对象。<br><img src=\"/2021/04/20/Filter/%E8%BF%87%E6%BB%A4%E5%99%A8.png\"></p>\n<h2 id=\"详细细节\"><a href=\"#详细细节\" class=\"headerlink\" title=\"详细细节\"></a>详细细节</h2><ol>\n<li>客户端将请求发送给Web容器；</li>\n<li>Web容器根据客户端发送的请求生成请求对象request和响应对象response。</li>\n<li>Web容器在调用与过滤器相关联的Web组件（例如Servlet/JSP）之前，先将request对象、response对象发送给过滤器。</li>\n<li>过滤器对【request】对象进行必要的处理；</li>\n<li>过滤器把处理过的request对象以及response对象传递给Web组件；</li>\n<li>Web组件调用完成后，再次通过过滤器，此时过滤器对【response】对象进行必要的处理；</li>\n<li>过滤器把处理过的response对象传递给Web容器；</li>\n<li>Web容器将响应的结果返回到客户端，并在浏览器上显示。</li>\n</ol>\n<h1 id=\"编写Filter\"><a href=\"#编写Filter\" class=\"headerlink\" title=\"编写Filter\"></a>编写Filter</h1><ol>\n<li>实现一个类实现Filter接口</li>\n<li>注册（注解或者Web.xml）</li>\n</ol>\n<p><img src=\"/2021/04/20/Filter/Filter.png\"></p>\n<h2 id=\"将Filter和Servlet关联\"><a href=\"#将Filter和Servlet关联\" class=\"headerlink\" title=\"将Filter和Servlet关联\"></a>将Filter和Servlet关联</h2><p>使用Url-pattern关联，把Servlet的url-pattern赋值给Filter。此时Filter是拦截操作，如果要放行，则需要加下面代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">filterChain.doFilter(servletRequest, servletResponse);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Filter的url-pattern可以设置为-吗\"><a href=\"#Filter的url-pattern可以设置为-吗\" class=\"headerlink\" title=\"Filter的url-pattern可以设置为/*吗\"></a>Filter的url-pattern可以设置为/*吗</h2><p>可以，并且对Servlet没有影响。此时要在拦截器配置好编码格式（设置好Request编码和Response编码格式。<br><img src=\"/2021/04/20/Filter/%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png\"></p>\n<h2 id=\"多个Servlet不可以设置同一个url-pattern，但是多个Filter可以。\"><a href=\"#多个Servlet不可以设置同一个url-pattern，但是多个Filter可以。\" class=\"headerlink\" title=\"多个Servlet不可以设置同一个url-pattern，但是多个Filter可以。\"></a>多个Servlet不可以设置同一个url-pattern，但是多个Filter可以。</h2><p>含义即为多个拦截器同时拦截同一个url-pattern请求，先后调用Filter。顺序按照Mapping的声明顺序为准，注解的话则以类名的ASCII码顺序为准。</p>\n<div class=\"note info\">\n            <p>返回的顺序，按照栈递归顺序，先进的后返回。</p>\n          </div>\n\n<h1 id=\"Filter案例：登陆\"><a href=\"#Filter案例：登陆\" class=\"headerlink\" title=\"Filter案例：登陆\"></a>Filter案例：登陆</h1><h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2>","categories":["Web服务器"],"tags":["Web"]},{"title":"Hibernate-validator","url":"/2021/05/25/Hibernate-validator/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>校验和模型绑定起来 → 请求参数和javabean中的成员变量绑定起来 → 校验逻辑和javabean中的成员变量绑定起来</p>\n<span id=\"more\"></span>\n\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"导包\"><a href=\"#导包\" class=\"headerlink\" title=\"导包\"></a>导包</h2><p><img src=\"/2021/05/25/Hibernate-validator/%E5%AF%BC%E5%8C%85.png\"></p>\n<h2 id=\"配置在Spring-WebMVC\"><a href=\"#配置在Spring-WebMVC\" class=\"headerlink\" title=\"配置在Spring-WebMVC\"></a>配置在Spring-WebMVC</h2><p><img src=\"/2021/05/25/Hibernate-validator/%E9%85%8D%E7%BD%AEHibernateValidator.png\"></p>\n<h2 id=\"使用Validator\"><a href=\"#使用Validator\" class=\"headerlink\" title=\"使用Validator\"></a>使用Validator</h2><p>@Validator和@Valid两个注解任选其一<br><img src=\"/2021/05/25/Hibernate-validator/%E4%BD%BF%E7%94%A8.png\"></p>\n<h1 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h1><p>常见的注解 （Bean Validation 中内置的 constraint）<br>@Null   被注释的元素必须为 null<br>@NotNull    被注释的元素必须不为 null<br>@Size(max=, min=)   被注释的元素的大小必须在指定的范围内<br>@AssertTrue     被注释的元素必须为 true<br>@AssertFalse    被注释的元素必须为 false<br>@Min(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@Max(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@Digits (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内<br>@Past   被注释的元素必须是一个过去的日期 Date<br>@Future     被注释的元素必须是一个将来的日期<br>@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式<br>Hibernate Validator 附加的 constraint<br>@NotBlank(message =)   验证字符串非null，且长度必须大于0<br>@Email  被注释的元素必须是电子邮箱地址<br>@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内<br>@NotEmpty   被注释的字符串的必须非空<br>@Range(min=,max=,message=)  被注释的元素必须在合适的范围内</p>\n<h1 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h1><h2 id=\"参数校验错误信息\"><a href=\"#参数校验错误信息\" class=\"headerlink\" title=\"参数校验错误信息\"></a>参数校验错误信息</h2><p>BindResult类：可以知道哪个参数有错误。</p>\n<h3 id=\"hasFieldErrors\"><a href=\"#hasFieldErrors\" class=\"headerlink\" title=\"hasFieldErrors\"></a>hasFieldErrors</h3><h3 id=\"getFiledError\"><a href=\"#getFiledError\" class=\"headerlink\" title=\"getFiledError\"></a>getFiledError</h3><h3 id=\"getFiled\"><a href=\"#getFiled\" class=\"headerlink\" title=\"getFiled\"></a>getFiled</h3><h3 id=\"getRejectedValue\"><a href=\"#getRejectedValue\" class=\"headerlink\" title=\"getRejectedValue\"></a>getRejectedValue</h3><p>等等方法</p>\n<h2 id=\"自定义错误信息\"><a href=\"#自定义错误信息\" class=\"headerlink\" title=\"自定义错误信息\"></a>自定义错误信息</h2><p><img src=\"/2021/05/25/Hibernate-validator/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF.png\"></p>\n<h2 id=\"和MessageSource混合\"><a href=\"#和MessageSource混合\" class=\"headerlink\" title=\"和MessageSource混合\"></a>和MessageSource混合</h2><p><img src=\"/2021/05/25/Hibernate-validator/MessageSource1.png\"><br><img src=\"/2021/05/25/Hibernate-validator/MessageSource2.png\"></p>\n","categories":["框架"],"tags":["参数验证"]},{"title":"JDK","url":"/2021/12/27/JDK/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><span id=\"more\"></span>\n<h1 id=\"JDK8\"><a href=\"#JDK8\" class=\"headerlink\" title=\"JDK8\"></a>JDK8</h1><h2 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h2><p>用来对接口，实现其对应方法的函数式编程方式。<br>应用</p>\n<h3 id=\"FunctionalInterface\"><a href=\"#FunctionalInterface\" class=\"headerlink\" title=\"@FunctionalInterface\"></a>@FunctionalInterface</h3><p>函数式接口，里面只能定义个方法。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ol>\n<li>匿名内部类原理：会生成一个匿名的类文件</li>\n<li>lambda：在程序运行的时候，内部生成一个类，类里面是lambda表达式。再生成一个匿名内部类，并实现接口，重写方法（重写内容就是执行刚开始生成含有lambda表达式的类）</li>\n</ol>\n<p>-Djdk.internal.lambda.dumpProxyClasses 运行包名 类名<br>这个参数可以将内部class码输出到一个文件</p>\n<h3 id=\"省略写法\"><a href=\"#省略写法\" class=\"headerlink\" title=\"省略写法\"></a>省略写法</h3><h3 id=\"使用前提\"><a href=\"#使用前提\" class=\"headerlink\" title=\"使用前提\"></a>使用前提</h3><ol>\n<li>方法的参数或局部变量类型必须为接口才能使用</li>\n<li>接口中有且仅有一个抽象方法</li>\n</ol>\n<h3 id=\"与匿名内部类对比\"><a href=\"#与匿名内部类对比\" class=\"headerlink\" title=\"与匿名内部类对比\"></a>与匿名内部类对比</h3><ol>\n<li>所需类型不一样</li>\n</ol>\n<ul>\n<li>匿名内部类：类、抽象类、接口</li>\n<li>lambda：必须是接口</li>\n</ul>\n<ol start=\"2\">\n<li>抽象方法数量不一样</li>\n</ol>\n<ul>\n<li>匿名内部类：方法数量没要求</li>\n<li>lambda：必须一个</li>\n</ul>\n<ol start=\"3\">\n<li>实现原理不同</li>\n</ol>\n<ul>\n<li>匿名内部类：编译后生成类</li>\n<li>lambda：运行时，动态生成</li>\n</ul>\n<h2 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h2><p>只关心抽象方法的参数列表和返回值类型</p>\n<h3 id=\"常用函数时接口\"><a href=\"#常用函数时接口\" class=\"headerlink\" title=\"常用函数时接口\"></a>常用函数时接口</h3><p>java.util.function</p>\n<ol>\n<li><p>Supplier<br>生成数据的</p>\n</li>\n<li><p>Consumer<br>消费数据的<br>默认方法：andThen()</p>\n</li>\n<li><p>Function<br>执行转换用的，将原始对象，转换为目标对象<br>默认方法：andThen()、compose()<br>静态方法：indentity()</p>\n</li>\n<li><p>Predicate<br>默认方法：and()、negate()、or()<br>静态方法：</p>\n</li>\n</ol>\n<h2 id=\"接口新增的方法\"><a href=\"#接口新增的方法\" class=\"headerlink\" title=\"接口新增的方法\"></a>接口新增的方法</h2><p>接口可以有<strong>默认方法</strong>和<strong>静态方法</strong>。</p>\n<h3 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h3><p>接口的所有实现类，都必须重写抽象方法，不利于接口拓展。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">返回类型 default function() &#123;</span><br><span class=\"line\">    function body;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">返回类型 static function() &#123;</span><br><span class=\"line\">    function body;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不能被重写，不能被继承</p>\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><h3 id=\"对象名-方法名\"><a href=\"#对象名-方法名\" class=\"headerlink\" title=\"对象名::方法名\"></a>对象名::方法名</h3><ol>\n<li>被引用的方法，参数要和接口中抽象方法的参数一样。</li>\n<li>接口抽象方法有返回值时，被引用的方法也必须有返回值。</li>\n</ol>\n<h3 id=\"类名-静态方法名\"><a href=\"#类名-静态方法名\" class=\"headerlink\" title=\"类名::静态方法名\"></a>类名::静态方法名</h3><h3 id=\"类名-引用实例方法\"><a href=\"#类名-引用实例方法\" class=\"headerlink\" title=\"类名::引用实例方法\"></a>类名::引用实例方法</h3><h3 id=\"类名-构造器\"><a href=\"#类名-构造器\" class=\"headerlink\" title=\"类名::构造器\"></a>类名::构造器</h3><h3 id=\"数组-构造器\"><a href=\"#数组-构造器\" class=\"headerlink\" title=\"数组::构造器\"></a>数组::构造器</h3><h2 id=\"Stream流\"><a href=\"#Stream流\" class=\"headerlink\" title=\"Stream流\"></a>Stream流</h2><p>类似于流水线处理，不是一种数据结构，不保存数据，而是数据加工处理。</p>\n<h3 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h3><ol>\n<li>Collection</li>\n<li>Stream.of()</li>\n</ol>\n<h1 id=\"JDK9\"><a href=\"#JDK9\" class=\"headerlink\" title=\"JDK9\"></a>JDK9</h1><h1 id=\"JDK10\"><a href=\"#JDK10\" class=\"headerlink\" title=\"JDK10\"></a>JDK10</h1><h1 id=\"JDK11\"><a href=\"#JDK11\" class=\"headerlink\" title=\"JDK11\"></a>JDK11</h1><h1 id=\"JDK14\"><a href=\"#JDK14\" class=\"headerlink\" title=\"JDK14\"></a>JDK14</h1><h1 id=\"JDK17\"><a href=\"#JDK17\" class=\"headerlink\" title=\"JDK17\"></a>JDK17</h1>","categories":["编程语言"],"tags":["Java"]},{"title":"JSON","url":"/2021/04/14/JSON/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>是数据格式，而不是语言。很多编程语言都有针对Json的解析器。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"JavaScript声明对象\"><a href=\"#JavaScript声明对象\" class=\"headerlink\" title=\"JavaScript声明对象\"></a>JavaScript声明对象</h2><p>对象里可以包含对象和数组。</p>\n<div class=\"note info\">\n            <p>大括号里是的对象，中括号里的是数组或集合。</p>\n          </div>\n\n<h2 id=\"Json格式和Xml格式的区别\"><a href=\"#Json格式和Xml格式的区别\" class=\"headerlink\" title=\"Json格式和Xml格式的区别\"></a>Json格式和Xml格式的区别</h2><h2 id=\"Json对象和Json字符串\"><a href=\"#Json对象和Json字符串\" class=\"headerlink\" title=\"Json对象和Json字符串\"></a>Json对象和Json字符串</h2><p>Json字符串的属性值上有双引号。</p>\n<h1 id=\"Java语言操作字符串\"><a href=\"#Java语言操作字符串\" class=\"headerlink\" title=\"Java语言操作字符串\"></a>Java语言操作字符串</h1><h2 id=\"Java对象转换为Json字符串\"><a href=\"#Java对象转换为Json字符串\" class=\"headerlink\" title=\"Java对象转换为Json字符串\"></a>Java对象转换为Json字符串</h2><ol>\n<li>手动填写</li>\n<li>使用工具类（Gson/FastJson）<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;toJson</span><br><span class=\"line\">Gson.toJson(java.lang.Object src)</span><br><span class=\"line\">&#x2F;&#x2F;fromJson</span><br><span class=\"line\">Gson.fromJson(java.lang.String json, java.lang.Class&lt;T&gt; classOfT)</span><br><span class=\"line\">&#x2F;&#x2F;如果是List数组，可以用TypeToken</span><br><span class=\"line\">Type listType &#x3D; new TypeToken&lt;List&lt;String&gt;&gt;() &#123;&#125;.getType();</span><br><span class=\"line\">List&lt;String&gt; target &#x3D; gson.fromJson(json, listType);</span><br><span class=\"line\">&#x2F;&#x2F;或者使用JsonParser（已过时）</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"Json字符串转换为Java对象\"><a href=\"#Json字符串转换为Java对象\" class=\"headerlink\" title=\"Json字符串转换为Java对象\"></a>Json字符串转换为Java对象</h2>","categories":["协议标准"],"tags":["JSON"]},{"title":"JWT","url":"/2021/06/15/JWT/","content":"<h1 id=\"JWT是什么\"><a href=\"#JWT是什么\" class=\"headerlink\" title=\"JWT是什么\"></a>JWT是什么</h1><p>Json Web Token，JSON Web Tokens are an open, industry standard <a href=\"https://tools.ietf.org/html/rfc7519\">RFC 7519</a> method for representing claims securely between two parties.</p>\n<span id=\"more\"></span>\n\n<h1 id=\"JWT能做什么\"><a href=\"#JWT能做什么\" class=\"headerlink\" title=\"JWT能做什么\"></a>JWT能做什么</h1><h2 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h2><p>一旦用户登陆，之后每个信息都包含JWT，允许该JWT的用户访问其对应的资源。</p>\n<div class=\"note info\">\n            <p>点单登陆是当前JWT最广泛应用的领域。</p>\n          </div>\n\n<h2 id=\"信息交换\"><a href=\"#信息交换\" class=\"headerlink\" title=\"信息交换\"></a>信息交换</h2><p>在各方安全之间安全地传输信息的好方法。使用JWT签名，可以确保发件人信息是否正确，内容是否被篡改（签名使用标头和有效负载）。</p>\n<h1 id=\"为什么要使用JWT\"><a href=\"#为什么要使用JWT\" class=\"headerlink\" title=\"为什么要使用JWT\"></a>为什么要使用JWT</h1><h2 id=\"基于传统Session的认证问题\"><a href=\"#基于传统Session的认证问题\" class=\"headerlink\" title=\"基于传统Session的认证问题\"></a>基于传统Session的认证问题</h2><p>服务器保存用户的seesion，并以cookies返回sessionId保存在用户端。</p>\n<ol>\n<li>随着用户增多，服务器压力增加</li>\n<li>用户认证之后，服务端做记录，session保存在内存里，即下次必须还访问这台机器。在分布式的环境下，相应限制了负载能力。</li>\n<li>还要基于cookies，如果cookies被拦截，容易受伪造跨站攻击。</li>\n<li>前后端分离，增加了部署复杂性，用户一次请求要分发多次，session每次携带sessionId到服务器，还要查询用户信息，服务器压力很大；同时如果后端多节点部署，需要实现session共享机制，不方便集群。（？）</li>\n</ol>\n<h2 id=\"基于JWT\"><a href=\"#基于JWT\" class=\"headerlink\" title=\"基于JWT\"></a>基于JWT</h2><p><img src=\"/2021/06/15/JWT/%E5%9F%BA%E4%BA%8EJWT.png\"></p>\n<h3 id=\"认证流程\"><a href=\"#认证流程\" class=\"headerlink\" title=\"认证流程\"></a>认证流程</h3><ol>\n<li>前端通过Web表单，把用户名和密码发送给后端接口。（建议用SSL加密）</li>\n<li>后端核对用户名和密码，把用户ID和其他信息作为JWT Payload，将其和头部进行Base64编码拼接后签名，形成一个JWT（Token），格式形入xxx.yyy.zzz（header.payload.signature)</li>\n<li>后端把JWT返回给前端浏览器，前端浏览器把JWT保存在localStorage或sessionStorage上，退出登录时，浏览器把JWT删除。</li>\n<li>前端每次请求就把JWT放在Http Header的Authorization中。（可以解决XSS和XSRF问题）</li>\n<li>后端检查JWT是否有效。（签名是否过期，Token是否有效，Token接收方是否是自己）</li>\n<li>后端使用JWT包含的用户信息，进行相应操作，获得信息。</li>\n</ol>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>简洁（compact）：通过url、post或者在Header中，数据量小，传输速度快。<br>字包含（self-contained）：负载中包含了用户所有需要的信息，避免多次查询数据库。<br>跨语言：因为Token是以JSON加密形式保存在客户端，所以原则上任何形式的Web都可以支持。<br>适合分布式微服务：不需要服务器保存会话信息。</p>\n<h1 id=\"JWT结构\"><a href=\"#JWT结构\" class=\"headerlink\" title=\"JWT结构\"></a>JWT结构</h1><p>Header.Payload.Signature</p>\n<h2 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h2><p>头部信息，两部分组成</p>\n<ol>\n<li>令牌类型。默认是JWT</li>\n<li>签名算法。例如HMAC、SHA256或RSA等</li>\n</ol>\n<p>然后再使用BASE64编码组成Header。（Base64是编码格式）</p>\n<h2 id=\"Payload\"><a href=\"#Payload\" class=\"headerlink\" title=\"Payload\"></a>Payload</h2><p>有效负载，包含声明。声明是有关实体和其他数据的声明。<br>也是BASE64的编码<br>iss: jwt签发者<br>sub: jwt所⾯向的⽤户<br>aud: 接收jwt的⼀⽅<br>exp: jwt的过期时间，这个过期时间必须要⼤于签发时间<br>nbf: 定义在什么时间之前，该jwt都是不可⽤的<br>iat: jwt的签发时间<br>jti: jwt的唯⼀身份标识，主要⽤来作为⼀次性token,从⽽回避重放攻击<br>claim：jwt存放信息的地⽅</p>\n<div class=\"note warning\">\n            <p>不要再payload上放用户的敏感信息，因为没有加密，被拦截然后使用BASE64解码就会被泄漏。</p>\n          </div>\n<h2 id=\"Signature\"><a href=\"#Signature\" class=\"headerlink\" title=\"Signature\"></a>Signature</h2><p>Signature需要编码后的header和payload以及提供的密钥，然后使用指定的签名算法（HS256）进行签名，签名的作用是确保JWT没有被篡改过。<br>比如：HMACSHA265（base64urlEncode（header) + “.” + base64urlEncode(payload), key）</p>\n<h3 id=\"验签\"><a href=\"#验签\" class=\"headerlink\" title=\"验签\"></a>验签</h3><p>先用签名3验证1.2。</p>\n<h1 id=\"使用JWT\"><a href=\"#使用JWT\" class=\"headerlink\" title=\"使用JWT\"></a>使用JWT</h1><h2 id=\"导包\"><a href=\"#导包\" class=\"headerlink\" title=\"导包\"></a>导包</h2><h2 id=\"生成JWT\"><a href=\"#生成JWT\" class=\"headerlink\" title=\"生成JWT\"></a>生成JWT</h2><p><img src=\"/2021/06/15/JWT/%E5%88%9B%E5%BB%BAJWT.png\"></p>\n<h2 id=\"验证JWT\"><a href=\"#验证JWT\" class=\"headerlink\" title=\"验证JWT\"></a>验证JWT</h2><p><img src=\"/2021/06/15/JWT/%E9%AA%8C%E8%AF%81JWT.png\"></p>\n<h2 id=\"异常信息\"><a href=\"#异常信息\" class=\"headerlink\" title=\"异常信息\"></a>异常信息</h2><p><img src=\"/2021/06/15/JWT/%E5%BC%82%E5%B8%B8.png\"></p>\n<h1 id=\"JWT封装为工具类\"><a href=\"#JWT封装为工具类\" class=\"headerlink\" title=\"JWT封装为工具类\"></a>JWT封装为工具类</h1><h2 id=\"密钥\"><a href=\"#密钥\" class=\"headerlink\" title=\"密钥\"></a>密钥</h2><h2 id=\"创建JWT\"><a href=\"#创建JWT\" class=\"headerlink\" title=\"创建JWT\"></a>创建JWT</h2><h3 id=\"创建Map\"><a href=\"#创建Map\" class=\"headerlink\" title=\"创建Map\"></a>创建Map</h3><p>Map保存用户的Payload的信息</p>\n<h3 id=\"生成JWT-1\"><a href=\"#生成JWT-1\" class=\"headerlink\" title=\"生成JWT\"></a>生成JWT</h3><p>使用map.foreach把对应信息放到Payload里</p>\n<h2 id=\"验证JWT-1\"><a href=\"#验证JWT-1\" class=\"headerlink\" title=\"验证JWT\"></a>验证JWT</h2><h2 id=\"获取JWT的内部信息\"><a href=\"#获取JWT的内部信息\" class=\"headerlink\" title=\"获取JWT的内部信息\"></a>获取JWT的内部信息</h2><p>返回DecodedJWT</p>\n<h2 id=\"返回JWT\"><a href=\"#返回JWT\" class=\"headerlink\" title=\"返回JWT\"></a>返回JWT</h2><h1 id=\"SpringBoot整合\"><a href=\"#SpringBoot整合\" class=\"headerlink\" title=\"SpringBoot整合\"></a>SpringBoot整合</h1><h2 id=\"导包-1\"><a href=\"#导包-1\" class=\"headerlink\" title=\"导包\"></a>导包</h2><ol>\n<li>java-jwt</li>\n<li>lombok</li>\n<li>druid</li>\n<li>mysql</li>\n</ol>\n<h2 id=\"配置mysql\"><a href=\"#配置mysql\" class=\"headerlink\" title=\"配置mysql\"></a>配置mysql</h2>","categories":["协议标准"],"tags":["安全校验"]},{"title":"JavaScript","url":"/2022/08/30/JavaScript/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><span id=\"more\"></span>\n<h1 id=\"标签位置\"><a href=\"#标签位置\" class=\"headerlink\" title=\"标签位置\"></a>标签位置</h1><h2 id=\"内标签\"><a href=\"#内标签\" class=\"headerlink\" title=\"内标签\"></a>内标签</h2><h2 id=\"外标签\"><a href=\"#外标签\" class=\"headerlink\" title=\"外标签\"></a>外标签</h2><h2 id=\"内联式\"><a href=\"#内联式\" class=\"headerlink\" title=\"内联式\"></a>内联式</h2><h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><p>document.write(‘xxxx’)<br>alter(‘xxx’)<br>console.log(‘xxx’)</p>\n<h2 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h2><p>prompt(‘xxx’)</p>\n<h1 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h1><h2 id=\"数字字面量\"><a href=\"#数字字面量\" class=\"headerlink\" title=\"数字字面量\"></a>数字字面量</h2><p>99999</p>\n<h2 id=\"字符串字面量\"><a href=\"#字符串字面量\" class=\"headerlink\" title=\"字符串字面量\"></a>字符串字面量</h2><p>‘xxx’</p>\n<h2 id=\"数组字面量\"><a href=\"#数组字面量\" class=\"headerlink\" title=\"数组字面量\"></a>数组字面量</h2><p>[]</p>\n<h2 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h2><p>{}</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h2 id=\"声明变量\"><a href=\"#声明变量\" class=\"headerlink\" title=\"声明变量\"></a>声明变量</h2><p>let a </p>\n<p>let 不允许多次声明<br>let 可以同时声明多个变量</p>\n<h2 id=\"变量赋值\"><a href=\"#变量赋值\" class=\"headerlink\" title=\"变量赋值\"></a>变量赋值</h2><h2 id=\"更新变量\"><a href=\"#更新变量\" class=\"headerlink\" title=\"更新变量\"></a>更新变量</h2><h2 id=\"变量命名规范\"><a href=\"#变量命名规范\" class=\"headerlink\" title=\"变量命名规范\"></a>变量命名规范</h2><ol>\n<li>不能命名关键字</li>\n<li>下划线、字母、数字、$ 作为开头，数字不行，不能有其他符号</li>\n<li>严格区分大小写</li>\n<li>小驼峰命名法</li>\n</ol>\n<h2 id=\"let和var的区别\"><a href=\"#let和var的区别\" class=\"headerlink\" title=\"let和var的区别\"></a>let和var的区别</h2><p>建议使用let</p>\n<ol>\n<li>var是先使用再声明</li>\n<li>var可以重复声明</li>\n<li>变量提升，全局变量的问题</li>\n</ol>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><h2 id=\"声明数组\"><a href=\"#声明数组\" class=\"headerlink\" title=\"声明数组\"></a>声明数组</h2><p>let arrayName = [1,2,3,4,….]</p>\n<h2 id=\"下标\"><a href=\"#下标\" class=\"headerlink\" title=\"下标\"></a>下标</h2><p>下标从0开始</p>\n<h2 id=\"长度\"><a href=\"#长度\" class=\"headerlink\" title=\"长度\"></a>长度</h2><p>arrayName.length</p>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p>JS是弱类型数据，变量赋值后才确实数据类型</p>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>（正、负、浮点都属于数字）</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>单引号、双引号、反引号<br>嵌套的话，单内双外，双内单外，或者转意<br>拼接 +</p>\n<h4 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">18</span></span><br><span class=\"line\">$&#123;age&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"未定义\"><a href=\"#未定义\" class=\"headerlink\" title=\"未定义\"></a>未定义</h3><p>let 只声明不赋值，就是undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a</span><br></pre></td></tr></table></figure>\n<p>当我们不知道这个数据是否传过来，可以通过判断这个值是不是undefined</p>\n<h3 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h3><p>null和undefined还是有区别的，null表示赋值了但是为空</p>\n<h2 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h2><h2 id=\"数据类型检测\"><a href=\"#数据类型检测\" class=\"headerlink\" title=\"数据类型检测\"></a>数据类型检测</h2><h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><h3 id=\"显式\"><a href=\"#显式\" class=\"headerlink\" title=\"显式\"></a>显式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(xxx)</span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(xxx)</span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(xxx)：可以过滤单位</span><br><span class=\"line\"><span class=\"built_in\">String</span>(xxx)</span><br><span class=\"line\">xxx.toString()：如果里面数字是<span class=\"number\">2</span>，表示转换为二进制</span><br></pre></td></tr></table></figure>\n<h3 id=\"隐式\"><a href=\"#隐式\" class=\"headerlink\" title=\"隐式\"></a>隐式</h3><p>JS自动帮我们转换</p>\n<ul>\n<li><ul>\n<li>/ 会自动转换为数字</li>\n</ul>\n</li>\n</ul>\n<p>+作为正号，会自动转换为数字。</p>\n","categories":["编程语言"],"tags":["前端"]},{"title":"Java多线程","url":"/2022/07/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>程序多线程是一种高效运行的手段，也是程序员进阶所必须要了解的内容。<br>“众人拾柴火焰高”、“人多力量大”<br>但是并不是人越多越好，也不是大家一起出力。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"工作队列\"><a href=\"#工作队列\" class=\"headerlink\" title=\"工作队列\"></a>工作队列</h1><h2 id=\"直接交换队列\"><a href=\"#直接交换队列\" class=\"headerlink\" title=\"直接交换队列\"></a>直接交换队列</h2><p>SyschronousQueue</p>\n<h2 id=\"无界队列\"><a href=\"#无界队列\" class=\"headerlink\" title=\"无界队列\"></a>无界队列</h2><p>LinkedBlockingQueue</p>\n<h2 id=\"有界队列\"><a href=\"#有界队列\" class=\"headerlink\" title=\"有界队列\"></a>有界队列</h2><p>ArrayBlockingQueue</p>\n<h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><p>线程的创建和销毁是需要耗费大量资源的（切换内核态）。<br>从而引出了线程池，创建线程，使用调度后先不回收，放在池子里，等下一个任务的到来，然后继续使用。（池化）</p>\n<h2 id=\"线程池构造函数\"><a href=\"#线程池构造函数\" class=\"headerlink\" title=\"线程池构造函数\"></a>线程池构造函数</h2><h3 id=\"重要参数\"><a href=\"#重要参数\" class=\"headerlink\" title=\"重要参数\"></a>重要参数</h3><ol>\n<li>corePoolSize<br>核心线程数，如果当前线程池线程数量没有达到该值，即使线程有空闲，也继续新建线程。</li>\n<li>maxPoolSize<br>最大线程数，队列满了的时候会新建线程来处理任务，最终线程个数最大不能超过这个值</li>\n<li>keepAliveTime<br>存活时间：默认对超过core的线程进行过期回收，也可以设置对core进行，但不建议。</li>\n<li>workQueue<br>工作队列</li>\n<li>threadFactory<br>线程工厂：用来创建Thread，默认是Excutors.DefaultThreadFactory，参数设置也是默认。也可以自己指定如何创建线程。</li>\n<li>Handler<br>处理器</li>\n</ol>\n<h2 id=\"线程新增规则\"><a href=\"#线程新增规则\" class=\"headerlink\" title=\"线程新增规则\"></a>线程新增规则</h2><ol>\n<li>if (threadNums &lt; corePoolSize)<br>新创建核心线程 (new coreThread)</li>\n<li>if (threadNums &gt;= corePoolSize &amp;&amp; threadNums &lt; maxPoolSize &amp;&amp; 队列没满)<br>任务进队列</li>\n<li>if (threadNums &gt;= corePoolSize &amp;&amp; threadNums &lt; maxPoolSize &amp;&amp; 队列满了)<br>新创建非核心线程(new Thread)：会被回收</li>\n<li>if (threadNums = maxPoolSize &amp;&amp; 队列满了)<br>拒绝处理任务</li>\n</ol>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><ol>\n<li>固定大小的线程池<br>core = max</li>\n<li>线程池希望保持较少的线程，需要时才扩大</li>\n<li>maxPoolSize设置很高，可以允许任意数量的并发</li>\n<li>队伍设置为无界，那么非核心线程永远不会增加</li>\n</ol>\n<h2 id=\"线程池的创建\"><a href=\"#线程池的创建\" class=\"headerlink\" title=\"线程池的创建\"></a>线程池的创建</h2><p>最好是手动创建，可以根据业务调整。</p>\n<h3 id=\"自动\"><a href=\"#自动\" class=\"headerlink\" title=\"自动\"></a>自动</h3><h3 id=\"手动\"><a href=\"#手动\" class=\"headerlink\" title=\"手动\"></a>手动</h3><ol>\n<li>newFixedThreadPool<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class ThreadPool &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tExecutorService executorService &#x3D; Executors.newFixedThreadPool(4);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfor (int i &#x3D; 0; i &lt; 1000 ; i++) &#123;</span><br><span class=\"line\">\t\t\texecutorService.execute(new Task());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Task implements Runnable &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void run() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(Thread.currentThread().getName() + &quot;: Running~&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\ncore线程数：自定义<br>Max线程数：等于core<br>过期时间：0<br>队列：LinkedBlockingQueue</li>\n</ol>\n<p>优点：线程池开销小，线程数量固定<br>缺点：使用的是无界队列，如果请求过多处理不过来，会占用大量内存，且可能OOM</p>\n<ol start=\"2\">\n<li>newsingleThreadExecutor<br>仅一个核心的线程池<br>core线程数：1<br>Max线程数：1<br>过期时间：0<br>队列：LinkedBlockingQueue</li>\n</ol>\n<p>缺点：请求堆积，占用大量内存<br>应用场景是什么？</p>\n<ol start=\"3\">\n<li>newCacheThreadExecutor<br>使用直接交换队列，有请求就会创建线程，设定时间后会自动回收<br>core线程数：1<br>Max线程数：1<br>过期时间：60s<br>队列：SyschronousQueue</li>\n</ol>\n<p>缺点：默认是0个core，Integer_MAX个最大线程，会创建过多线程。</p>\n<ol start=\"4\">\n<li>newScheduleThreadPool<br>core线程数：自定义<br>Max线程数：Integer_MAX<br>过期时间：0<br>队列：DelayWorkQueue</li>\n</ol>\n<p>定时或者周期的执行线程</p>\n<ol start=\"5\">\n<li>workStealingPool（JDK1.8）<br>线程可以产生子任务<br>可以“窃取”子任务，可以帮其他线程的子任务完成<br>不保证执行顺序</li>\n</ol>\n<h2 id=\"线程个数设定\"><a href=\"#线程个数设定\" class=\"headerlink\" title=\"线程个数设定\"></a>线程个数设定</h2><h3 id=\"CPU计算密集型\"><a href=\"#CPU计算密集型\" class=\"headerlink\" title=\"CPU计算密集型\"></a>CPU计算密集型</h3><p>一般设定为CPU核心数的1-2倍</p>\n<h3 id=\"IO操作密集型\"><a href=\"#IO操作密集型\" class=\"headerlink\" title=\"IO操作密集型\"></a>IO操作密集型</h3><p>因为IO操作速度比CPU直接读取Cache和内存慢的多，会有大量核心空闲，建议把线程设置为多倍。保障效率</p>\n<h3 id=\"经验公式\"><a href=\"#经验公式\" class=\"headerlink\" title=\"经验公式\"></a>经验公式</h3><p>线程数 = CPU核心数 * (1 + 平均等待时间/平均工作时间)</p>\n<h2 id=\"关闭线程池\"><a href=\"#关闭线程池\" class=\"headerlink\" title=\"关闭线程池\"></a>关闭线程池</h2><h3 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h3><p>运行完当下正在运行和队列里的任务。并拒绝新的任务请求</p>\n<h3 id=\"isShutdown\"><a href=\"#isShutdown\" class=\"headerlink\" title=\"isShutdown\"></a>isShutdown</h3><p>是否进入shutdown的模式</p>\n<h3 id=\"isTerminated\"><a href=\"#isTerminated\" class=\"headerlink\" title=\"isTerminated\"></a>isTerminated</h3><p>判断当下和队列任务是否已经清空</p>\n","categories":["编程语言"],"tags":["Java"]},{"title":"Java序列化","url":"/2023/03/10/Java%E5%BA%8F%E5%88%97%E5%8C%96/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>为什么需要序列化：有时候需要将**<em>具体的Java对象**</em>通过网络传递，因此将具体的Java对象按照字节码（或二进制？）转化成一个易于传递的数据。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><h2 id=\"实现接口\"><a href=\"#实现接口\" class=\"headerlink\" title=\"实现接口\"></a>实现接口</h2><ol>\n<li>静态属性/方法，以及transient不参与序列化和反序列化</li>\n<li>序列化的特征可以被继承（父类实现序列化，子类爷实现序列化，二者都会参与序列化）</li>\n</ol>\n<h2 id=\"Java原生\"><a href=\"#Java原生\" class=\"headerlink\" title=\"Java原生\"></a>Java原生</h2><p><code>ObjectOutputSteam.writeObject()</code></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><ol>\n<li>将对象实例相关的类元数据输出。</li>\n<li>递归地输出类的超类描述直到不再有超类。</li>\n<li>类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。</li>\n<li>从上至下递归输出实例的数据</li>\n</ol>\n<h1 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h1><h2 id=\"Java原生-1\"><a href=\"#Java原生-1\" class=\"headerlink\" title=\"Java原生\"></a>Java原生</h2><p><code>ObjectOutputStream.readObject()</code> ：需要自己做强转类型。<br>底层逻辑用到了反射。<br>性能差、且有安全问题</p>\n<h1 id=\"serialVersionID\"><a href=\"#serialVersionID\" class=\"headerlink\" title=\"serialVersionID\"></a>serialVersionID</h1><p>序列和反序列的”相对协议“，即序列化和反序列时候，需要serialVersionID保持一致。</p>\n<p>逻辑：类A 对象A‘ 类B</p>\n<p><strong>类A</strong>的实例化对象是<strong>A’</strong>，经过序列化成为<strong>序列化文件</strong>（包含：类A和内部信息）</p>\n<p><strong>序列化文件</strong>反序列过程中，比较序列化文件中类A内部的 serialVersionID (static)，如果和类B不一样，则拒绝反序列。</p>\n<h1 id=\"序列化框架\"><a href=\"#序列化框架\" class=\"headerlink\" title=\"序列化框架\"></a>序列化框架</h1><ol>\n<li>Kryo：<a href=\"https://github.com/EsotericSoftware/kryo\">https://github.com/EsotericSoftware/kryo</a></li>\n<li>Protobuf：<a href=\"https://github.com/protostuff/protostuff\">https://github.com/protostuff/protostuff</a></li>\n<li>Hessian：</li>\n</ol>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://blog.csdn.net/sanmi8276/article/details/109072574\">https://blog.csdn.net/sanmi8276/article/details/109072574</a></p>\n","categories":["编程语言"],"tags":["Java"]},{"title":"Java核心技术","url":"/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/","content":"<p><img src=\"/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/1.jpg\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Java基本程序设计结构\"><a href=\"#Java基本程序设计结构\" class=\"headerlink\" title=\"Java基本程序设计结构\"></a>Java基本程序设计结构</h1><p><strong><em>基于Java核心技术书籍的重点总结</em></strong></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><hr>\n<h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><ol>\n<li>byte</li>\n<li>short</li>\n<li>int</li>\n<li>long</li>\n</ol>\n<h3 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h3><ol>\n<li>float</li>\n<li>double</li>\n</ol>\n<h3 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h3><p>char</p>\n<h3 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h3><p>boolean</p>\n<h3 id=\"数据类型之间的转换\"><a href=\"#数据类型之间的转换\" class=\"headerlink\" title=\"数据类型之间的转换\"></a>数据类型之间的转换</h3><br>\n\n<h2 id=\"变量和常量\"><a href=\"#变量和常量\" class=\"headerlink\" title=\"变量和常量\"></a>变量和常量</h2><hr>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3><br>\n\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><hr>\n<h3 id=\"基础运算符\"><a href=\"#基础运算符\" class=\"headerlink\" title=\"基础运算符\"></a>基础运算符</h3><h3 id=\"结合赋值运算符\"><a href=\"#结合赋值运算符\" class=\"headerlink\" title=\"结合赋值运算符\"></a>结合赋值运算符</h3><h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><h3 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h3><h3 id=\"运算优先级问题\"><a href=\"#运算优先级问题\" class=\"headerlink\" title=\"运算优先级问题\"></a>运算优先级问题</h3><h3 id=\"数学函数\"><a href=\"#数学函数\" class=\"headerlink\" title=\"数学函数\"></a>数学函数</h3><br>\n\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><hr>\n<h3 id=\"String类\"><a href=\"#String类\" class=\"headerlink\" title=\"String类\"></a>String类</h3><h3 id=\"子串\"><a href=\"#子串\" class=\"headerlink\" title=\"子串\"></a>子串</h3><h3 id=\"拼接\"><a href=\"#拼接\" class=\"headerlink\" title=\"拼接\"></a>拼接</h3><ol>\n<li>+</li>\n<li>Java11新增：repeated方法</li>\n<li>join方法</li>\n</ol>\n<h3 id=\"不可变字符串\"><a href=\"#不可变字符串\" class=\"headerlink\" title=\"不可变字符串\"></a>不可变字符串</h3><p>优点：<br>缺点：</p>\n<h3 id=\"字符串判等\"><a href=\"#字符串判等\" class=\"headerlink\" title=\"字符串判等\"></a>字符串判等</h3><p>s1.equals(s2)</p>\n<div class=\"note info\">\n            <p>字符串不能用 ==，字符串是对象不是值</p>\n          </div>\n\n<h3 id=\"空串和null串\"><a href=\"#空串和null串\" class=\"headerlink\" title=\"空串和null串\"></a>空串和null串</h3><p>空串是一个空的字符串，有地址；null串则是连地址空间都没有的</p>\n<h3 id=\"码点和代码单元\"><a href=\"#码点和代码单元\" class=\"headerlink\" title=\"码点和代码单元\"></a>码点和代码单元</h3><p>码点：一个“字符”所需要的编码二进制<br>码元：一次读取所对应的码位</p>\n<h3 id=\"String的API\"><a href=\"#String的API\" class=\"headerlink\" title=\"String的API\"></a>String的API</h3><h3 id=\"字符串的构造\"><a href=\"#字符串的构造\" class=\"headerlink\" title=\"字符串的构造\"></a>字符串的构造</h3><p>字符串构造器：StringBuffer、StringBuilder<br>StringBuffer是数据安全的，有同步机制，因此性能较差<br>StringBuilder是数据不安全的，可以异步进行，性能较好</p>\n<div class=\"note info\">\n            <p>一般开发使用StringBuilder，基本都是new一个新类，独占一个StringBuilder。所以不存在安全性问题。</p>\n          </div>\n\n<h4 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h4><ol>\n<li>构造方法<br>new StringBuffer()：长度 = 16<br>new StringBuffer(int capacity)：长度 = capacity<br>new StringBuffer(String string)：长度 = string + 16</li>\n<li>操作<br>append(String string)<br>delectCharAt(index)<br>insert()<br>reverse()<br>replace()<br>…</li>\n<li>扩容原理<br>如果新增后的长度超过原来的长度，将（原来长度 * 2 ）+ 2，如果超过最大长度，就返回能支持的最大长度。</li>\n</ol>\n<h4 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h4><h2 id=\"输入-输出\"><a href=\"#输入-输出\" class=\"headerlink\" title=\"输入/输出\"></a>输入/输出</h2><h3 id=\"标准输入-输出\"><a href=\"#标准输入-输出\" class=\"headerlink\" title=\"标准输入/输出\"></a>标准输入/输出</h3><p>读取输入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.util.Scanner</span><br><span class=\"line\">java.lang.System</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Console <span class=\"title\">console</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">java.io.Console\t<span class=\"comment\">//从控制台读取信息或密码</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span>[] <span class=\"title\">readPassword</span><span class=\"params\">(String prompt, Object...args)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">readLine</span><span class=\"params\">(String prompt, Object...args)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>标准输出： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">System.out.print(x) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">System.out.printf(<span class=\"string\">&quot;%xxx&quot;</span>,xxx) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文件输入-输出\"><a href=\"#文件输入-输出\" class=\"headerlink\" title=\"文件输入/输出\"></a>文件输入/输出</h3><p>读取文件:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Scanner in = <span class=\"keyword\">new</span> Scanner(Path.of(<span class=\"string\">&quot;name.txt&quot;</span>), StandardCharsets.UTF_8) </span><br></pre></td></tr></table></figure>\n<p>写入文件:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">PrintWriter out = <span class=\"keyword\">new</span> PrintWriter(<span class=\"string\">&quot;name.txt&quot;</span>, StandardCharsets.UTF_8)</span><br></pre></td></tr></table></figure>\n<p>注意路径的定位，绝对路径和相对路径</p>\n<h2 id=\"控制流程\"><a href=\"#控制流程\" class=\"headerlink\" title=\"控制流程\"></a>控制流程</h2><h3 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h3><p>块是由若干java语句组成的结构，由大括号括起，确定了变量的作用域。</p>\n<h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><p>if else</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>while/do…while</p>\n<h3 id=\"确定循环\"><a href=\"#确定循环\" class=\"headerlink\" title=\"确定循环\"></a>确定循环</h3><p>for/for each</p>\n<h3 id=\"多重循环\"><a href=\"#多重循环\" class=\"headerlink\" title=\"多重循环\"></a>多重循环</h3><p>switch</p>\n<h3 id=\"中断控制\"><a href=\"#中断控制\" class=\"headerlink\" title=\"中断控制\"></a>中断控制</h3><p>break/continue</p>\n<h2 id=\"大数\"><a href=\"#大数\" class=\"headerlink\" title=\"大数\"></a>大数</h2><p><strong>java.math.BigInteger</strong><br>add()、subtract()、multiply()、divide()、sqrt()、mod()、compareTo()、valueOf()<br><strong>java.math.BigDecimal</strong></p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"声明数组\"><a href=\"#声明数组\" class=\"headerlink\" title=\"声明数组\"></a>声明数组</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int a[] &#x3D; new int[num];</span><br><span class=\"line\">int a[] &#x3D; new int[]&#123;num1, num2...&#125;;</span><br><span class=\"line\">new int[] &#123;num1, num2...&#125;;\t\t&#x2F;&#x2F;匿名数组</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h3><p>访问数组需要根据数组下标访问。数组名为一个地址，指向数组的第0个位置的内容。</p>\n<h3 id=\"for-each循环\"><a href=\"#for-each循环\" class=\"headerlink\" title=\"for each循环\"></a>for each循环</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (variable : collection) statement;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>打印数组所有的值：使用Arrays.toString(s)，会把数组元素，用逗号分隔，连同括号一起输出</p>\n          </div>\n\n<h3 id=\"数组拷贝\"><a href=\"#数组拷贝\" class=\"headerlink\" title=\"数组拷贝\"></a>数组拷贝</h3><p>Java中，如果把一个数组变量赋值给另一个数组变量，则他们指向同一个引用。所以，如果需要拷贝数组，则需要使用Arrays类的copyOf方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int[] copy &#x3D; Arrays.copyOf(base, base.length);</span><br><span class=\"line\">&#x2F;&#x2F;第二个参数是新数组的大小，因此也可以用来扩大数组容量</span><br><span class=\"line\">int[] increase &#x3D; Arrays.copyOf(base, base.length &lt; 2);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h3><h3 id=\"数组排序\"><a href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"></a>数组排序</h3><h2 id=\"对象和类\"><a href=\"#对象和类\" class=\"headerlink\" title=\"对象和类\"></a>对象和类</h2><h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><h3 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h3><p>Java需要用到某个类时，如果该类未被加载到内存中，系统会进行加载、连接、初始化，实现对类的加载。</p>\n<ol>\n<li>加载：通过类的全限定名获取类的二进制字节流；之后在内存中生存一个代表该类的Class对象，作为方法区的该类各个数据的访问入口。</li>\n<li>连接：1）验证，确保类加载的正确性。2）准备，为类的静态变量分配内存，并设置默认初始值。3）解析，将类中符号引用替换为直接引用（就是替换成内存地址）。</li>\n<li>初始化：给静态变量赋初值，执行静态代码块内容。</li>\n</ol>\n<div class=\"note info\">\n            <ol><li>验证中，在class文件字节码，前4个字节，是Magic Number，判断是不是class文件。</li><li>初始化语句，在类加载的初始化阶段才会进行。</li></ol>\n          </div>\n\n<h3 id=\"类加载的时机：\"><a href=\"#类加载的时机：\" class=\"headerlink\" title=\"类加载的时机：\"></a>类加载的时机：</h3><ol>\n<li>首次创建类</li>\n<li>首次访问静态变量</li>\n<li>首次调用静态方法</li>\n<li>使用反射强制创造某个类或接口的对应java.lang.class对象</li>\n<li>初始化某个类的子类，会先触发父类的加载</li>\n<li>直接使用java.exe来运行某个main类</li>\n</ol>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><ol>\n<li>Bootstrap ClassLoader 根类加载器：Java核心类的加载，JDK中JRE的lib下的rt.jar</li>\n<li>Extension ClassLoader 拓展类加载器：JRE拓展目录中jar包的加载，JDK中JRE的lib下的ext目录</li>\n<li>System ClassLoader 系统类加载器：复杂加载自定义的类</li>\n</ol>\n<h3 id=\"获取Class对象\"><a href=\"#获取Class对象\" class=\"headerlink\" title=\"获取Class对象\"></a>获取Class对象</h3><ol>\n<li>通过对象获取<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Object中</span><br><span class=\"line\">Class getClass()</span><br></pre></td></tr></table></figure></li>\n<li>通过字面值常量（但是不是完整的类加载，没有初始化过程，且必须是全类名）</li>\n<li>通过Class类的静态方法：Class.forName(String className) （常用）</li>\n</ol>\n<div class=\"note info\">\n            <p>一般开发都是用config文件</p>\n          </div>\n\n<h3 id=\"利用Properties对象读取配置\"><a href=\"#利用Properties对象读取配置\" class=\"headerlink\" title=\"利用Properties对象读取配置\"></a>利用Properties对象读取配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">FileInputStream fis &#x3D; new FileInputStream(&quot;config.properties&quot;);</span><br><span class=\"line\">Properties prop &#x3D; new Properties();</span><br><span class=\"line\">prop.load(fis);</span><br><span class=\"line\">String className &#x3D; properties.getProperty(&quot;className&quot;);</span><br><span class=\"line\">return className;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取类中定义的构造方法\"><a href=\"#获取类中定义的构造方法\" class=\"headerlink\" title=\"获取类中定义的构造方法\"></a>获取类中定义的构造方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Constructor[] getConstructors()\t\t&#x2F;&#x2F;获取所有public方法</span><br><span class=\"line\">Constructor[] getDeclaredConstructors()\t\t&#x2F;&#x2F;获取所有方法</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor getConstructor(Class... parameterTypes)\t\t&#x2F;&#x2F;获取指定public方法</span><br><span class=\"line\">Constructor getDeclaredConstructor(Class... parameterTypes)\t\t&#x2F;&#x2F;获取指定的任意方法</span><br><span class=\"line\">&#x2F;&#x2F;参数类型是其对应的Class对象</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>可变参数只能有一个，且必须在参数的末尾：public void show(int a, double… b)</p>\n          </div>\n\n<p>可以使用获取的构造方法来创建对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Constructor.newInstance(Object... initArgs);</span><br><span class=\"line\"></span><br><span class=\"line\">constructor.setAccessible(true);\t&#x2F;&#x2F;针对private的权限，告诉JVM绕过权限检查</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取类中成员变量的方法\"><a href=\"#获取类中成员变量的方法\" class=\"headerlink\" title=\"获取类中成员变量的方法\"></a>获取类中成员变量的方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Field[] getFields()\t\t&#x2F;&#x2F;获得子类和父类的public成员变量</span><br><span class=\"line\">Fieled[] getDeclaredFields()\t\t&#x2F;&#x2F;获得自己的所有成员变量</span><br><span class=\"line\"></span><br><span class=\"line\">Field getField(String name)\t\t&#x2F;&#x2F;获取指定的public成员变量，先子类再父类查找</span><br><span class=\"line\">Field getDeclaredField(String name)\t\t&#x2F;&#x2F;获取自己任意的成员变量</span><br></pre></td></tr></table></figure>\n<p>获取成员变量的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">field.get(Object obj);</span><br><span class=\"line\">void set(Object obj, Object value);</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>为什么不用obj.fieldName来获取成员变量值？ 因为该方式涉及一个权限问题，使用反射可以越过权限访问(通过setAceessible)</p>\n          </div>\n\n<div class=\"note info\">\n            <p>关于静态成员变量：</p><ol><li>静态变量的对象获取与普通是相同的。</li><li>但是因为静态成员不依赖于对象，所以获取值的时候，传递的要是一个null。</li></ol>\n          </div>\n\n\n<h3 id=\"获得类中成员方法的方法\"><a href=\"#获得类中成员方法的方法\" class=\"headerlink\" title=\"获得类中成员方法的方法\"></a>获得类中成员方法的方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Method[] getMethods();\t\t&#x2F;&#x2F;自己及父类的public方法</span><br><span class=\"line\">Method[] getDeclaredMethods();\t\t&#x2F;&#x2F;自己的所有方法</span><br><span class=\"line\"></span><br><span class=\"line\">Method getMethod(String name, Class&lt;?&gt;... parameterTypes);\t\t&#x2F;&#x2F;获取自己及父类指定public成员方法</span><br><span class=\"line\">Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);\t\t&#x2F;&#x2F;获取自己的所有指定方法</span><br><span class=\"line\"></span><br><span class=\"line\">Object invoke(Object obj, Object... args);</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>关于静态方法：</p><ol><li>静态方法对象获取与普通是相同的。</li><li>静态方法不依赖于对象，调用传的值也要传递一个null。</li></ol>\n          </div>\n\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>为我们在代码中添加信息，提供了一种形式化的方法，使我们可以在稍后的某个时刻非常方便的使用这些信息(通过代码来获取，并使用这些定义的额外信息)。并且在JVM进行编译的时候，对其视而不见。只有固定语法，没有标准形式？</p>\n<h3 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h3><p>注解的定义，和类、接口的定义十分类似。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@interface MyInterface&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;第一条信息</span><br><span class=\"line\">\t&#x2F;&#x2F;第二条信息</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <ol><li>注解内信息直接是有标准的。</li><li>每一个信息，都有自己的名字（方法名），都有自己的数据类型（方法返回值）。</li><li>@ 一定不能丢。</li><li>注解不能继承。</li><li>数据类型不能是自定义类</li></ol>\n          </div>\n\n<h3 id=\"使用注解\"><a href=\"#使用注解\" class=\"headerlink\" title=\"使用注解\"></a>使用注解</h3><p>注解类型（类）和注解实例（对象）。注解的实质，是创建一个注解实例，并且给该实例的各个成员变量赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@MyInterface(maxAge &#x3D; 25, minAge &#x3D; 18)</span><br></pre></td></tr></table></figure>\n<p>注解可以在定义时，设置默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@MyInterface&#123;</span><br><span class=\"line\">\tint length() default 5;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <ol><li>注解对象必须有值</li><li>引用类型不允许默认声明为null（比如String）</li><li>简化版注解：仅有一个变量名，且为value，注解实例可以直接写数值。 @MyInterface(100)</li></ol>\n          </div>\n\n<h3 id=\"注解处理器\"><a href=\"#注解处理器\" class=\"headerlink\" title=\"注解处理器\"></a>注解处理器</h3><p>使用工厂类</p>\n<div class=\"note info\">\n            <p>isAnnotationPresent(Class targetAnnotation) 判断该成员变量是否有注解<br>getAnnotation(Class targetAnnotation) 获取该变量的注解对象</p>\n          </div>\n\n<h3 id=\"注解的保留级别\"><a href=\"#注解的保留级别\" class=\"headerlink\" title=\"注解的保留级别\"></a>注解的保留级别</h3><ol>\n<li>SOURCE：注解将被编译器丢弃（class文件中没有）</li>\n<li>CLASS：注解可以在Class文件，但是会被JVM丢弃（不会在内存中）</li>\n<li>RUNTIME：在内存中一样保存。</li>\n</ol>\n<div class=\"note info\">\n            <p>默认保留级别是CLASS</p>\n          </div>\n\n<h3 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h3><p>元注解：注解的注解。</p>\n<ol>\n<li>@Target        作用范围，多个对象用大括号包起来。</li>\n<li>@Retention        保留级别<br>修改注解的保留级别：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@MyInterface(....)</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>isAnnotation(Class type)<br>getAnnotation(Class type)</p>\n          </div>\n\n</li>\n</ol>\n<h3 id=\"注解的使用场景\"><a href=\"#注解的使用场景\" class=\"headerlink\" title=\"注解的使用场景\"></a>注解的使用场景</h3><p>配置文件和注解的区别。<br>如果配置和代码直接相关，使用注解。比如相关开源组件：Junit、Servlet、Spring。<br>如何配置和代码运行环境有关，使用配置文件。</p>\n<div class=\"note info\">\n            <p>硬编码：把变量值，直接写在代码里。</p>\n          </div>\n\n\n\n\n<h2 id=\"lambda函数\"><a href=\"#lambda函数\" class=\"headerlink\" title=\"lambda函数\"></a>lambda函数</h2><p>lambda函数是个匿名函数，可以理解为一段可以传递的代码。</p>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><h2 id=\"处理错误\"><a href=\"#处理错误\" class=\"headerlink\" title=\"处理错误\"></a>处理错误</h2><hr>\n<h3 id=\"异常的分类\"><a href=\"#异常的分类\" class=\"headerlink\" title=\"异常的分类\"></a>异常的分类</h3><p><img src=\"/2021/03/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/exception-architechture-java.png\" alt=\"xxx\"><br>Exception还分为：编译时异常(Checkable Exception)、运行时异常(Runtime Exception)</p>\n<h3 id=\"异常的实质\"><a href=\"#异常的实质\" class=\"headerlink\" title=\"异常的实质\"></a>异常的实质</h3><p>提供了一致性的错误报告模型，使得类的构建者和使用者之间可以进行可靠的沟通</p>\n<h3 id=\"常见异常\"><a href=\"#常见异常\" class=\"headerlink\" title=\"常见异常\"></a>常见异常</h3><p>数组越界<br>空指针</p>\n<h3 id=\"声明检查异常\"><a href=\"#声明检查异常\" class=\"headerlink\" title=\"声明检查异常\"></a>声明检查异常</h3><p>告诉编译器可能发生什么错误<br>4种抛出异常的情况：</p>\n<ol>\n<li>调用抛出检查型异常的方法</li>\n<li>检测到一个错误</li>\n<li>程序出现错误</li>\n<li>java虚拟机或者运行时库出现内部错误</li>\n</ol>\n<div class=\"note info\">\n            <p>子类覆盖超类的方法时，可以抛出更特定的异常，或者根本不抛出异常。另外，超类不抛出异常，子类更不能抛出异常</p>\n          </div>\n\n<h3 id=\"如何抛出异常\"><a href=\"#如何抛出异常\" class=\"headerlink\" title=\"如何抛出异常\"></a>如何抛出异常</h3><ol>\n<li>throws<br>在方法定义时，多个异常用逗号( , )分隔<br>throws表示抛出一种可能性，并不一定发生，且由调用者来处理异常</li>\n<li>throw<br>在方法内抛出异常类，可以由方法体内来处理<br>throw则是必定抛出一个异常<br>tip：抛出编译时异常，必须使用throws</li>\n</ol>\n<h3 id=\"创建异常类\"><a href=\"#创建异常类\" class=\"headerlink\" title=\"创建异常类\"></a>创建异常类</h3><p>定义一个派生于Exception的类（Throwable是所有异常的基类（父类）） </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.Throwable:</span><br><span class=\"line\">Throwable() </span><br><span class=\"line\">Throwable(String message)</span><br><span class=\"line\"><span class=\"function\">String <span class=\"title\">getMessage</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h2><hr>\n<h3 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try/catch\"></a>try/catch</h3><ul>\n<li>捕获单个异常</li>\n<li>捕获多个异常; 并列处理,同一处理方式可以合并</li>\n</ul>\n<h3 id=\"再次抛出异常和异常链\"><a href=\"#再次抛出异常和异常链\" class=\"headerlink\" title=\"再次抛出异常和异常链\"></a>再次抛出异常和异常链</h3><p>可以在catch中再次抛出一个异常（就是希望改变异常类型）</p>\n<ol>\n<li>使用这样的包装细节，可以在子系统抛出高层异常时，不丢失原始异常的细节。</li>\n<li>想记录一个异常，可以将他重新抛出。</li>\n</ol>\n<div class=\"note info\">\n            <p>如果一个方法发生检查型异常，但是该方法不允许抛出检查型异常，可以包装成运行时异常。 </p>\n          </div>\n\n<div class=\"note warning\">\n            <p>如果异常被捕获，而没有被处理或抛出，则异常会被忽略</p>\n          </div>\n\n<h3 id=\"finally子句\"><a href=\"#finally子句\" class=\"headerlink\" title=\"finally子句\"></a>finally子句</h3><p>代码抛出异常后，就会停止处理这个方法中剩余的代码，并退出。</p>\n<ol>\n<li>有时代码要求必须执行的内容（比如关闭流等），可以用finally子句（finally子句必定被执行）</li>\n<li>try语句可以没有catch，只搭配finally。</li>\n<li>嵌套try，内层try可以执行finally，确保一些工作，外层负责报告错误。</li>\n<li>java7之后的可替代方案：try-with-resources</li>\n</ol>\n<div class=\"note warning\">\n            <p>finally里如果使用return，这个返回值会遮蔽原来的返回值</p>\n          </div> \n\n<h3 id=\"try-with-resources\"><a href=\"#try-with-resources\" class=\"headerlink\" title=\"try-with-resources\"></a>try-with-resources</h3><p>要求资源属于AutoCloseable接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Resource res = ...) &#123;</span><br><span class=\"line\">    work with res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//try块结束的时候，res会自动释放</span></span><br></pre></td></tr></table></figure>\n\n<p>Java9中,可以在try首部中提供之前声明的事实最终变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printAll</span><span class=\"params\">(String[] lines, PrintWriter out)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (out) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String line : lines) &#123;</span><br><span class=\"line\">            out.println(line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;\t<span class=\"comment\">//结束后自动out.close()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div class=\"note info\">\n            <p>try-with-resources也可以有自己的catch子句或者finally子句，关闭资源后会执行子句。</p>\n          </div>\n\n\n<h3 id=\"分析堆栈轨迹元素\"><a href=\"#分析堆栈轨迹元素\" class=\"headerlink\" title=\"分析堆栈轨迹元素\"></a>分析堆栈轨迹元素</h3><p><strong>堆栈轨迹(stack trace)</strong> 是程序执行过程中某个特定点上挂起的方法调用的一个列表。当java程序因为一个未捕获的异常而终止时，就会显示堆栈轨迹。<br>主要是调用Throwable类的printStackTrace方法<br>更为灵活的是使用StackWalker类，每一个实例描述一个栈帧。利用StackWalker.StackFrame类的一些方法可以得到所执行代码的文件名和行号，以及类对象和方法名。<br>相关类：StackWalker、StackFrame、StackTraceElement</p>\n<h3 id=\"使用异常的技巧\"><a href=\"#使用异常的技巧\" class=\"headerlink\" title=\"使用异常的技巧\"></a>使用异常的技巧</h3><ol>\n<li>异常处理不能代替简单的测试: 因为异常捕获非常消耗性能</li>\n<li>不要过分细化异常</li>\n<li>充分利用异常的层级结构</li>\n<li>不要压制异常</li>\n<li>检测错误时，苛刻比放任更好</li>\n<li>不要羞于传递异常</li>\n</ol>\n<div class=\"note info\">\n            <p>早抛出，晚捕获</p>\n          </div>\n\n\n<h2 id=\"使用断言\"><a href=\"#使用断言\" class=\"headerlink\" title=\"使用断言\"></a>使用断言</h2><h3 id=\"断言的概念\"><a href=\"#断言的概念\" class=\"headerlink\" title=\"断言的概念\"></a>断言的概念</h3><p>假如确信某个属性符合要求，并且代码的执行依赖这个属性，且不想要大量检测的代码保留在程序中，可以使用断言。断言机制允许在测试期间向代码插入一些检查，而在生产代码的时候会自动删除这些检查。</p>\n<div class=\"note info\">\n            <p>即assert是负责检查绝对不可以出现的情况</p>\n          </div>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">assert condition;</span><br><span class=\"line\">assert condition : expression;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启用和禁用断言\"><a href=\"#启用和禁用断言\" class=\"headerlink\" title=\"启用和禁用断言\"></a>启用和禁用断言</h3><p>断言默认是禁用。</p>\n<ol>\n<li>启用：运行时使用 -enableassertions 或 -ea 开启。</li>\n<li>禁用：运行时使用 -disableassertions 或 -da 开启。</li>\n</ol>\n<div class=\"note info\">\n            <p>不必重新编译程序来启用或禁用，因为这是类加载器的功能。禁用断言时，类加载器会去除断言代码</p>\n          </div>\n<p>断言也可以某个类或这个包中启用。</p>\n<div class=\"note info\">\n            <p>-ea和-da对那些没有类加载类的“系统类”无效，需要用-enablesystemassertions/-esa 开关断言</p>\n          </div>\n\n<h3 id=\"使用断言完成参数检查\"><a href=\"#使用断言完成参数检查\" class=\"headerlink\" title=\"使用断言完成参数检查\"></a>使用断言完成参数检查</h3><p>Java中提供了三种处理系统错误的机制：</p>\n<ol>\n<li>抛出一个异常</li>\n<li>日志</li>\n<li>使用断言</li>\n</ol>\n<p>以下情况要使用断言：</p>\n<ol>\n<li>断言失败是致命的、不可恢复的错误</li>\n<li>断言检查只是在开发和测试阶段打开</li>\n</ol>\n<p>因此不应该使用断言向程序的其他部分通知发生了可通知性错误，或者，不应用利用断言与程序用户沟通问题。断言只应该用于测试阶段确定程序内部错误的位置。</p>\n<p><em>前置条件</em>：程序所必须具有的约定。比如约定一个参数a不能为null</p>\n<h3 id=\"使用断言提供假设文档\"><a href=\"#使用断言提供假设文档\" class=\"headerlink\" title=\"使用断言提供假设文档\"></a>使用断言提供假设文档</h3><p>……</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.ClassLoader</span><br><span class=\"line\">\tvoid setDefaultAssertionStatus(boolean b)</span><br><span class=\"line\">\t&#x2F;&#x2F;为通过类加载器的类启动或禁用类</span><br><span class=\"line\">\tvoid setClassAssertionStatus(String className, boolean b)</span><br><span class=\"line\">\t&#x2F;&#x2F;为给定的类和它的内部类启用或禁用断言</span><br><span class=\"line\">\tvoid setPackageAssertionStatus(String packageName, boolean b)</span><br><span class=\"line\">\t&#x2F;&#x2F;为给定包及其子包的所有类启用或禁用断言</span><br><span class=\"line\">\tvoid clearAssertionStatus()</span><br><span class=\"line\">\t&#x2F;&#x2F;删除所有显式的类和包断言状态设置，并禁用通过这个类加载器加载所有类的断言</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>日志API的主要优点:</p>\n<ol>\n<li>可以很容易地取消全部日志记录，或者仅仅取消某个级别以下的日志，而且很容易地再次打开开关。</li>\n<li>可以很简单的禁止日志记录，因此，将这些日志代码留在程序中的开销很小。</li>\n<li>日志记录可以被定向到不同的处理器，如在控制台显示、写至文件，等等。</li>\n<li>日志记录器和处理器都可以对记录进行过滤。过滤器可以根据过滤器实现器指定的标准丢弃那些无用的记录项。</li>\n<li>日志记录可以采用不同的方式格式化，例如，纯文本或者XML</li>\n<li>应用程序可以使用多个日志记录器，他们使用与包名类似的有层次的结构名字</li>\n<li>日志系统的配置由配置文件控制</li>\n</ol>\n<div class=\"note info\">\n            <p>但是现在工程化管理，多数使用Log4J2等一些日志框架</p>\n          </div>\n\n<h3 id=\"基本日志\"><a href=\"#基本日志\" class=\"headerlink\" title=\"基本日志\"></a>基本日志</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Logger.getGlobal().info(&quot;xxx&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;&#x2F;生成简单的日志记录</span><br><span class=\"line\">Logger.getGlobal().setLevel(Level.OFF);</span><br><span class=\"line\">&#x2F;&#x2F;取消所有日志</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高级日志\"><a href=\"#高级日志\" class=\"headerlink\" title=\"高级日志\"></a>高级日志</h3><p>在很多程序中，我们并不希望所有日志都记录在一个全局日志中。因此可以定义自己的日志记录器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;调用getLogger方法创建或获取日志记录器：</span><br><span class=\"line\">private static final Logger myLogger &#x3D; Logger.getLogger(&quot;com.myCompany.myApp&quot;)</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>为什么定义为final？是因为未被任何变量引用的日志记录器可能会被垃圾回收，因此需要定义为final</p>\n          </div>\n\n<p>日志记录器的层次性更强，父与子之间会共享某些属性，比如日志级别。<br>日志分为7个级别：</p>\n<ol>\n<li>SEVERE</li>\n<li>WARNING</li>\n<li>INFO</li>\n<li>CONFIG</li>\n<li>FINE</li>\n<li>FINER</li>\n<li>FINEST</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">logger.setLevel(Level.FINE)</span><br><span class=\"line\">&#x2F;&#x2F;默认只记录前三个级别，也可以自行设置，这样，FINE及以上的日志都会记录</span><br><span class=\"line\">&#x2F;&#x2F;Level.ALL全部开启，Level.OFF全部关闭</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>INFO及更高级别的日志会被默认记录，因此，应该使用CONFIG、FINE、FINER、FINEST来记录有助于诊断，但意义不大的调试信息</p>\n          </div>\n\n<div class=\"note warning\">\n            <p>如果修改日志记录级别比INFO低，还需要修改日志处理器的配置。因为日志处理器会抑制低于INFO的消息。</p>\n          </div>\n\n<p>默认的日志记录将显示调用堆栈得出的包含日志调用的类名和方法名。如果虚拟机对执行过程进行了优化，就会得不到准确的调用信息。因此需要使用**<em>logp**</em>方法获得调用类和方法确切的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void logp(Level l, String className, String methodName, String message)</span><br></pre></td></tr></table></figure>\n<p>还有一些跟踪执行流的便利方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void entering(String className, String methodName)</span><br><span class=\"line\">void entering(String className, STring methodName, Object param)</span><br><span class=\"line\">void entering(String className, String methodName, Object[] params)</span><br><span class=\"line\">void exiting(String className, String methodName)</span><br><span class=\"line\">void exiting(String className, String methodName, Object result)</span><br></pre></td></tr></table></figure>\n\n<p>在记录中包含异常的描述</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void throwing(String className, String methodName, Throwable t)</span><br><span class=\"line\">void log(Level l, String message, Throwable t)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改日志管理器配置\"><a href=\"#修改日志管理器配置\" class=\"headerlink\" title=\"修改日志管理器配置\"></a>修改日志管理器配置</h3><p>默认情况下，配置文件位于: conf/logging.properties（Java9之前，位于jre/lib/logging.properties）<br>编辑配置文件，修改.level=级别。<br>如果要自定义日志记录器级别，在日志记录器后面加.level=级别，比如 com.myCompany.myApp.level=FINE</p>\n<h3 id=\"本地化\"><a href=\"#本地化\" class=\"headerlink\" title=\"本地化\"></a>本地化</h3><p>…..</p>\n<h3 id=\"处理器\"><a href=\"#处理器\" class=\"headerlink\" title=\"处理器\"></a>处理器</h3><p>…..</p>\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>…..</p>\n<h3 id=\"格式化器\"><a href=\"#格式化器\" class=\"headerlink\" title=\"格式化器\"></a>格式化器</h3><p>….</p>\n<h3 id=\"日志技巧\"><a href=\"#日志技巧\" class=\"headerlink\" title=\"日志技巧\"></a>日志技巧</h3><p>….</p>\n<h2 id=\"调试技巧\"><a href=\"#调试技巧\" class=\"headerlink\" title=\"调试技巧\"></a>调试技巧</h2><h1 id=\"重要的类\"><a href=\"#重要的类\" class=\"headerlink\" title=\"重要的类\"></a>重要的类</h1><h2 id=\"File类\"><a href=\"#File类\" class=\"headerlink\" title=\"File类\"></a>File类</h2><h3 id=\"基本概述\"><a href=\"#基本概述\" class=\"headerlink\" title=\"基本概述\"></a>基本概述</h3><p>File类是文件和目录路径名的抽象表达形式<br>File的构造方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">File(String pathname)</span><br><span class=\"line\">File(String parent, String child)</span><br><span class=\"line\">File(File parent, String child)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"成员方法\"><a href=\"#成员方法\" class=\"headerlink\" title=\"成员方法\"></a>成员方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;创建：</span><br><span class=\"line\">public boolean createNewFile()</span><br><span class=\"line\">public boolean mkdir()</span><br><span class=\"line\">public boolean mkdirs()</span><br><span class=\"line\">&#x2F;&#x2F;删除</span><br><span class=\"line\">public boolean delete()</span><br><span class=\"line\">&#x2F;&#x2F;重命名</span><br><span class=\"line\">public boolean renameTo(File dest)</span><br><span class=\"line\">&#x2F;&#x2F;判断</span><br><span class=\"line\">public boolean isFile()</span><br><span class=\"line\">public boolean isDirectory()</span><br><span class=\"line\">public boolean exists()</span><br><span class=\"line\">public boolean canRead()</span><br><span class=\"line\">public boolean canWrite()</span><br><span class=\"line\">public boolean isHidden()</span><br><span class=\"line\">&#x2F;&#x2F;基础属性获取</span><br><span class=\"line\">public File getAbsolutePath()</span><br><span class=\"line\">public String getPath()</span><br><span class=\"line\">public String getName()</span><br><span class=\"line\">public long length()</span><br><span class=\"line\">public long lastModified()</span><br><span class=\"line\">&#x2F;&#x2F;高级属性获取</span><br><span class=\"line\">public String[] list()  &#x2F;&#x2F;返回一个字符串数组，这些字符串指定此抽象路径名表示的目录</span><br><span class=\"line\">中的文件和目录。</span><br><span class=\"line\">public File[] listFiles() &#x2F;&#x2F;返回一个File数组，这些路径名表示此抽象路径名表示的目录中的文件或者目录</span><br><span class=\"line\">&#x2F;&#x2F;如果返回的是一个null，表示该路径名下是一个文件</span><br><span class=\"line\">&#x2F;&#x2F;自定义获取</span><br><span class=\"line\">File[] listFiles(FileFilter filter)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过滤器接口\"><a href=\"#过滤器接口\" class=\"headerlink\" title=\"过滤器接口\"></a>过滤器接口</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public interface FileFilter &#123;</span><br><span class=\"line\">  boolean accept(File pathname);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;例如写一个只接收txt文件后缀的文件过滤器</span><br><span class=\"line\">FileFilter filter &#x3D; new FileFilter() &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 过滤条件就是在这里实现的</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public boolean accept(File targetFile) &#123;</span><br><span class=\"line\">    if (targetFile.isDirectory()) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 如果是目录，不满足条件</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  String name &#x3D; targetFile.getName();</span><br><span class=\"line\">  &#x2F;&#x2F; 判断如果是txt文件返回true，否则返回false</span><br><span class=\"line\">    return name.endsWith(&quot;txt&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"泛型程序设计\"><a href=\"#泛型程序设计\" class=\"headerlink\" title=\"泛型程序设计\"></a>泛型程序设计</h1><h2 id=\"为什么要定义泛型\"><a href=\"#为什么要定义泛型\" class=\"headerlink\" title=\"为什么要定义泛型\"></a>为什么要定义泛型</h2><p>泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。</p>\n<h3 id=\"类型参数的好处\"><a href=\"#类型参数的好处\" class=\"headerlink\" title=\"类型参数的好处\"></a>类型参数的好处</h3><p>使用类型参数可以用来指定元素的类型：</p>\n<ol>\n<li>使代码具有更好的可读性</li>\n<li>编译器可以充分利用这个类型信息，获取值时不用强制类型转换</li>\n<li>更加安全，防止插入错误类型的对象</li>\n</ol>\n<h3 id=\"谁想成为泛型程序员\"><a href=\"#谁想成为泛型程序员\" class=\"headerlink\" title=\"谁想成为泛型程序员\"></a>谁想成为泛型程序员</h3><p>要预计泛型类所有的可能用法，是很困难的。<br>Java语言设计者发明了一个具有独创性的新概念，**<em>标识通配符类型**</em><br>泛型程序设计分为三个类型：</p>\n<ol>\n<li>仅仅使用泛型类</li>\n<li>混合使用不同的泛型类，需要对Java泛型有足够的了解</li>\n<li>实现自己的泛型类和泛型方法</li>\n</ol>\n<h2 id=\"定义简单的泛型类\"><a href=\"#定义简单的泛型类\" class=\"headerlink\" title=\"定义简单的泛型类\"></a>定义简单的泛型类</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Pair&lt;T&gt; &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>一般E表示集合元素类型，K和V分别表示键和值的类型，T（U、S）表示任意类型</p>\n          </div>\n<p>可以用具体的类型替换变量来实例化泛型类型</p>\n<h2 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h2><p>定义一个带有类型参数的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class ArrayAlg &#123;</span><br><span class=\"line\">  public static &lt;T&gt; T getMiddle(T ... a) &#123;</span><br><span class=\"line\">    return a[a.length &#x2F; 2];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>泛型类型放在返回类型的前面</p>\n          </div>\n<div class=\"note success\">\n            <p>如果想知道编译器对一个范型方法的调用最终判断出哪种类型，可以故意引入一个错误，然后分析错误信息。</p>\n          </div>\n\n<h2 id=\"类型变量的限定\"><a href=\"#类型变量的限定\" class=\"headerlink\" title=\"类型变量的限定\"></a>类型变量的限定</h2><p>有时候类或方法需要类型变量加以约束，可以对类型变量T设置一个限定来实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;T extends Comparable&gt; T min(T[] a) ...</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>为什么用extends？是因为T应该是限定类型的子类型。T和限定类型可以是类，也可以是接口。</p>\n          </div>\n<p>一个类型变量或通配符可以有多个限定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">T extends Comparable &amp; Serializable</span><br></pre></td></tr></table></figure>\n<p>限定类型用”&amp;”分隔，类型变量用”,”分隔</p>\n<h2 id=\"泛型代码和虚拟机\"><a href=\"#泛型代码和虚拟机\" class=\"headerlink\" title=\"泛型代码和虚拟机\"></a>泛型代码和虚拟机</h2><h3 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h3><p>原始类型：无论何时定义一个泛型类型，都会自动提供一个相应的原始类型（即去掉类型参数后的泛型类型名）<br>类型擦除：泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换成它们非泛型上界。</p>\n<h3 id=\"转换泛型表达式\"><a href=\"#转换泛型表达式\" class=\"headerlink\" title=\"转换泛型表达式\"></a>转换泛型表达式</h3><p>编写泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。<br>当访问一个泛型字段时也要插入强制类型转换。</p>\n<h3 id=\"转换泛型方法\"><a href=\"#转换泛型方法\" class=\"headerlink\" title=\"转换泛型方法\"></a>转换泛型方法</h3><p>类型擦除也会出现在泛型方法中。类型擦除后，会与多态发生冲突。继而引出桥方法（bridge method），来解决这个问题: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void setSecond(Object second) &#123;</span><br><span class=\"line\">  setSecond((LocalDate) second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总之Java泛型的转换，需要记住以下几个事实：</p>\n<ol>\n<li>虚拟机中没有泛型，只有普通类和方法</li>\n<li>所有的类型参数都会替换为它们的限定类型</li>\n<li>会合成桥方法来保持多态</li>\n<li>为保持类型安全性，必要时会插入强制类型转换</li>\n</ol>\n<h3 id=\"调用遗留代码\"><a href=\"#调用遗留代码\" class=\"headerlink\" title=\"调用遗留代码\"></a>调用遗留代码</h3><h2 id=\"限制和局限性\"><a href=\"#限制和局限性\" class=\"headerlink\" title=\"限制和局限性\"></a>限制和局限性</h2><h3 id=\"不能用基本类型实例化类型参数\"><a href=\"#不能用基本类型实例化类型参数\" class=\"headerlink\" title=\"不能用基本类型实例化类型参数\"></a>不能用基本类型实例化类型参数</h3><h3 id=\"运行时类型查询只适用于原始类型\"><a href=\"#运行时类型查询只适用于原始类型\" class=\"headerlink\" title=\"运行时类型查询只适用于原始类型\"></a>运行时类型查询只适用于原始类型</h3><h3 id=\"不能创建参数化类型的数组\"><a href=\"#不能创建参数化类型的数组\" class=\"headerlink\" title=\"不能创建参数化类型的数组\"></a>不能创建参数化类型的数组</h3><h3 id=\"Varargs-警告\"><a href=\"#Varargs-警告\" class=\"headerlink\" title=\"Varargs 警告\"></a>Varargs 警告</h3><h1 id=\"Java-I-O流\"><a href=\"#Java-I-O流\" class=\"headerlink\" title=\"Java I/O流\"></a>Java I/O流</h1><h2 id=\"I-O流概念\"><a href=\"#I-O流概念\" class=\"headerlink\" title=\"I/O流概念\"></a>I/O流概念</h2><p>I/O流：I/O流用来处理JVM和外部设备之间的数据传输，Java通过流(Stream)的方式，完成数据的传输过程。</p>\n<h2 id=\"I-O的分类\"><a href=\"#I-O的分类\" class=\"headerlink\" title=\"I/O的分类\"></a>I/O的分类</h2><h3 id=\"按照数据流向\"><a href=\"#按照数据流向\" class=\"headerlink\" title=\"按照数据流向\"></a>按照数据流向</h3><p>输入流：读入数据<br>输出流：写出数据</p>\n<h3 id=\"按照数据类型\"><a href=\"#按照数据类型\" class=\"headerlink\" title=\"按照数据类型\"></a>按照数据类型</h3><p>字节流：数据是一连串二进制<br>字符流：数据是字符序列</p>\n<div class=\"note info\">\n            <p>文本数据用字符流，如果不确定数据类型，一律用字节流</p>\n          </div>\n\n<h2 id=\"I-O流常用基类\"><a href=\"#I-O流常用基类\" class=\"headerlink\" title=\"I/O流常用基类\"></a>I/O流常用基类</h2><p>字节流抽象基类：</p>\n<ol>\n<li>InputStream</li>\n<li>OutputStream</li>\n</ol>\n<p>字符流抽象基类：</p>\n<ol>\n<li>Reader</li>\n<li>Writer</li>\n</ol>\n<h2 id=\"字节流\"><a href=\"#字节流\" class=\"headerlink\" title=\"字节流\"></a>字节流</h2><h3 id=\"字节流写数据\"><a href=\"#字节流写数据\" class=\"headerlink\" title=\"字节流写数据\"></a>字节流写数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;构造方法</span><br><span class=\"line\">FileInputStream(File file)</span><br><span class=\"line\">FileInputStream(String fileName)</span><br><span class=\"line\">&#x2F;&#x2F;方法</span><br><span class=\"line\">public void write(int b)</span><br><span class=\"line\">public void write(byte[] b)</span><br><span class=\"line\">public void write(byte[] b,int off,int len)</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>字节流写数据的问题</p><ol><li>创建字节输出流时，JVM会首先到操作系统中，查找目标文件。<br> a. 当发现目标文件不存在的时候，JVM会首先创建该目标文件(内容为空)<br> b. 当发现目标文件存在的时候, JVM默认会首先清空目标文件内容，最好准备让FileOutputStream,从文件头开始写入数据</li><li>如果要实现换行，核心是需要换行符<br> a. 类linux: ‘\\n’<br> b. windows: ‘\\r’ +’\\n’</li><li>数据写成功后，是要close()，因为要关闭此输出流，并且释放与此相关的系统资源</li><li>实现追加写入一定要新创建输出流对象，在两个不同的输出流对象上，向同一个文件写入数据，对文件的追加写入。<br> FileOutputStream(File file, boolean append)<br> //创建一个向指定 File 对象表示的文件中写入数据的文件输出流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处</li></ol>\n          </div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;获取当前系统的换行操作符</span><br><span class=\"line\">String s &#x3D; System.lineSeparator();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字节流读数据\"><a href=\"#字节流读数据\" class=\"headerlink\" title=\"字节流读数据\"></a>字节流读数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;构造方法</span><br><span class=\"line\">FileOutputStream(File file)</span><br><span class=\"line\">FileOutputStream(String fileName)</span><br><span class=\"line\">&#x2F;&#x2F;方法</span><br><span class=\"line\">public int read()\t\t\t&#x2F;&#x2F;返回读取一个字节数据，末尾则返回-1</span><br><span class=\"line\">public int read(byte[] b)\t\t&#x2F;&#x2F;返回读取的字节总数，末尾则返回-1</span><br><span class=\"line\">public int read(byte[] b, int offset, int length)\t&#x2F;&#x2F;读取保存在数组的[offset, offset + length)的区间</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字节缓冲流\"><a href=\"#字节缓冲流\" class=\"headerlink\" title=\"字节缓冲流\"></a>字节缓冲流</h3><p>字节流一次读取一个字节数组明显比一次读取一个字节的速度快的多，这是因为加了缓冲区的效果，减少了I/O操作次数，因此Java也提供了字节缓冲流。Read和Write都是在缓冲区进行交流。<br>字节缓冲输出流：BufferedOutputStream<br>字节缓冲输入流：BufferedInputStream</p>\n<h2 id=\"字符流\"><a href=\"#字符流\" class=\"headerlink\" title=\"字符流\"></a>字符流</h2><p>在某些情况下，使用字节流操作中文不方便。主要是因为数据单位不一致，因此可以采用将一个字符作为一个单位操作的I/O流。</p>\n<div class=\"note info\">\n            <p>字符流 = 字节流 + 编码表</p>\n          </div>\n\n<h3 id=\"编码表\"><a href=\"#编码表\" class=\"headerlink\" title=\"编码表\"></a>编码表</h3><p>编码表是字符与数值对应的关系表<br>常见编码表：</p>\n<ol>\n<li>ASCII/Unicode 字符集</li>\n<li>ISO-8859-1 -&gt; Latin-1</li>\n<li>GBK：2个字符表示一个中文 （JDK默认用GBK）</li>\n<li>UTF-8：一般3个字符表示一个中文（IDEA默认用UTF-8）</li>\n<li>UTF-16：一个字符固定占16位，中文也占16位 （JVM保存字符的默认格式）</li>\n</ol>\n<p>编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">byte[] getBytes(String charsetName)</span><br></pre></td></tr></table></figure>\n<p>解码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">string(byte[], int length, String charsetName)</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"转换流\"><a href=\"#转换流\" class=\"headerlink\" title=\"转换流\"></a>转换流</h3><p>要利用Writer或者Reader向文本中写入中文字符串，而Writer和Reader是抽象类，无法直接实例化，所以需要用其子类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;OutputStreamWriter的实例化</span><br><span class=\"line\">public OutputStreamWriter(OutputStream out)</span><br><span class=\"line\">public OutputStreamWriter(OutputStream out, String charsetName)</span><br><span class=\"line\">&#x2F;&#x2F;Writer写字符数据的方法</span><br><span class=\"line\">public void write(int c)\t\t&#x2F;&#x2F;写入一个字符，32位int只保留低位的16倍作为字符数据</span><br><span class=\"line\">public void write(char[] cbuff)\t\t&#x2F;&#x2F;将cbuff数组的内容写出</span><br><span class=\"line\">public void write(char[] cbuff, cbuff int, int off, int len)</span><br><span class=\"line\">public void write(String str)</span><br><span class=\"line\">public void write(String str, int off, int len)</span><br><span class=\"line\">&#x2F;&#x2F;InputStreamReader的实例化</span><br><span class=\"line\">public InputStreamReader(InputStream in)</span><br><span class=\"line\">public InputStreamReader(InputStream in, String charsetName)</span><br><span class=\"line\">&#x2F;&#x2F;Reader读数据的方法</span><br><span class=\"line\">public int read()</span><br><span class=\"line\">public int read(char[] cbuff)\t\t&#x2F;&#x2F;将读取的数据放入cbuff数组中</span><br><span class=\"line\">public int read(char[] cbuff, int off, int len)</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>字符流的为了实现编解码，自带缓冲区，如果不刷新或者关闭流时，是不会在目标文件上输出</p>\n          </div>\n<div class=\"note info\">\n            <p>flush()强制清空缓冲区并写出所有缓冲区，close()则是直接关闭整个流，会先调用flush()，再关闭流</p>\n          </div>\n\n<h3 id=\"简便文本输入输出流\"><a href=\"#简便文本输入输出流\" class=\"headerlink\" title=\"简便文本输入输出流\"></a>简便文本输入输出流</h3><p>因为转换流过于麻烦，于是Java提供了简化的字符输入输出包装流</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;FileReader</span><br><span class=\"line\">public FileReader(String fileName)</span><br><span class=\"line\">public FileReader(File file)</span><br><span class=\"line\">&#x2F;&#x2F;FileWriter</span><br><span class=\"line\">public FileWriter(String fileName)</span><br><span class=\"line\">public FileWriter(String fileName, boolean append)</span><br><span class=\"line\">public FileWriter(File file)</span><br><span class=\"line\">public FileWriter(File file, boolean append)</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>这两个类不提供指定编解码值</p>\n          </div>\n\n\n<h3 id=\"字符缓冲流\"><a href=\"#字符缓冲流\" class=\"headerlink\" title=\"字符缓冲流\"></a>字符缓冲流</h3><p>字符缓冲流定义了字符缓冲流独有的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;使用默认大小输入&#x2F;输出字符流</span><br><span class=\"line\">BufferedWriter(Writer writer)</span><br><span class=\"line\">BufferedReader(Reader reader)</span><br><span class=\"line\">&#x2F;&#x2F;BufferedWriter子类独有的方法</span><br><span class=\"line\">void newLine()\t\t&#x2F;&#x2F;写入一个对应系统的换行符</span><br><span class=\"line\">&#x2F;&#x2F;BufferedReader独有</span><br><span class=\"line\">String readLine() \t&#x2F;&#x2F;不读取换行符</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h1><p>单个程序看起来在同时完成多个任务，每一个任务在线程中执行。</p>\n<h2 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h2><p>一个进程代表一个运行的程序，而线程则是从进程中划分的最小任务并发执行单元。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Thread(Runnable target)</span><br><span class=\"line\">void start()</span><br><span class=\"line\">void run()</span><br><span class=\"line\">static void sleep(long millis)</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>不要调用Thread类或Runnable对象的run方法。直接调用会在同一个线程中执行，而没启动新的线程。如果要执行run方法的新线程，应该使用Thread.start方法。</p>\n          </div>\n\n<h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><ol>\n<li>New</li>\n<li>Runnable</li>\n<li>Blocked</li>\n<li>Waiting</li>\n<li>Timed waiting</li>\n<li>Terminated</li>\n</ol>\n<h3 id=\"新建线程\"><a href=\"#新建线程\" class=\"headerlink\" title=\"新建线程\"></a>新建线程</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Thread(Runnable runnable, String name);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可运行线程\"><a href=\"#可运行线程\" class=\"headerlink\" title=\"可运行线程\"></a>可运行线程</h3><p>一旦调用start方法，线程就处于可运行状态。可运行状态线程可能运行也可能没有运行。一个线程只有在调用yield()或者被阻塞或等待时才会失去控制权。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">static void yield()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"阻塞和等待线程\"><a href=\"#阻塞和等待线程\" class=\"headerlink\" title=\"阻塞和等待线程\"></a>阻塞和等待线程</h3><p>处于以下状态，可能使线程暂时不活动，从而等待特定条件来重新激活运行。</p>\n<ol>\n<li>当一个线程试图获取一个内部的对象锁，如果锁被其他线程占有，会进入阻塞状态。</li>\n<li>当线程等待另一个线程通知调度器出现一个条件时，会进入等待状态。</li>\n<li>有几个方法有超时参数，调用这些方法会让线程进入计时等待状态。</li>\n</ol>\n<h3 id=\"线程终止\"><a href=\"#线程终止\" class=\"headerlink\" title=\"线程终止\"></a>线程终止</h3><p>线程会由于以下两个原因终止：</p>\n<ol>\n<li>run方法正常退出，线程自然终止</li>\n<li>因为一个没有捕获的异常终止了run方法，使线程意外终止</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void join()</span><br><span class=\"line\">void join(long millis)</span><br><span class=\"line\">Thread.State.getState()\t\t&#x2F;&#x2F;返回值NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</span><br><span class=\"line\">void stop()</span><br><span class=\"line\">void suspend()</span><br><span class=\"line\">void resume()\t\t&#x2F;&#x2F;已被废弃</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程属性\"><a href=\"#线程属性\" class=\"headerlink\" title=\"线程属性\"></a>线程属性</h2><h3 id=\"中断线程\"><a href=\"#中断线程\" class=\"headerlink\" title=\"中断线程\"></a>中断线程</h3><p>除了已经废弃的stop方法，没有办法可以强制线程终止。不过interrupt可以用来请求一个终止线程。<br>当调用interrupt方法时候，就会设置线程的中断状态。每个线程都应该不时地检查这个标志，以判断是否可以被中断。<br>要想得出是否设置了中断状态，要先调用静态Thread.currentThread方法获取当前线程，再调用isInterrupted方法来判断。但是如果线程被阻塞，就无法检查中断状态。因而需要引入InterruptedException异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">while (!Thread.currentThread.isInterrupted() &amp;&amp; work to do) &#123;</span><br><span class=\"line\">  do more work;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>interrupted和isInterrupted两个方法</p>\n          </div>\n\n<div class=\"note danger\">\n            <p>不要抑制InterruptedException异常，如果想不出catch子句可以做什么有意义的工作，仍然有两个合理的选择：</p><ol><li>在catch子句中调用Thread.currentThread().interrupt()来设置中断，这样调用者就可以检测中断。</li><li>用throws InterruptedException标记你的异常，去掉try语句，调用者就可以捕获这个异常。</li></ol>\n          </div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void interrupt()</span><br><span class=\"line\">static boolean interrupted()</span><br><span class=\"line\">boolean isInterrupted()</span><br><span class=\"line\">static Thread currentThread()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>可以通过调用 t.setDaemon(true)将一个线程转换为守护线程。守护线程的作用就是为其他线程提供服务，当仅剩下守护线程时，虚拟机就会退出。<br>计时器、清空过时缓存项都是守护线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void setDaemon(boolean isDaemon)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p>不推荐使用，现在基本都是交给操作系统来管理线程。</p>\n<h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><p>两个线程对同一个数据进行写入，结果取决于访问数据的次序。这种情况称为竞态条件。</p>\n<h3 id=\"竞态条件的一个例子\"><a href=\"#竞态条件的一个例子\" class=\"headerlink\" title=\"竞态条件的一个例子\"></a>竞态条件的一个例子</h3><p>模拟银行，使用**<em>同步存取**</em></p>\n<h2 id=\"线程实现\"><a href=\"#线程实现\" class=\"headerlink\" title=\"线程实现\"></a>线程实现</h2><h3 id=\"实现方法一：继承Thread\"><a href=\"#实现方法一：继承Thread\" class=\"headerlink\" title=\"实现方法一：继承Thread\"></a>实现方法一：继承Thread</h3><p>每一个线程独立拥有自己的独立的字段属性，即各个线程独立运行，互不干扰。</p>\n<h3 id=\"实现方法二：实现Runnable\"><a href=\"#实现方法二：实现Runnable\" class=\"headerlink\" title=\"实现方法二：实现Runnable\"></a>实现方法二：实现Runnable</h3><p>适用于数据共享，多个线程共享共同的字段属性。<br>新建一个该Runnable类，使用new Thread(runnable).start()</p>\n<h2 id=\"线程实现问题\"><a href=\"#线程实现问题\" class=\"headerlink\" title=\"线程实现问题\"></a>线程实现问题</h2><p>本质都是对共享变量的操作不是原子操作。<br>思路一：对共享变量进行的一组操作，阻止其线程切换。但是抢占式线程调度，代码层面无法控制，因而无法实现。<br>思路二：给共享变量加锁，一组操作进行操作前加锁，直到进行结束时，都不解锁。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;同步代码块</span><br><span class=\"line\">synchronized(LockObject object) &#123;</span><br><span class=\"line\">\t需要同步的代码...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;synchronized也可以修饰方法（类中普通成员方法），将方法作为同步的。该锁对象是个隐式锁对象（其实就是this对象）。所以，哪个对象调用该同步方法，锁对象就是哪个。</span><br><span class=\"line\">privtae synchronized void function() &#123;</span><br><span class=\"line\">  需要同步的代码...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>synchronized也可以修饰静态方法，但是此时的锁对象就不是this了，而是这个类的class对象</p>\n          </div>\n\n<p>锁对象：可以是Java对象中的任意对象。因为：</p>\n<ol>\n<li>Java的对象内部都有一个标志位，可以作为标记加锁和解锁状态。</li>\n<li>锁对象，实际上就是充当“锁”这个角色。</li>\n</ol>\n<p>执行同步代码的细节：执行同步代码时，尝试对锁对象加锁。</p>\n<ol>\n<li>如果锁对象未锁，JVM对锁对象设标记位，并在锁对象中记录，哪个线程执行的加锁。加锁成功后开始执行。</li>\n<li>如果锁对象有锁，且加锁线程不是当前线程，则系统将当前线程处于阻塞态。直到加锁线程执行完毕，并释放锁。</li>\n</ol>\n<p>如何释放锁：某一线程执行完毕后，退出同步代码之前，JVM自动清理锁对象标志位，改为未上锁。</p>\n<h3 id=\"多卖\"><a href=\"#多卖\" class=\"headerlink\" title=\"多卖\"></a>多卖</h3><h3 id=\"超卖\"><a href=\"#超卖\" class=\"headerlink\" title=\"超卖\"></a>超卖</h3><h3 id=\"双检查（double-check）\"><a href=\"#双检查（double-check）\" class=\"headerlink\" title=\"双检查（double check）\"></a>双检查（double check）</h3><p>外部条件检查一次，进入同步代码块时，再检查一次，以确保绝对无误。即解决多卖还解决超卖。</p>\n<h2 id=\"线程锁\"><a href=\"#线程锁\" class=\"headerlink\" title=\"线程锁\"></a>线程锁</h2><p>JDK1.5之后提供了Lock锁机制。这种才是真正意义上完整的锁。因为加锁和锁解完全由自己所完成。<br>因为synchronized中的锁状态，仅仅表示锁状态，加锁和解锁完全有JVM隐式完成。</p>\n<h3 id=\"Lock接口\"><a href=\"#Lock接口\" class=\"headerlink\" title=\"Lock接口\"></a>Lock接口</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">lock()</span><br><span class=\"line\">unlock()</span><br><span class=\"line\">&#x2F;&#x2F;实现同步代码块</span><br><span class=\"line\">lock锁对象.lock();</span><br><span class=\"line\">同步代码块</span><br><span class=\"line\">lock锁对象.unlock();</span><br><span class=\"line\">&#x2F;&#x2F;Lock的直接实现</span><br><span class=\"line\">new ReentrantLock();</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>仅从构造代码块的角度来讲：推荐使用synchronized + Object。因为自己实现Lock会十分复杂，会出很多意向不到的问题。<br>在JDK文档中，对于Lock对象一定要用finally来进行释放锁。<br>在1.6等版本，两者加放锁效率不同，Lock锁会更快。但是在1.8之后，经过优化，两者相差几乎不多。<br>多线程工具：java.util.concurrent</p>\n          </div>\n\n<h2 id=\"同步的弊端：死锁\"><a href=\"#同步的弊端：死锁\" class=\"headerlink\" title=\"同步的弊端：死锁\"></a>同步的弊端：死锁</h2><p>如果同步出现了嵌套锁，可能会出现死锁。</p>\n<h3 id=\"解决方案一\"><a href=\"#解决方案一\" class=\"headerlink\" title=\"解决方案一\"></a>解决方案一</h3><p>把锁的执行顺序设置为相同的。</p>\n<h3 id=\"解决方案二\"><a href=\"#解决方案二\" class=\"headerlink\" title=\"解决方案二\"></a>解决方案二</h3><p>要么持有所有锁，要么一把锁都不持有。<br>例子：把所有的锁再放到一个锁中，以这个锁作为最终使用的锁。</p>\n<h2 id=\"生产者-消费者问题\"><a href=\"#生产者-消费者问题\" class=\"headerlink\" title=\"生产者-消费者问题\"></a>生产者-消费者问题</h2><h3 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h3><p>/定义在Object中</p>\n<ol>\n<li>wait()</li>\n<li>notify()</li>\n<li>notifyAll()</li>\n</ol>\n<div class=\"note info\">\n            <p>wait()：</p><ol><li>使当前线程阻塞，等待其他线程调用此对象notify()或notifyAll()方法来唤醒。</li><li>当前线程必须拥有此对象对象监视器（即当前线程持有一个锁对象，只能在当前线程的锁对象上调用wait()。</li><li>执行时，释放该监视器（锁）的所有权并等待。</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object o &#x3D; new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;才能正常运行</span><br><span class=\"line\">synchronized(o) &#123;</span><br><span class=\"line\">  if(condition) &#123;</span><br><span class=\"line\">    o.wait();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n          </div>\n\n<div class=\"note info\">\n            <p>notify():</p><ol><li>唤醒在此对象监视器上的单个线程，被唤醒时，需要重新获取监视器（锁对象）才能继续执行。</li><li>如果有多个线程阻塞，随机选择一个唤醒。<br>notifyAll():</li><li>唤醒在此对象监视器上的所有线程。</li><li>在多个线程执行的时候，一定要使用该方法。</li><li>在调用notifyAll()时，可能会出现虚假唤醒（就是唤醒了不该唤醒的线程），所以需要在线程执行之前，都进行条件判断，来确认自己是否满足条件。</li></ol>\n          </div>\n\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><h3 id=\"Executors\"><a href=\"#Executors\" class=\"headerlink\" title=\"Executors\"></a>Executors</h3><p>JDK1.5后提供线程池</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ExecutorService newCacheThreadPool()</span><br><span class=\"line\">&#x2F;&#x2F;针对短期异步任务的线程，可提高程序效率。</span><br><span class=\"line\">&#x2F;&#x2F;如果现有线程没有可用的，创建一个新线程加入到线程池。</span><br><span class=\"line\">&#x2F;&#x2F;终止并从缓存中移除60s中没有运行的线程</span><br><span class=\"line\">ExecutorService newFixedThreadPool(int nThreads)</span><br><span class=\"line\">ExecutorService newSingleThreadExecutor()</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>对于线程池而言，可以提交两种类型的线程：</p><ol><li>Runnable子类对象，没有返回值。</li><li>Callable接口，返回范型。</li></ol>\n          </div>\n<h3 id=\"Future接口\"><a href=\"#Future接口\" class=\"headerlink\" title=\"Future接口\"></a>Future接口</h3><p>表示异步类计算结果</p>\n<h3 id=\"关闭线程池\"><a href=\"#关闭线程池\" class=\"headerlink\" title=\"关闭线程池\"></a>关闭线程池</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">shutdown()</span><br><span class=\"line\">shutdownNow()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"线程池的运作原理\"><a href=\"#线程池的运作原理\" class=\"headerlink\" title=\"线程池的运作原理\"></a>线程池的运作原理</h3><p>维护一个阻塞队列BlockingQueue。</p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><h3 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h3><p>Timer，线程安排之后在后台中执行的任务，可安排任务执行一次或定期执行。</p>\n<div class=\"note info\">\n            <p>与Timer对象对应的是一个后台线程，用于顺序（轮循）执行所有计时器任务。</p>\n          </div>\n\n<h3 id=\"终止定时器\"><a href=\"#终止定时器\" class=\"headerlink\" title=\"终止定时器\"></a>终止定时器</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Timer下的cancel()</span><br><span class=\"line\">TimerTask下的ancel()</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>TimerTask下的cancel()只针对于自己，将自己（TimerTask对象）从计时器中移出，所以只有在运行的时候才能cancel()</p>\n          </div>\n\n\n<h1 id=\"GC管理\"><a href=\"#GC管理\" class=\"headerlink\" title=\"GC管理\"></a>GC管理</h1><h2 id=\"JavaMemoery\"><a href=\"#JavaMemoery\" class=\"headerlink\" title=\"JavaMemoery\"></a>JavaMemoery</h2><h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>很小的内存区域，是线程私有的内存空间，是当前线程所执行的字节码行号指示器。</p>\n<div class=\"note info\">\n            <p>每个线程都有一个程序计数器</p>\n          </div>\n<h3 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h3><p>描述的是Java方法执行的内存模型，每个方法执行时都会生成一个栈帧，存储局部变量表，操作栈，动态链接，方法出口等信息。栈内存是线程私有的，局部变量不会被共享。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。</p>\n<h3 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h3><p>此内存区域的唯一目的就是存放对象，一个JVM实例只存在一个堆，堆内存的大小是可以调节的。堆内存是线程共享的</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量等数据。</p>\n<h2 id=\"内存管理方式\"><a href=\"#内存管理方式\" class=\"headerlink\" title=\"内存管理方式\"></a>内存管理方式</h2><h3 id=\"显式内存管理（C-C-）\"><a href=\"#显式内存管理（C-C-）\" class=\"headerlink\" title=\"显式内存管理（C/C++）\"></a>显式内存管理（C/C++）</h3><p>malloc、free。</p>\n<div class=\"note warning\">\n            <p>野指针：<br>内存泄漏：</p>\n          </div>\n<h3 id=\"隐式内存管理（JAVA-其他）\"><a href=\"#隐式内存管理（JAVA-其他）\" class=\"headerlink\" title=\"隐式内存管理（JAVA/其他）\"></a>隐式内存管理（JAVA/其他）</h3><h2 id=\"如何判断垃圾\"><a href=\"#如何判断垃圾\" class=\"headerlink\" title=\"如何判断垃圾\"></a>如何判断垃圾</h2><h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>查看对象是否能被访问到：采用引用计数法。</p>\n<ol>\n<li>每个对象添加一个引用计数器。</li>\n<li>当有个地方引用他的时候，引用计数器+1。</li>\n<li>当引用失效的时候，引用计数器-1。</li>\n<li>当计数器值为0的时候，对象无法被引用，表面对象不存在。<div class=\"note info\">\n            <p>当两个对象循环引用的时候，引用计数法无法判断是否存在垃圾</p>\n          </div>\n<h3 id=\"根搜索算法\"><a href=\"#根搜索算法\" class=\"headerlink\" title=\"根搜索算法\"></a>根搜索算法</h3>GC Roots包含的对象：</li>\n<li>虚拟机栈中引用的对象。</li>\n<li>方法区静态属性引用的对象。<div class=\"note info\">\n            <p>这两个对象，都是可以直接访问到的对象，且这两个引用指向的对象，一定可以访问到对象。</p>\n          </div>\n从GC Roots的节点开始，向下搜索，如果当一个对象无法通过任何一个链搜索到时，则认为该对象是垃圾。</li>\n</ol>\n<h2 id=\"如何回收垃圾\"><a href=\"#如何回收垃圾\" class=\"headerlink\" title=\"如何回收垃圾\"></a>如何回收垃圾</h2><h3 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h3><p>优点：回收很简单。<br>缺点：但是会产生内存碎片。</p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>在内存分配的时候，保留区域不使用；但是在内存回收的时候，使用他。<br>回收一次后，保留区域变成使用区域，使用区域清空变成空闲区域。<br>优点：没有内存碎片。<br>缺点：内存使用效率低，如果对象过多，回收效率会变慢。</p>\n<h3 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h3><h3 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h3><p>针对堆内存：新生代、老年代。<br>新生代：特点，朝生夕死，所以使用复制算法。8:1:1 eden:survivor:survivor。每次只使用一个survivor作为保留区域。<br>老年代：特点，稳定，持续存在，使用标记整理算法。新生代每经过一次垃圾回收，存活后计数+1，当15次后，即可进入老年代。</p>\n<h2 id=\"GC触发时机\"><a href=\"#GC触发时机\" class=\"headerlink\" title=\"GC触发时机\"></a>GC触发时机</h2><h3 id=\"申请堆空间失败时\"><a href=\"#申请堆空间失败时\" class=\"headerlink\" title=\"申请堆空间失败时\"></a>申请堆空间失败时</h3><h3 id=\"系统进入idle后，一段时间后会进行\"><a href=\"#系统进入idle后，一段时间后会进行\" class=\"headerlink\" title=\"系统进入idle后，一段时间后会进行\"></a>系统进入idle后，一段时间后会进行</h3><h3 id=\"主动调用GC\"><a href=\"#主动调用GC\" class=\"headerlink\" title=\"主动调用GC\"></a>主动调用GC</h3><p>System.gc</p>\n<h2 id=\"GC相关概念\"><a href=\"#GC相关概念\" class=\"headerlink\" title=\"GC相关概念\"></a>GC相关概念</h2><h3 id=\"Shallow-Size\"><a href=\"#Shallow-Size\" class=\"headerlink\" title=\"Shallow Size\"></a>Shallow Size</h3><p>对象本身占用内存大小，对象头+成员变量内存</p>\n<h3 id=\"Retained-Size\"><a href=\"#Retained-Size\" class=\"headerlink\" title=\"Retained Size\"></a>Retained Size</h3><p>该对象的Shallow Size + 仅可以从自身访问的对象的Shallow Size总和。</p>\n<div class=\"note info\">\n            <p>注意仅这个字，实际上就是回收该对象，总共会回收的内存大小。</p>\n          </div>\n<div class=\"note info\">\n            <p>内存泄漏不一定导致内存溢出。</p>\n          </div>\n","categories":["编程语言"],"tags":["Java"]},{"title":"Java版本特征","url":"/2021/03/15/Java%E7%89%88%E6%9C%AC%E7%89%B9%E5%BE%81/","content":"<h1 id=\"Java8\"><a href=\"#Java8\" class=\"headerlink\" title=\"Java8\"></a>Java8</h1><h2 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h2><p>箭头符号 -&gt;<br>符号左侧：表达式参数列表<br>符号右侧：表达式所执行的功能，即lambda体<br>lambda表达式需要函数式接口支持</p>\n<span id=\"more\"></span>\n\n<h3 id=\"语法格式一：无参数，无返回值\"><a href=\"#语法格式一：无参数，无返回值\" class=\"headerlink\" title=\"语法格式一：无参数，无返回值\"></a>语法格式一：无参数，无返回值</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">() -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;需要用一个拥有无参无返回值的接口</span><br><span class=\"line\">Runnable run1 &#x3D; () -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>在Java1.7之前，匿名内部类应用了同级别的局部变量，该变量必须是final。Java1.8之后则不需要，因为会JDK会自动将变量处理为final。</p>\n          </div>\n\n<h3 id=\"语法格式二：有一个参数，并且无返回值\"><a href=\"#语法格式二：有一个参数，并且无返回值\" class=\"headerlink\" title=\"语法格式二：有一个参数，并且无返回值\"></a>语法格式二：有一个参数，并且无返回值</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(x) -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法格式三：有一个参数（小括号可以不写），并且无返回值\"><a href=\"#语法格式三：有一个参数（小括号可以不写），并且无返回值\" class=\"headerlink\" title=\"语法格式三：有一个参数（小括号可以不写），并且无返回值\"></a>语法格式三：有一个参数（小括号可以不写），并且无返回值</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">x -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法格式四：有两个以上的参数，并且lambda体中有多条语句，且有返回值\"><a href=\"#语法格式四：有两个以上的参数，并且lambda体中有多条语句，且有返回值\" class=\"headerlink\" title=\"语法格式四：有两个以上的参数，并且lambda体中有多条语句，且有返回值\"></a>语法格式四：有两个以上的参数，并且lambda体中有多条语句，且有返回值</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(x, y) -&gt; &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  return ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法格式五：若lambda体只有一条语句，return和大括号都可以省略不写（推荐）\"><a href=\"#语法格式五：若lambda体只有一条语句，return和大括号都可以省略不写（推荐）\" class=\"headerlink\" title=\"语法格式五：若lambda体只有一条语句，return和大括号都可以省略不写（推荐）\"></a>语法格式五：若lambda体只有一条语句，return和大括号都可以省略不写（推荐）</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; com &#x3D; (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法格式六：lambda表达式的数据类型可以省略不写（类型推断：JVM会从上下文自动推断）\"><a href=\"#语法格式六：lambda表达式的数据类型可以省略不写（类型推断：JVM会从上下文自动推断）\" class=\"headerlink\" title=\"语法格式六：lambda表达式的数据类型可以省略不写（类型推断：JVM会从上下文自动推断）\"></a>语法格式六：lambda表达式的数据类型可以省略不写（类型推断：JVM会从上下文自动推断）</h3><div class=\"note info\">\n            <p>左右遇一括号省，左侧推断类型省</p>\n          </div>\n\n<h3 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h3><p>如果一个接口只有一个抽象方法的接口，称为函数式接口。<br>可以使用注解@FunctionalInterface来检查是不是函数式接口，如果写超过一个方法，则会报错。</p>\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><p>:: 双冒号</p>\n<h1 id=\"Java11\"><a href=\"#Java11\" class=\"headerlink\" title=\"Java11\"></a>Java11</h1><h1 id=\"Java14\"><a href=\"#Java14\" class=\"headerlink\" title=\"Java14\"></a>Java14</h1><h1 id=\"Java17\"><a href=\"#Java17\" class=\"headerlink\" title=\"Java17\"></a>Java17</h1><h1 id=\"Java21\"><a href=\"#Java21\" class=\"headerlink\" title=\"Java21\"></a>Java21</h1>","categories":["编程语言"],"tags":["Java"]},{"title":"Java面试题","url":"/2021/03/06/Java%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"<p><img src=\"/2021/03/06/Java%E9%9D%A2%E8%AF%95%E9%A2%98/1.jpg\" alt=\"xxx\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><h2 id=\"JDK、JVM、JRE分别是什么，有什么区别\"><a href=\"#JDK、JVM、JRE分别是什么，有什么区别\" class=\"headerlink\" title=\"JDK、JVM、JRE分别是什么，有什么区别\"></a>JDK、JVM、JRE分别是什么，有什么区别</h2><h2 id=\"什么是面向对象的思想\"><a href=\"#什么是面向对象的思想\" class=\"headerlink\" title=\"什么是面向对象的思想\"></a>什么是面向对象的思想</h2><h2 id=\"和equals的区别\"><a href=\"#和equals的区别\" class=\"headerlink\" title=\"==和equals的区别\"></a>==和equals的区别</h2><h2 id=\"final的理解\"><a href=\"#final的理解\" class=\"headerlink\" title=\"final的理解\"></a>final的理解</h2><h2 id=\"String、StringBuffer、StringBuilder的区别\"><a href=\"#String、StringBuffer、StringBuilder的区别\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder的区别\"></a>String、StringBuffer、StringBuilder的区别</h2><h2 id=\"接口和抽象类\"><a href=\"#接口和抽象类\" class=\"headerlink\" title=\"接口和抽象类(*)\"></a>接口和抽象类(*)</h2><h2 id=\"递归简单算法题-N递归、不死神兔\"><a href=\"#递归简单算法题-N递归、不死神兔\" class=\"headerlink\" title=\"递归简单算法题(N递归、不死神兔)\"></a>递归简单算法题(N递归、不死神兔)</h2><h2 id=\"Integer和int\"><a href=\"#Integer和int\" class=\"headerlink\" title=\"Integer和int\"></a>Integer和int</h2><p>自动拆箱和自动装箱问题</p>\n<h2 id=\"final，finally和finalize的区别\"><a href=\"#final，finally和finalize的区别\" class=\"headerlink\" title=\"final，finally和finalize的区别\"></a>final，finally和finalize的区别</h2><p>&emps;&emps;&emps;&emps;final是修饰符，可以修饰类、变量和方法。</p>\n<ol>\n<li>修饰类：类不可被继承</li>\n<li>修饰变量，即为常量，不可被修改</li>\n<li></li>\n</ol>\n<h2 id=\"如果catch里面有return语句，请问finally的代码还会执行吗-如果会，请问是在return前还是return后？\"><a href=\"#如果catch里面有return语句，请问finally的代码还会执行吗-如果会，请问是在return前还是return后？\" class=\"headerlink\" title=\"如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后？\"></a>如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后？</h2><h2 id=\"常量池相关\"><a href=\"#常量池相关\" class=\"headerlink\" title=\"常量池相关\"></a>常量池相关</h2><p>&emps;&emps;&emps;&emps;静态常量池和运行常量池。<br>&emps;&emps;&emps;&emps;常量池主要用于存放两大类常量： 字面量和符号引用量。<br>&emps;&emps;&emps;&emps;字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值(成员变量)等。<br>&emps;&emps;&emps;&emps;符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p>\n<ol>\n<li>类和接口的全限定名</li>\n<li>字段名称和描述符</li>\n<li>方法名称和描述符</li>\n</ol>\n<h2 id=\"float-3-4-是否正确？\"><a href=\"#float-3-4-是否正确？\" class=\"headerlink\" title=\"float = 3.4 是否正确？\"></a>float = 3.4 是否正确？</h2><p>&emps;&emps;&emps;&emps;不正确，Java默认没加F，为双精度数。</p>\n<h2 id=\"short-s1-1；s1-s1-1；short-s1-1-s1-1\"><a href=\"#short-s1-1；s1-s1-1；short-s1-1-s1-1\" class=\"headerlink\" title=\"short s1 = 1；s1 = s1 + 1；short s1 = 1; s1 += 1;\"></a>short s1 = 1；s1 = s1 + 1；short s1 = 1; s1 += 1;</h2><p>&emps;&emps;&emps;&emps;大坑，IntegerCache，JVM会初始化一个[-128,127]的缓存。</p>\n<h2 id=\"接口和抽象类的区别\"><a href=\"#接口和抽象类的区别\" class=\"headerlink\" title=\"接口和抽象类的区别\"></a>接口和抽象类的区别</h2><p>&emps;&emps;&emps;&emps;</p>\n<h1 id=\"Java框架\"><a href=\"#Java框架\" class=\"headerlink\" title=\"Java框架\"></a>Java框架</h1><h2 id=\"ArrayList和LinkedList的区别\"><a href=\"#ArrayList和LinkedList的区别\" class=\"headerlink\" title=\"ArrayList和LinkedList的区别\"></a>ArrayList和LinkedList的区别</h2><ol>\n<li>线程安全</li>\n<li>底层数据结构</li>\n<li>插入和删除</li>\n<li>随机访问</li>\n<li>内存占用</li>\n</ol>\n<h2 id=\"RandomAccess接口\"><a href=\"#RandomAccess接口\" class=\"headerlink\" title=\"RandomAccess接口\"></a>RandomAccess接口</h2><h2 id=\"ArrayLsit和Vector区别\"><a href=\"#ArrayLsit和Vector区别\" class=\"headerlink\" title=\"ArrayLsit和Vector区别\"></a>ArrayLsit和Vector区别</h2><p>&emps;&emps;&emps;&emps;Vector是同步的，可以由多个线程一起安全地访问一个Vector对象，但是在同步上需要花费大量时间。</p>\n<h2 id=\"HashMap和HashTable的区别\"><a href=\"#HashMap和HashTable的区别\" class=\"headerlink\" title=\"HashMap和HashTable的区别\"></a>HashMap和HashTable的区别</h2><ol>\n<li>线程安全</li>\n<li>底层数据结构</li>\n<li>效率</li>\n<li>null key和null value</li>\n<li>初始容量大小和每次扩容大小的不同</li>\n</ol>\n<h2 id=\"为什么HashMap长度是2的n次幂\"><a href=\"#为什么HashMap长度是2的n次幂\" class=\"headerlink\" title=\"为什么HashMap长度是2的n次幂\"></a>为什么HashMap长度是2的n次幂</h2><h2 id=\"HashMap多线程导致的死循环\"><a href=\"#HashMap多线程导致的死循环\" class=\"headerlink\" title=\"HashMap多线程导致的死循环\"></a>HashMap多线程导致的死循环</h2><p>&emps;&emps;&emps;&emps;HashMap的扩容resize()</p>\n<div class=\"note info\">\n            <p>jdk1.8已经解决了死循环的问题。</p>\n          </div>\n\n<h2 id=\"HashSet和HashMap的区别\"><a href=\"#HashSet和HashMap的区别\" class=\"headerlink\" title=\"HashSet和HashMap的区别\"></a>HashSet和HashMap的区别</h2><h2 id=\"ConcurrentHashMap-和-Hashtable-的区别\"><a href=\"#ConcurrentHashMap-和-Hashtable-的区别\" class=\"headerlink\" title=\"ConcurrentHashMap 和 Hashtable 的区别\"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p>&emps;&emps;&emps;&emps;底层数据结构<br>&emps;&emps;&emps;&emps;实现线程安全的方式</p>\n<h2 id=\"什么时候用lambda表达式，什么时候用方法引用\"><a href=\"#什么时候用lambda表达式，什么时候用方法引用\" class=\"headerlink\" title=\"什么时候用lambda表达式，什么时候用方法引用\"></a>什么时候用lambda表达式，什么时候用方法引用</h2><h2 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h2><h2 id=\"git-rebase和merge的区别\"><a href=\"#git-rebase和merge的区别\" class=\"headerlink\" title=\"git rebase和merge的区别\"></a>git rebase和merge的区别</h2><h2 id=\"Thread-sleep-和Object-wait\"><a href=\"#Thread-sleep-和Object-wait\" class=\"headerlink\" title=\"Thread.sleep()和Object.wait()\"></a>Thread.sleep()和Object.wait()</h2><ol>\n<li>sleep是Thread的静态方法，wait是Object的成员方法。</li>\n<li>sleep在休眠时间到了后，就会唤醒，wait是其他线程，在同一个对象中，调用notify()或notifyAll()。</li>\n<li>sleep使用没有任何前提，wait要求必须当前线程在持有的锁对象上调用。</li>\n<li>sleep在阻塞时不会放弃锁的持有，而wait会在阻塞时，放弃锁对象。</li>\n</ol>\n","categories":["编程语言"],"tags":["Java"]},{"title":"LeetCode","url":"/2021/04/14/LeetCode_Java/","content":"<h1 id=\"LeetCode\"><a href=\"#LeetCode\" class=\"headerlink\" title=\"LeetCode\"></a>LeetCode</h1><span id=\"more\"></span>\n<h1 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h1><h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a>15. 三数之和</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>\n<p>注意：答案中不可以包含重复的三元组。</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode.cn/problems/3sum\">https://leetcode.cn/problems/3sum</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>通过对有序数组的两边进行夹逼得到对应所求元素。</p>\n<ol>\n<li>排序：因为要得到求和，有序的数列更好处理。</li>\n<li>中间目标值：先有序选取一个值，然后将目标值减去该值（target - i），得到中间目标值。</li>\n<li>夹逼：因为有序，所以从两边依次夹逼，直到得到中间目标值或确定不存在。<br> 确定退出夹逼的循环条件：j &lt; k;</li>\n<li>去重</li>\n<li>注意数组边界条件</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;三个指针i,j,k</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; &#x2F;&#x2F;要加i &gt; 0，防止减为负的</span><br><span class=\"line\">            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F;定义结果</span><br><span class=\"line\">            int k &#x3D; nums.length - 1;</span><br><span class=\"line\">            int twoSum &#x3D; -nums[i];</span><br><span class=\"line\">            for (int j &#x3D; i + 1; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">                if (j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) &#123;</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                while (j &lt; k &amp;&amp; nums[j] + nums[k] &gt; twoSum) &#123;</span><br><span class=\"line\">                    k--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (j &#x3D;&#x3D; k) &#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (nums[j] + nums[k] &#x3D;&#x3D; twoSum) &#123;</span><br><span class=\"line\">                    ArrayList&lt;Integer&gt; numResult &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">                    numResult.add(nums[i]);</span><br><span class=\"line\">                    numResult.add(nums[j]);</span><br><span class=\"line\">                    numResult.add(nums[k]);</span><br><span class=\"line\">                    result.add(numResult);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><h1 id=\"208-实现Trie（前缀树）\"><a href=\"#208-实现Trie（前缀树）\" class=\"headerlink\" title=\"208. 实现Trie（前缀树）\"></a>208. 实现Trie（前缀树）</h1><h2 id=\"什么是前缀树\"><a href=\"#什么是前缀树\" class=\"headerlink\" title=\"什么是前缀树\"></a>什么是前缀树</h2><p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：<br>指向子节点的指针数组 children。对于本题而言，数组长度为26，即小写英文字母的数量。此时 children[0]对应小写字母 a，children[1]对应小写字母 b，…，children[25]对应小写字母 z。<br>布尔字段 isEnd，表示该节点是否为字符串的结尾。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2>","categories":["数据结构与算法"],"tags":["Java","算法"]},{"title":"Linux","url":"/2020/09/11/Linux/","content":"<h1 id=\"Linux简介\"><a href=\"#Linux简介\" class=\"headerlink\" title=\"Linux简介\"></a>Linux简介</h1><span id=\"more\"></span>\n\n<h1 id=\"Linux框架\"><a href=\"#Linux框架\" class=\"headerlink\" title=\"Linux框架\"></a>Linux框架</h1><p><img src=\"/2020/09/11/Linux/1.png\"><br>操作性系统 = 内核 + 系统调用<br>Linux启动首先启动内核，内核是一段计算机操作系统程序，这个程序直接管理管理硬件，包括CPU、内存空间、硬盘接口、网络接口等等。所有的计算机操作都要通过内核传递给硬件。<br>为了方便调用内核，Linux将内核的功能接口制作成系统调用(system call)。系统调用看起来就像C语言的函数。你可以在程序中直接调用。<br>在命令行中输入$man 2 syscalls可以查看所有的系统调用。<br>Linux定义一些库函数(library routine)来将系统调用组合成某些常用的功能。</p>\n<h1 id=\"Linux系统规划和分区\"><a href=\"#Linux系统规划和分区\" class=\"headerlink\" title=\"Linux系统规划和分区\"></a>Linux系统规划和分区</h1><h2 id=\"硬盘分区格式\"><a href=\"#硬盘分区格式\" class=\"headerlink\" title=\"硬盘分区格式\"></a>硬盘分区格式</h2><ol>\n<li>MBR<br>启动引导程序记录和分区表一般放在第一个扇区（以古老的512字节的扇区大小举例）：</li>\n</ol>\n<ul>\n<li>主引导记录：安装启动引导程序的地方，446字节。启动引导程序负责加载内核文件</li>\n<li>分区表：分区区块仅有64字节，所以规定只允许4组记录区，每组16字节（可以为4组主要分区或3组主要+1组拓展），每组记录起始和结束的柱面号码；</li>\n<li>拓展分区可以分为多个逻辑分区，逻辑分区的数量由操作系统限定；拓展分区只能有一个；拓展分区不能被格式化，只能对拓展分区下的逻辑分区进行格式化；拓展分区的逻辑分区表都在对应的逻辑分区的前，上一个逻辑分区表通过链表指针指向下一个逻辑分区表。</li>\n<li>逻辑分区设备名称号码由5号开始<br>缺点：一般情况如果分区表损坏，即无法正常读取到分区；无法使用2.2TB以上的磁盘容量</li>\n</ul>\n<ol start=\"2\">\n<li>GPT</li>\n</ol>\n<ul>\n<li>磁盘所有区块使用LBA（Logical Block Address 逻辑区块地址）来处理，默认为512字节。硬盘的末尾做一个相同的备份，以防止意外</li>\n<li>LBA0（MBR兼容区别）</li>\n<li>LBA1（GPT表头记录）</li>\n<li>LBA2-33（实际记录分区信息区）</li>\n<li>每个LBA为512字节，可以有4组分区（每组128字节）32个LBA就有128组分区；每组内有64位用来提供开始/结束扇区。 2^64 * 512字节</li>\n</ul>\n<h2 id=\"Bios\"><a href=\"#Bios\" class=\"headerlink\" title=\"Bios\"></a>Bios</h2><p>Bios会根据配置，找到用户的第一个扇区的MBR位置，里面包含（安装系统的）启动引导程序。启动引导程序又会加载系统内核文件，开启操作系统。</p>\n<h2 id=\"UEFI\"><a href=\"#UEFI\" class=\"headerlink\" title=\"UEFI\"></a>UEFI</h2><h2 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h2><ol>\n<li>/：根⽬录，所有的⽬录、⽂件、设备都在/之下，/就是Linux⽂件系统的组织者，也是最上级的领<br>导者。</li>\n<li>/bin：bin 就是⼆进制（binary）英⽂缩写。在⼀般的系统当中，都可以在这个⽬录下找到linux<br>常⽤的命令。系统所需要的那些命令位于此⽬录。</li>\n<li>/boot：Linux的内核及引导系统程序所需要的⽂件⽬录。</li>\n<li>/dev：dev 是设备（device)的英⽂缩写。这个⽬录对所有的⽤户都⼗分重要。因为在这个⽬录中<br>包含了所有linux系统中使⽤的外部设备。但是这⾥并不是放的外部设备的驱动程序。这⼀点和常<br>⽤的windows,dos操作系统不⼀样。它实际上是⼀个访问这些外部设备的端⼝。可以⾮常⽅便地去<br>访问这些外部设备，和访问⼀个⽂件，⼀个⽬录没有任何区别。</li>\n<li>/home：如果建⽴⼀个⽤户，⽤户名是”xx”,那么在/home⽬录下就有⼀个对应的/home/xx路径，<br>⽤来存放⽤户的主⽬录。</li>\n<li>/lib：lib是库（library）英⽂缩写。这个⽬录是⽤来存放系统动态连接共享库的。⼏乎所有的应⽤<br>程序都会⽤到这个⽬录下的共享库。因此，千万不要轻易对这个⽬录进⾏什么操作，⼀旦发⽣问<br>题，系统就不能⼯作了。</li>\n<li>/proc：存储的是当前内核运⾏状态的⼀系列特殊⽂件，⽤户可以通过这些⽂件查看有关系统硬件<br>及当前正在运⾏进程的信息，甚⾄可以通过更改其中某些⽂件来改变内核的运⾏状态。此外还<br>有/srv /sys三个⽬录，内核相关⽬录，不要动。</li>\n<li>/root：Linux超级权限⽤户root的家⽬录。</li>\n<li>/sbin：这个⽬录是⽤来存放系统管理员的系统管理程序。⼤多是涉及系统管理的命令的存放，是<br>超级权限⽤户root的可执⾏命令存放地，普通⽤户⽆权限执⾏这个⽬录下的命令，sbin中包含的<br>都是root权限才能执⾏的。</li>\n<li>/usr：这是linux系统中占⽤硬盘空间最⼤的⽬录。⽤户的很多应⽤程序和⽂件都存放在这个⽬录<br>下。 Unix software resource usr。类似windows系统的program files</li>\n<li>/usr/local：这⾥主要存放那些⼿动安装的软件，即不是通过或apt-get安装的软件。它和/usr⽬<br>录具有相类似的⽬录结构。</li>\n<li>/usr/share ：系统共⽤的东⻄存放地，⽐如 /usr/share/fonts 是字体⽬录，/usr/share/doc<br>和/usr/share/man帮助⽂件。</li>\n<li>/etc：管理所有的配置⽂件的⽬录，⽐如安装mysql的配置⽂件my.conf</li>\n<li>/mnt：可供系统管理员使⽤，⼿动挂载⼀些临时设备媒体设备的⽬录。</li>\n<li>/media：是⾃动挂载的⽬录。当把U盘插⼊到系统中，会⾃动挂载到该⽬录下。⽐如插⼊⼀个U<br>盘，会⾃动到/media⽬录中挂载。</li>\n<li>/opt：额外安装软件存放的⽬录。⽐如mysql的安装包就可以放在该⽬录。</li>\n</ol>\n<h1 id=\"文件和目录管理\"><a href=\"#文件和目录管理\" class=\"headerlink\" title=\"文件和目录管理\"></a>文件和目录管理</h1><h2 id=\"目录文件\"><a href=\"#目录文件\" class=\"headerlink\" title=\"目录文件\"></a>目录文件</h2><h3 id=\"mkdir\"><a href=\"#mkdir\" class=\"headerlink\" title=\"mkdir\"></a>mkdir</h3><h3 id=\"rmdir\"><a href=\"#rmdir\" class=\"headerlink\" title=\"rmdir\"></a>rmdir</h3><h3 id=\"cp\"><a href=\"#cp\" class=\"headerlink\" title=\"cp\"></a>cp</h3><p>[root@www ~]# cp [-adfilprsu] 来源档(source) ⽬标档(destination)<br>-a：相当於 -pdr 的意思，⾄於 pdr 请参考下列说明；(常⽤)<br>-d：若来源档为连结档的属性(link file)，则复制连结档属性⽽⾮⽂件本身；<br>-f：为强制(force)的意思，若⽬标⽂件已经存在且⽆法开启，则移除后再尝试⼀次；<br>-i：若⽬标档(destination)已经存在时，在覆盖时会先询问动作的进⾏(常⽤)<br>-l：进⾏硬式连结(hard link)的连结档创建，⽽⾮复制⽂件本身；<br>-p：连同⽂件的属性⼀起复制过去，⽽⾮使⽤默认属性(备份常⽤)；<br>-r：递归持续复制，⽤於⽬录的复制⾏为；(常⽤)<br>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』⽂件；<br>-u：若 destination ⽐ source 旧才升级 destination ！</p>\n<h3 id=\"mv\"><a href=\"#mv\" class=\"headerlink\" title=\"mv\"></a>mv</h3><p>[root@www ~]# mv [-fiu] source destination<br>-f ：force 强制的意思，如果⽬标⽂件已经存在，不会询问⽽直接覆盖；<br>-i ：若⽬标⽂件 (destination) 已经存在时，就会询问是否覆盖！<br>-u ：若⽬标⽂件已经存在，且 source ⽐较新，才会升级 (update)</p>\n<h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><p>-f ：就是 force 的意思，忽略不存在的⽂件，不会出现警告信息；<br>-i ：互动模式，在删除前会询问使⽤者是否动作<br>-r ：递归删除啊！最常⽤在⽬录的删除了！这是⾮常危险的选项！！！</p>\n<h2 id=\"普通文件\"><a href=\"#普通文件\" class=\"headerlink\" title=\"普通文件\"></a>普通文件</h2><h3 id=\"touch\"><a href=\"#touch\" class=\"headerlink\" title=\"touch\"></a>touch</h3><h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h3><h3 id=\"more\"><a href=\"#more\" class=\"headerlink\" title=\"more:\"></a>more:</h3><p>和cat功能类似，不过是以分⻚的形式⼀⻚⼀⻚显示数据。最基本的指令就是按空⽩键（space）就往下⼀⻚显示，按 b 键就会往回（back）⼀⻚显示。<br>+n ：从笫n⾏开始显示<br>-c ：从顶部清屏，然后显示</p>\n<h3 id=\"less\"><a href=\"#less\" class=\"headerlink\" title=\"less\"></a>less</h3><p>也⽤来分⻚显示数据，但是功能⽐more强⼤。并不会⼀次性将全部⽂件读取才显示，⽽是根据显示<br>的需要加载对应的数据。<br>-f ：强迫打开特殊⽂件，例如外围设备代号、⽬录和⼆进制⽂件<br>-m ：显示类似more命令的百分⽐<br>-N ：显示每⾏的⾏号<br>操作命令：<br>b 向后翻⼀⻚<br>d 向后翻半⻚<br>h 显示帮助界⾯<br>q 退出less 命令<br>u 向前滚动半⻚<br>y 向前滚动⼀⾏</p>\n<h3 id=\"head\"><a href=\"#head\" class=\"headerlink\" title=\"head\"></a>head</h3><p>查看⼀个⽂件，取开头的⼀部分内容。head filename，或者添加选项： head -5 filename</p>\n<h3 id=\"tail\"><a href=\"#tail\" class=\"headerlink\" title=\"tail\"></a>tail</h3><p>查看⼀个⽂件的尾部内容。tail -5 filename，查看⽂件的最后五⾏<br>常⻅⽤法：tail -f filename,尾部持续不断地输出内容。Control + c退出。<br>例如：tail -5f filename</p>\n<h3 id=\"echo\"><a href=\"#echo\" class=\"headerlink\" title=\"echo\"></a>echo</h3><p>输出内容到控制台。⽐如输出Linux的环境变量到控制台</p>\n<div class=\"note info\">\n            <p>“&gt;”指令：输出重定向，会覆盖原来内容<br>“&gt;&gt;”指令：追加，不会覆盖原来内容</p>\n          </div>\n\n<h3 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h3><p>tar是⽤来建⽴，还原备份⽂件的⼯具程序，它可以加⼊，解开备份⽂件内的⽂件。<br>-c:产⽣.tar⽂件<br>-v:显示详细信息<br>-z:打包同时压缩<br>-f:指定压缩后的⽂件名<br>-x:解压.tar⽂件<br>压缩 ：tar -zcvf combine.tar.gz 1.txt<br>解压 ：tar -zxvf combine.tar.gz -C java/<br>-C 表示解压到指定⽬录</p>\n<h2 id=\"文本编辑\"><a href=\"#文本编辑\" class=\"headerlink\" title=\"文本编辑\"></a>文本编辑</h2><h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3><p>如果没有vim，需要先安装vim工具</p>\n<h3 id=\"移动光标\"><a href=\"#移动光标\" class=\"headerlink\" title=\"移动光标\"></a>移动光标</h3><p><img src=\"/2020/09/11/Linux/%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87.png\"></p>\n<h3 id=\"搜索替换\"><a href=\"#搜索替换\" class=\"headerlink\" title=\"搜索替换\"></a>搜索替换</h3><p><img src=\"/2020/09/11/Linux/%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2.png\"></p>\n<h3 id=\"删除、复制和粘贴\"><a href=\"#删除、复制和粘贴\" class=\"headerlink\" title=\"删除、复制和粘贴\"></a>删除、复制和粘贴</h3><p><img src=\"/2020/09/11/Linux/%E5%88%A0%E9%99%A4%E5%A4%8D%E5%88%B6%E5%92%8C%E7%B2%98%E8%B4%B4.png\"></p>\n<h3 id=\"编辑模式切换\"><a href=\"#编辑模式切换\" class=\"headerlink\" title=\"编辑模式切换\"></a>编辑模式切换</h3><p><img src=\"/2020/09/11/Linux/%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F.png\"></p>\n<h3 id=\"退出指令\"><a href=\"#退出指令\" class=\"headerlink\" title=\"退出指令\"></a>退出指令</h3><p><img src=\"/2020/09/11/Linux/%E9%80%80%E5%87%BA%E6%8C%87%E4%BB%A4.png\"></p>\n<h1 id=\"用户和用户组管理\"><a href=\"#用户和用户组管理\" class=\"headerlink\" title=\"用户和用户组管理\"></a>用户和用户组管理</h1><ol>\n<li>用户名</li>\n<li>用户所属的组</li>\n<li>用户的家目录</li>\n</ol>\n<h2 id=\"用户名\"><a href=\"#用户名\" class=\"headerlink\" title=\"用户名\"></a>用户名</h2><h3 id=\"添加用户：useradd\"><a href=\"#添加用户：useradd\" class=\"headerlink\" title=\"添加用户：useradd\"></a>添加用户：useradd</h3><p><img src=\"/2020/09/11/Linux/useradd.png\"></p>\n<h3 id=\"删除用户：userdel\"><a href=\"#删除用户：userdel\" class=\"headerlink\" title=\"删除用户：userdel\"></a>删除用户：userdel</h3><p><img src=\"/2020/09/11/Linux/userdel.png\"></p>\n<h3 id=\"修改账号：usermod\"><a href=\"#修改账号：usermod\" class=\"headerlink\" title=\"修改账号：usermod\"></a>修改账号：usermod</h3><p><img src=\"/2020/09/11/Linux/usermod.png\"></p>\n<h3 id=\"密码管理：password\"><a href=\"#密码管理：password\" class=\"headerlink\" title=\"密码管理：password\"></a>密码管理：password</h3><p><img src=\"/2020/09/11/Linux/password.png\"></p>\n<h2 id=\"用户组\"><a href=\"#用户组\" class=\"headerlink\" title=\"用户组\"></a>用户组</h2><h3 id=\"添加用户组：groupadd\"><a href=\"#添加用户组：groupadd\" class=\"headerlink\" title=\"添加用户组：groupadd\"></a>添加用户组：groupadd</h3><p><img src=\"/2020/09/11/Linux/groupadd.png\"></p>\n<h3 id=\"删除用户组：groupdel\"><a href=\"#删除用户组：groupdel\" class=\"headerlink\" title=\"删除用户组：groupdel\"></a>删除用户组：groupdel</h3><p><img src=\"/2020/09/11/Linux/groupdel.png\"></p>\n<h3 id=\"修改用户组：groupmod\"><a href=\"#修改用户组：groupmod\" class=\"headerlink\" title=\"修改用户组：groupmod\"></a>修改用户组：groupmod</h3><p><img src=\"/2020/09/11/Linux/groupmod.png\"></p>\n<h3 id=\"切换用户组（同一个用户）：newgrp\"><a href=\"#切换用户组（同一个用户）：newgrp\" class=\"headerlink\" title=\"切换用户组（同一个用户）：newgrp\"></a>切换用户组（同一个用户）：newgrp</h3><p>newgrp 用户组</p>\n<h2 id=\"与用户有关的系统文件\"><a href=\"#与用户有关的系统文件\" class=\"headerlink\" title=\"与用户有关的系统文件\"></a>与用户有关的系统文件</h2><h3 id=\"etc-passwd文件是用户管理工作涉及的最重要的一个文件。\"><a href=\"#etc-passwd文件是用户管理工作涉及的最重要的一个文件。\" class=\"headerlink\" title=\"/etc/passwd文件是用户管理工作涉及的最重要的一个文件。\"></a>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</h3><p><img src=\"/2020/09/11/Linux/%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E6%96%87%E4%BB%B6.png\"></p>\n<ol>\n<li><p>“用户名”是代表用户账号的字符串。<br>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。<br>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>\n</li>\n<li><p>“口令”一些系统中，存放着加密后的用户口令字。<br>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>\n</li>\n<li><p>“用户标识号”是一个整数，系统内部用它来标识用户。<br>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。<br>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>\n</li>\n<li><p>“组标识号”字段记录的是用户所属的用户组。<br>它对应着/etc/group文件中的一条记录。</p>\n</li>\n<li><p>“注释性描述”字段记录着用户的一些个人情况。<br>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</p>\n</li>\n<li><p>“主目录”，也就是用户的起始工作目录。<br>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>\n</li>\n<li><p>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。<br>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。<br>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。<br>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。<br>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>\n</li>\n<li><p>系统中有一类用户称为伪用户（pseudo users）。<br>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。<br>常见的伪用户如下所示：<br>伪 用 户 含 义<br>bin 拥有可执行的用户命令文件<br>sys 拥有系统文件<br>adm 拥有帐户文件<br>uucp UUCP使用<br>lp lp或lpd子系统使用<br>nobody NFS使用</p>\n</li>\n</ol>\n<h3 id=\"拥有帐户文件\"><a href=\"#拥有帐户文件\" class=\"headerlink\" title=\"拥有帐户文件\"></a>拥有帐户文件</h3><ol>\n<li><p>除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。<br>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>\n</li>\n<li><p>/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生<br>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：<br>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志<br><img src=\"/2020/09/11/Linux/%E8%B4%A6%E6%88%B7%E6%96%87%E4%BB%B6.png\"></p>\n</li>\n</ol>\n<h3 id=\"用户组的所有信息都存放在-etc-group文件中\"><a href=\"#用户组的所有信息都存放在-etc-group文件中\" class=\"headerlink\" title=\"用户组的所有信息都存放在/etc/group文件中\"></a>用户组的所有信息都存放在/etc/group文件中</h3><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。<br>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。<br>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。<br>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。<br>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：<br>组名:口令:组标识号:组内用户列表<br><img src=\"/2020/09/11/Linux/%E7%94%A8%E6%88%B7%E7%BB%84%E7%9A%84%E6%96%87%E4%BB%B6.png\"></p>\n<h2 id=\"批量添加用户\"><a href=\"#批量添加用户\" class=\"headerlink\" title=\"批量添加用户\"></a>批量添加用户</h2><p><a href=\"https://www.runoob.com/linux/linux-user-manage.html\">https://www.runoob.com/linux/linux-user-manage.html</a></p>\n<h1 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h1><h2 id=\"查看权限：ls-l\"><a href=\"#查看权限：ls-l\" class=\"headerlink\" title=\"查看权限：ls -l\"></a>查看权限：ls -l</h2><p>前⾯10个符号表示⽂件的⼀些基本信息。<br>第1位：-表示是⼀个普通的⽂件；d表示是⼀个⽬录；（最常⽤）<br>rwx：Read、Write、Execute，读、写、执⾏权限，这个顺序不会变，如果没有权限的话就⽤-代替<br>第2-4位：表示⽂件所有者的权限<br>第5-7位：⽂件所在组的拥有的权限<br>第8-10位：⽂件其他组⽤户拥有的权限</p>\n<h2 id=\"修改权限：chmod\"><a href=\"#修改权限：chmod\" class=\"headerlink\" title=\"修改权限：chmod\"></a>修改权限：chmod</h2><ol>\n<li>chmod u=rwx,g=rw,o=r filename<br>u:所有者 g:所有组 o:其他组,a代表全部</li>\n<li>chmod 751 filename<br>r = 4, w = 2, x = 1, rwx = 4 + 2 + 1 = 7</li>\n</ol>\n<h1 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h1><h2 id=\"查看进程：ps\"><a href=\"#查看进程：ps\" class=\"headerlink\" title=\"查看进程：ps\"></a>查看进程：ps</h2><p>Linux系统中查看进程使⽤情况的命令是ps指令<br>常⻅选项：<br>-e：显示所有进程<br>-f：全格式<br>a:显示终端上的所有进程<br>u:以⽤户的格式来显示进程信息<br>x:显示后台运⾏的进程<br>⼀般常⽤格式为ps -ef或者ps aux两种。显示的信息⼤体⼀致，略有区别。<br>![](ps -ef.png)<br>![](ps -aux.png)</p>\n<div class=\"note info\">\n            <p>进一步筛选，ps -ef | grep [内容]</p>\n          </div>\n\n<h2 id=\"终止进程：kill\"><a href=\"#终止进程：kill\" class=\"headerlink\" title=\"终止进程：kill\"></a>终止进程：kill</h2><p><img src=\"/2020/09/11/Linux/kill.png\"></p>\n<h2 id=\"服务管理\"><a href=\"#服务管理\" class=\"headerlink\" title=\"服务管理\"></a>服务管理</h2><p><img src=\"/2020/09/11/Linux/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86.png\"></p>\n<h1 id=\"网络管理\"><a href=\"#网络管理\" class=\"headerlink\" title=\"网络管理\"></a>网络管理</h1><h2 id=\"查看网络：ifconfig\"><a href=\"#查看网络：ifconfig\" class=\"headerlink\" title=\"查看网络：ifconfig\"></a>查看网络：ifconfig</h2><h2 id=\"查看端口：netstat\"><a href=\"#查看端口：netstat\" class=\"headerlink\" title=\"查看端口：netstat\"></a>查看端口：netstat</h2><p>netstat<br>-a:显示全部<br>-n:以数字的形式显示<br>-p:显示该连接被哪个应⽤程序占⽤PID<br>eg:<br>netstat -anp | grep 3306</p>\n<div class=\"note info\">\n            <p>或者使用lsof</p>\n          </div>\n\n<h2 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h2><h2 id=\"传递文件\"><a href=\"#传递文件\" class=\"headerlink\" title=\"传递文件\"></a>传递文件</h2><p>rsync<br>rsync [参数] source1 source2 destination</p>\n<h1 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h1><h2 id=\"修改环境变量\"><a href=\"#修改环境变量\" class=\"headerlink\" title=\"修改环境变量\"></a>修改环境变量</h2><h3 id=\"export-PATH\"><a href=\"#export-PATH\" class=\"headerlink\" title=\"export PATH\"></a>export PATH</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">使用export命令直接修改PATH的值，配置MySQL进入环境变量的方法:</span><br><span class=\"line\">export PATH&#x3D;&#x2F;home&#x2F;uusama&#x2F;mysql&#x2F;bin:$PATH</span><br><span class=\"line\"> </span><br><span class=\"line\"># 或者把PATH放在前面</span><br><span class=\"line\">export PATH&#x3D;$PATH:&#x2F;home&#x2F;uusama&#x2F;mysql&#x2F;bin</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>生效时间：立即生效<br>生效期限：当前终端有效，窗口关闭后无效<br>生效范围：仅对当前用户有效<br>配置的环境变量中不要忘了加上原来的配置，即$PATH部分，避免覆盖原来配置</p>\n          </div>\n\n<h3 id=\"vim-bashrc\"><a href=\"#vim-bashrc\" class=\"headerlink\" title=\"vim ~/.bashrc\"></a>vim ~/.bashrc</h3><p>vim ~/.bash_profile<br>在最后一行加上<br>export PATH=$PATH:/home/uusama/mysql/bin</p>\n<div class=\"note info\">\n            <p>生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bash_profile生效<br>生效期限：永久有效<br>生效范围：仅对当前用户有效</p>\n          </div>\n\n<h3 id=\"etc-profile\"><a href=\"#etc-profile\" class=\"headerlink\" title=\"/etc/profile\"></a>/etc/profile</h3><p>vim /etc/profile<br>在最后一行加上<br>export PATH=$PATH:/home/uusama/mysql/bin</p>\n<div class=\"note info\">\n            <p>生效时间：新开终端生效，或者手动source /etc/profile生效<br>生效期限：永久有效<br>生效范围：对所有用户有效</p>\n          </div>\n\n<h3 id=\"vim-etc-environment\"><a href=\"#vim-etc-environment\" class=\"headerlink\" title=\"vim /etc/environment\"></a>vim /etc/environment</h3><p>vim /etc/profile<br>在最后一行加上<br>export PATH=$PATH:/home/uusama/mysql/bin</p>\n<div class=\"note info\">\n            <p>生效时间：新开终端生效，或者手动source /etc/profile生效<br>生效期限：永久有效<br>生效范围：对所有用户有效</p>\n          </div>\n\n<h3 id=\"加载环境变量的顺序\"><a href=\"#加载环境变量的顺序\" class=\"headerlink\" title=\"加载环境变量的顺序\"></a>加载环境变量的顺序</h3><p>/etc/environment<br>/etc/profile<br>/etc/bash.bashrc<br>/etc/profile.d/test.sh<br>~/.profile<br>~/.bashrc</p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"Listener","url":"/2021/04/20/Listener/","content":"<h1 id=\"监听器\"><a href=\"#监听器\" class=\"headerlink\" title=\"监听器\"></a>监听器</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>负责监听对象和做出响应处理。<br>比如Web开发中的监听器，像Context创建的时候读取的一些配置文件。<br>监听对象：ServletContext<br>监听事件：创建和销毁<br>监听者：自己编写的监听器<br>触发事件：监听器里面的方法</p>\n<span id=\"more\"></span>\n\n<h1 id=\"编写Listener\"><a href=\"#编写Listener\" class=\"headerlink\" title=\"编写Listener\"></a>编写Listener</h1><ol>\n<li>编写类实现ServletContextListener</li>\n<li>注册Listener（注解或者Web.xml）</li>\n</ol>\n<p><img src=\"/2021/04/20/Listener/Listener.png\"></p>\n<h2 id=\"如何实现的\"><a href=\"#如何实现的\" class=\"headerlink\" title=\"如何实现的\"></a>如何实现的</h2><p>ServletContext的代码是在tomcat内部，很久之前就写好了的一个接口。实现原理，依靠多态，将自己实现的类注入。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>初始化配置、Spring程序执行的入口。</p>\n","categories":["Web服务器"],"tags":["Web"]},{"title":"Lua","url":"/2022/08/19/Lua/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Lua脚本</p>\n<span id=\"more\"></span>\n<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><h2 id=\"赋值即可声明，默认全局变量\"><a href=\"#赋值即可声明，默认全局变量\" class=\"headerlink\" title=\"赋值即可声明，默认全局变量\"></a>赋值即可声明，默认全局变量</h2><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"local，当前作用域\"><a href=\"#local，当前作用域\" class=\"headerlink\" title=\"local，当前作用域\"></a>local，当前作用域</h2><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"nil，未被声明\"><a href=\"#nil，未被声明\" class=\"headerlink\" title=\"nil，未被声明\"></a>nil，未被声明</h2><h2 id=\"多重赋值\"><a href=\"#多重赋值\" class=\"headerlink\" title=\"多重赋值\"></a>多重赋值</h2><h2 id=\"数值型\"><a href=\"#数值型\" class=\"headerlink\" title=\"数值型\"></a>数值型</h2><p>十六进制<br>科学计数法</p>\n<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><h2 id><a href=\"#\" class=\"headerlink\" title=\"+ - * /\"></a>+ - * /</h2><h2 id=\"幂运算\"><a href=\"#幂运算\" class=\"headerlink\" title=\"幂运算\"></a>幂运算</h2><h2 id=\"移位\"><a href=\"#移位\" class=\"headerlink\" title=\"移位\"></a>移位</h2><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;&lt;</span><br><span class=\"line\">&gt;&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符-字符串\"><a href=\"#字符-字符串\" class=\"headerlink\" title=\"字符/字符串\"></a>字符/字符串</h1><h2 id=\"单引号\"><a href=\"#单引号\" class=\"headerlink\" title=\"单引号\"></a>单引号</h2><h2 id=\"双引号\"><a href=\"#双引号\" class=\"headerlink\" title=\"双引号\"></a>双引号</h2><h2 id=\"中括号\"><a href=\"#中括号\" class=\"headerlink\" title=\"中括号\"></a>中括号</h2><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">[[asdhasdasdj]]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h2><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">c = a..b</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串转换为数字\"><a href=\"#字符串转换为数字\" class=\"headerlink\" title=\"字符串转换为数字\"></a>字符串转换为数字</h2><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">tostring</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\">num = <span class=\"built_in\">tonumber</span>(<span class=\"string\">&quot;10&quot;</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出字符串长度\"><a href=\"#输出字符串长度\" class=\"headerlink\" title=\"输出字符串长度\"></a>输出字符串长度</h2><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">&quot;asdasdasd&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(#a)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">function_name</span><span class=\"params\">(...)</span></span> </span><br><span class=\"line\">    function_body</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Table\"><a href=\"#Table\" class=\"headerlink\" title=\"Table\"></a>Table</h1><p>里面可以放任何东西，按照数组来取(从1开始计数)</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;asdasd&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">end</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert\"></a>insert</h2><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">//在末尾插入</span><br><span class=\"line\"><span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(a, <span class=\"string\">&quot;d&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">//在第二个元素中插入</span><br><span class=\"line\"><span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(a, <span class=\"number\">2</span>, <span class=\"string\">&quot;d&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h2><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">//删掉第四个下标的值</span><br><span class=\"line\"><span class=\"built_in\">table</span>.<span class=\"built_in\">remove</span>(a, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n","tags":["编程语言"]},{"title":"Log4j2","url":"/2022/06/29/Log4j2/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>软件的运行过程中可能出现各式各样的问题，所以日志记录是一个良好的行为。既可以记录下出问题的情况，同时也可以排查出问题，从而提高稳定性。<br>SpringBoot自带有Logback作为日志，但是相比之下，Log4j2是一款性能和颗粒度更高的选择。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h1><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>x.x.x<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"需要排除依赖\"><a href=\"#需要排除依赖\" class=\"headerlink\" title=\"需要排除依赖\"></a>需要排除依赖</h2><p>因为SpringBoot自带Logback，所以需要排除掉</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">exclusions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">exclusion</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-logging<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">exclusion</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">exclusions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><h2 id=\"Loggers\"><a href=\"#Loggers\" class=\"headerlink\" title=\"Loggers\"></a>Loggers</h2><p>Loggers节点，常见的有两种：Root和Logger。</p>\n<h3 id=\"Root\"><a href=\"#Root\" class=\"headerlink\" title=\"Root\"></a>Root</h3><p>每个配置都必须有一个根记录器Root。如果未配置，则将使用默认根LoggerConfig，其级别为ERROR且附加了Console appender。Root节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出。<br>根记录器和其他记录器之间的主要区别是：<br>1.根记录器没有name属性。<br>2.根记录器不支持additivity属性，因为它没有父级。</p>\n<h4 id=\"自身属性\"><a href=\"#自身属性\" class=\"headerlink\" title=\"- 自身属性\"></a>- 自身属性</h4><ol>\n<li>level：决定了Root以最低以什么级别输出，以下的日志全部忽略</li>\n</ol>\n<h4 id=\"Appender-Ref\"><a href=\"#Appender-Ref\" class=\"headerlink\" title=\"- Appender-Ref\"></a>- Appender-Ref</h4><p>AppenderRef：Root的子节点，用来指定该日志输出到哪个Appender.</p>\n<h3 id=\"Logger\"><a href=\"#Logger\" class=\"headerlink\" title=\"Logger\"></a>Logger</h3><h4 id=\"自身属性-1\"><a href=\"#自身属性-1\" class=\"headerlink\" title=\"- 自身属性\"></a>- 自身属性</h4><ol>\n<li>name：用来指定该Logger所适用的类或者类所在的包全路径，继承自Root节点。一般是项目包名或者框架的包名，比如：com.jourwon，org.springframework</li>\n<li>level：日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</li>\n</ol>\n<h4 id=\"AppenderRef\"><a href=\"#AppenderRef\" class=\"headerlink\" title=\"- AppenderRef\"></a>- AppenderRef</h4><p>Logger的子节点，用来指定该日志输出到哪个Appender，如果没有指定，就会默认继承自Root。如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity=”false”只在自定义的Appender中进行输出。</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>配置的方式有多种<br>JavaConfig、Properties、XML，推荐使用XML</p>\n<h2 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--&lt;Configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_HOME&quot;</span>&gt;</span>/Users/tian/Documents/service-logs<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Appenders</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--*********************控制台日志***********************--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Console</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;consoleAppender&quot;</span> <span class=\"attr\">target</span>=<span class=\"string\">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志格式及颜色--&gt;</span></span><br><span class=\"line\">            &lt;PatternLayout</span><br><span class=\"line\">                    pattern=&quot;%style&#123;%d&#123;ISO8601&#125;&#125;&#123;bright,green&#125; %highlight&#123;%-5level&#125; [%style&#123;%t&#125;&#123;bright,blue&#125;] %style&#123;%C&#123;&#125;&#125;&#123;bright,yellow&#125;: %msg%n%style&#123;%throwable&#125;&#123;red&#125;&quot;</span><br><span class=\"line\">                    disableAnsi=&quot;false&quot; noConsoleNoAnsi=&quot;false&quot;/&gt;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">Console</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--*********************文件日志***********************--&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--all级别日志--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">RollingFile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;allFileAppender&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">fileName</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/all.log&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">filePattern</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/$$&#123;date:yyyy-MM&#125;/all-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志格式--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d %p %C&#123;&#125; [%t] %m%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!-- 设置日志文件切分参数 --&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--&lt;OnStartupTriggeringPolicy/&gt;--&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志基础文件大小，超过该大小就触发日志文件滚动更新--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">SizeBasedTriggeringPolicy</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;100 MB&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志文件滚动更新的时间，依赖于文件命名filePattern的设置--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志的文件个数上限，不设置默认为7个，超过大小后会被覆盖；依赖于filePattern中的%i--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">DefaultRolloverStrategy</span> <span class=\"attr\">max</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">RollingFile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--debug级别日志--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">RollingFile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;debugFileAppender&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">fileName</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/debug.log&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">filePattern</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/$$&#123;date:yyyy-MM&#125;/debug-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Filters</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--过滤掉info及更高级别日志--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">ThresholdFilter</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span> <span class=\"attr\">onMatch</span>=<span class=\"string\">&quot;DENY&quot;</span> <span class=\"attr\">onMismatch</span>=<span class=\"string\">&quot;NEUTRAL&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Filters</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志格式--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d %p %C&#123;&#125; [%t] %m%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!-- 设置日志文件切分参数 --&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--&lt;OnStartupTriggeringPolicy/&gt;--&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志基础文件大小，超过该大小就触发日志文件滚动更新--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">SizeBasedTriggeringPolicy</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;100 MB&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志文件滚动更新的时间，依赖于文件命名filePattern的设置--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志的文件个数上限，不设置默认为7个，超过大小后会被覆盖；依赖于filePattern中的%i--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">DefaultRolloverStrategy</span> <span class=\"attr\">max</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">RollingFile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--info级别日志--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">RollingFile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;infoFileAppender&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">fileName</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/info.log&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">filePattern</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Filters</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--过滤掉warn及更高级别日志--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">ThresholdFilter</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;warn&quot;</span> <span class=\"attr\">onMatch</span>=<span class=\"string\">&quot;DENY&quot;</span> <span class=\"attr\">onMismatch</span>=<span class=\"string\">&quot;NEUTRAL&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Filters</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志格式--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d %p %C&#123;&#125; [%t] %m%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!-- 设置日志文件切分参数 --&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--&lt;OnStartupTriggeringPolicy/&gt;--&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志基础文件大小，超过该大小就触发日志文件滚动更新--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">SizeBasedTriggeringPolicy</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;100 MB&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志文件滚动更新的时间，依赖于文件命名filePattern的设置，默认单位是day--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">TimeBasedTriggeringPolicy</span> <span class=\"attr\">interval</span>=<span class=\"string\">&quot;1&quot;</span> <span class=\"attr\">modulate</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志的文件个数上限，不设置默认为7个，超过大小后会被覆盖；依赖于filePattern中的%i--&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--&lt;DefaultRolloverStrategy max=&quot;100&quot;/&gt;--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">RollingFile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--warn级别日志--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">RollingFile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;warnFileAppender&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">fileName</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/warn.log&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">filePattern</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Filters</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--过滤掉error及更高级别日志--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">ThresholdFilter</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;error&quot;</span> <span class=\"attr\">onMatch</span>=<span class=\"string\">&quot;DENY&quot;</span> <span class=\"attr\">onMismatch</span>=<span class=\"string\">&quot;NEUTRAL&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Filters</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志格式--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d %p %C&#123;&#125; [%t] %m%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!-- 设置日志文件切分参数 --&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--&lt;OnStartupTriggeringPolicy/&gt;--&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志基础文件大小，超过该大小就触发日志文件滚动更新--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">SizeBasedTriggeringPolicy</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;100 MB&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志文件滚动更新的时间，依赖于文件命名filePattern的设置--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志的文件个数上限，不设置默认为7个，超过大小后会被覆盖；依赖于filePattern中的%i--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">DefaultRolloverStrategy</span> <span class=\"attr\">max</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">RollingFile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--error及更高级别日志--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">RollingFile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;errorFileAppender&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">fileName</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/error.log&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">filePattern</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志格式--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d %p %C&#123;&#125; [%t] %m%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">PatternLayout</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!-- 设置日志文件切分参数 --&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--&lt;OnStartupTriggeringPolicy/&gt;--&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志基础文件大小，超过该大小就触发日志文件滚动更新--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">SizeBasedTriggeringPolicy</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;100 MB&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--设置日志文件滚动更新的时间，依赖于文件命名filePattern的设置--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--设置日志的文件个数上限，不设置默认为7个，超过大小后会被覆盖；依赖于filePattern中的%i--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">DefaultRolloverStrategy</span> <span class=\"attr\">max</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">RollingFile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--json格式error级别日志--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">RollingFile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;errorJsonAppender&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">fileName</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/error-json.log&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">filePattern</span>=<span class=\"string\">&quot;$&#123;LOG_HOME&#125;/error-json-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">JSONLayout</span> <span class=\"attr\">compact</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">eventEol</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">locationInfo</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">SizeBasedTriggeringPolicy</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;100 MB&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">TimeBasedTriggeringPolicy</span> <span class=\"attr\">interval</span>=<span class=\"string\">&quot;1&quot;</span> <span class=\"attr\">modulate</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">RollingFile</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Appenders</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Loggers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 根日志设置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;debug&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;allFileAppender&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;all&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;consoleAppender&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;debug&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;debugFileAppender&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;debug&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;infoFileAppender&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;warnFileAppender&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;warn&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;errorFileAppender&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;error&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;errorJsonAppender&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;error&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">Root</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--spring日志--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.springframework&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;debug&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--druid数据源日志--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;druid.sql.Statement&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;warn&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- mybatis日志 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.mybatis&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;warn&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;warn&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.zaxxer.hikari&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.quartz&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.andya.demo&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;debug&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Loggers</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n","categories":["框架"],"tags":["Java","日志"]},{"title":"MVC","url":"/2021/04/14/MVC/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>判断一个程序好与坏，一个比较合理的方式是看：需求更改的时候，是否需要改变大量的代码。即各个组件之间的耦合性是否过于过高，过高会带来冗余和维护困难。因此引入MVC模型。</p>\n<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>Model-View-Controller，把一个应用的输入、处理、输出流程按照Model、View、Controller的方式进行分离，这样一个应用被分成三个块，即模型层、视图层、控制层。</p>\n<h2 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h2><p>封装的是数据模型和所有基于对这些数据的操作。在一个组件中，Model往往表示组件的状态和操作状态的方法。</p>\n<div class=\"note info\">\n            <p>Bean和对Bean的操作，作为Model</p>\n          </div>\n\n<h2 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h2><p>封装的是对数据Model的一种显示。一个模型可以由多个视图，而一个视图理论上也可以同不同的模型关联起来。</p>\n<div class=\"note info\">\n            <p>Jsp或者response作为View</p>\n          </div>\n\n<h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h2><p>封装的是外界作用于模型的操作,  通常，这些操作会转发到模型上，并调用模型中相应的一个或者多个方法。一般Controller在Model和View之间起到了沟通的作用，处理用户在View上的输入，并转发给Model。这样Model和View两者之间可以做到松散耦合，甚至可以彼此不知道对方，而由Controller连接起这两个部分。</p>\n<div class=\"note info\">\n            <p>Servlet就是作为一个Controller</p>\n          </div>\n","categories":["框架"],"tags":["MVC"]},{"title":"MapStruct","url":"/2021/11/17/MapStruct/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>对象与对象之间转换的工具</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"导包\"><a href=\"#导包\" class=\"headerlink\" title=\"导包\"></a>导包</h2><h2 id=\"定义目标对象\"><a href=\"#定义目标对象\" class=\"headerlink\" title=\"定义目标对象\"></a>定义目标对象</h2><p>原对象<br>目标对象</p>\n<h2 id=\"定义一个转换接口\"><a href=\"#定义一个转换接口\" class=\"headerlink\" title=\"定义一个转换接口\"></a>定义一个转换接口</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;这个注解会自动生成Bean并注册到Spring中</span><br><span class=\"line\">@Mapper(componentModel &#x3D; &quot;spring&quot;)   写在接口上</span><br><span class=\"line\"></span><br><span class=\"line\">@Mapping(&#123;@Mapping(target &#x3D; &quot;xxx&quot;, source &#x3D; &quot;xxx&quot;), ...&#125;) 写在方法上</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置编译注解处理器\"><a href=\"#配置编译注解处理器\" class=\"headerlink\" title=\"配置编译注解处理器\"></a>配置编译注解处理器</h2><p>maven下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">annotationProcessorPaths</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">&lt;!--mapStruct的注解处理器--&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mapstruct<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mapstruct-processor<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">&lt;!--如果还使用了lombok，要引用对应的lombok注解处理器--&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.18.16.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">annotationProcessorPaths</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"compile编译，生成对应的class文件\"><a href=\"#compile编译，生成对应的class文件\" class=\"headerlink\" title=\"compile编译，生成对应的class文件\"></a>compile编译，生成对应的class文件</h2>","categories":["框架"],"tags":["Spring","Java"]},{"title":"Math","url":"/2020/08/21/Math/","content":"","categories":["Math"]},{"title":"Maven","url":"/2021/04/14/Maven/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源 项目。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。<br>官网：<a href=\"https://maven.apache.org/\">https://maven.apache.org/</a></p>\n<span id=\"more\"></span>\n\n<h1 id=\"项目构建\"><a href=\"#项目构建\" class=\"headerlink\" title=\"项目构建\"></a>项目构建</h1><h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>mvn compile</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>mvn test</p>\n<h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>mvn package</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><h1 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h1><p>将各类依赖的Jar包放在仓库中，需要用的时候，直接从仓库中拿，不用给每一个项目部署一个开发依赖环境，节约空间和提高效率。</p>\n<ol>\n<li>减轻项目大小</li>\n<li>减少冲突（Jar包可能自己也有需要依赖的包，maven会自动一起导入）</li>\n</ol>\n<h2 id=\"坐标\"><a href=\"#坐标\" class=\"headerlink\" title=\"坐标\"></a>坐标</h2><p>GroupID<br>ArtifactID<br>Version</p>\n<h2 id=\"Scope-依赖范围\"><a href=\"#Scope-依赖范围\" class=\"headerlink\" title=\"Scope 依赖范围\"></a>Scope 依赖范围</h2><p><img src=\"/2021/04/14/Maven/Scope.png\"></p>\n<h2 id=\"依赖传递\"><a href=\"#依赖传递\" class=\"headerlink\" title=\"依赖传递\"></a>依赖传递</h2><p>如果一个依赖还要依赖另一个依赖，则会自动导入。</p>\n<div class=\"note info\">\n            <p>不是所有的依赖都可以传递。第二依赖的Scope为Test和Provided时，无法传递。此时如果有需要，手动导入依赖即可。</p>\n          </div>\n<p><img src=\"/2021/04/14/Maven/%E4%BE%9D%E8%B5%96%E4%BC%A0%E9%80%92.png\"></p>\n<h2 id=\"依赖冲突\"><a href=\"#依赖冲突\" class=\"headerlink\" title=\"依赖冲突\"></a>依赖冲突</h2><p>项目两个依赖A、B</p>\n<ol>\n<li>A：依赖C 1.1version</li>\n<li>B：依赖C 1.2version</li>\n</ol>\n<p>此时产生了冲突。Maven有对应的依赖冲突的解决原则。</p>\n<h3 id=\"第一声明者优先原则\"><a href=\"#第一声明者优先原则\" class=\"headerlink\" title=\"第一声明者优先原则\"></a>第一声明者优先原则</h3><p>此时依赖如果先声明A的话，则依赖为C 1.1；反之，则为C 1.2。</p>\n<h3 id=\"短路径优先原则\"><a href=\"#短路径优先原则\" class=\"headerlink\" title=\"短路径优先原则\"></a>短路径优先原则</h3><p>比如A声明依赖C 1.1，但是可以直接声明C为1.2，此时从A-C-1.1路径比C-1.2路径长。优先选择1.2版本。</p>\n<h3 id=\"排除依赖\"><a href=\"#排除依赖\" class=\"headerlink\" title=\"排除依赖\"></a>排除依赖</h3><p>使用exclusion标签把依赖排除出去。</p>\n<h3 id=\"依赖常量（推荐使用，易于版本控制）\"><a href=\"#依赖常量（推荐使用，易于版本控制）\" class=\"headerlink\" title=\"依赖常量（推荐使用，易于版本控制）\"></a>依赖常量（推荐使用，易于版本控制）</h3><p>使用properties标签把依赖的版本设定为常量。</p>\n<h1 id=\"Maven安装\"><a href=\"#Maven安装\" class=\"headerlink\" title=\"Maven安装\"></a>Maven安装</h1><p>压缩包直接解压到盘符根目录就行，然后设置环境变量MAVEN_HOME的path。 </p>\n<div class=\"note info\">\n            <p>目录不要太深，目录不要有中文字符。<br>另外IDEA继承了MAVEN，所以很多时候不需要自己安装。</p>\n          </div>\n\n<h1 id=\"Maven配置\"><a href=\"#Maven配置\" class=\"headerlink\" title=\"Maven配置\"></a>Maven配置</h1><h2 id=\"本地仓库\"><a href=\"#本地仓库\" class=\"headerlink\" title=\"本地仓库\"></a>本地仓库</h2><p>conf/setting.xml里</p>\n<div class=\"note info\">\n            <p>项目会优先在默认仓库里找Jar包，如果没有，则回去网络中央仓库中下载对应Jar包</p>\n          </div>\n\n<h2 id=\"配置国内镜像\"><a href=\"#配置国内镜像\" class=\"headerlink\" title=\"配置国内镜像\"></a>配置国内镜像</h2><p><a href=\"https://maven.aliyun.com/mvn/guide\">https://maven.aliyun.com/mvn/guide</a></p>\n<h2 id=\"IDEA修改Maven配置\"><a href=\"#IDEA修改Maven配置\" class=\"headerlink\" title=\"IDEA修改Maven配置\"></a>IDEA修改Maven配置</h2><h1 id=\"使用Maven\"><a href=\"#使用Maven\" class=\"headerlink\" title=\"使用Maven\"></a>使用Maven</h1><h2 id=\"Pom-xml\"><a href=\"#Pom-xml\" class=\"headerlink\" title=\"Pom.xml\"></a>Pom.xml</h2><p>全称是Project Object Model。</p>\n<h3 id=\"各标签含义\"><a href=\"#各标签含义\" class=\"headerlink\" title=\"各标签含义\"></a>各标签含义</h3><p><a href=\"https://www.runoob.com/maven/maven-pom.html\">https://www.runoob.com/maven/maven-pom.html</a></p>\n<h2 id=\"约定大于配置\"><a href=\"#约定大于配置\" class=\"headerlink\" title=\"约定大于配置\"></a>约定大于配置</h2><p>Java文件必须在src/main/java/<br>配置文件必须在src/main/resources/<br>测试文件必须在src/test/java/<br>测试配置文件必须在src/test/resources/</p>\n<div class=\"note info\">\n            <p>如果没有对应的目录，则不会构建对应的内容</p>\n          </div>\n\n<h2 id=\"构建配置文件\"><a href=\"#构建配置文件\" class=\"headerlink\" title=\"构建配置文件\"></a>构建配置文件</h2><h3 id=\"项目级（pom-xml）\"><a href=\"#项目级（pom-xml）\" class=\"headerlink\" title=\"项目级（pom.xml）\"></a>项目级（pom.xml）</h3><h3 id=\"用户级（定义在Maven的设置xml文件中-USER-HOME-m2-settings-xml-）\"><a href=\"#用户级（定义在Maven的设置xml文件中-USER-HOME-m2-settings-xml-）\" class=\"headerlink\" title=\"用户级（定义在Maven的设置xml文件中 (%USER_HOME%/.m2/settings.xml)）\"></a>用户级（定义在Maven的设置xml文件中 (%USER_HOME%/.m2/settings.xml)）</h3><p>其中 %USER_HOME% 代表用户主目录</p>\n<h3 id=\"全局（定义在-Maven-全局的设置-xml-文件中-M2-HOME-conf-settings-xml-）\"><a href=\"#全局（定义在-Maven-全局的设置-xml-文件中-M2-HOME-conf-settings-xml-）\" class=\"headerlink\" title=\"全局（定义在 Maven 全局的设置 xml 文件中 (%M2_HOME%/conf/settings.xml)）\"></a>全局（定义在 Maven 全局的设置 xml 文件中 (%M2_HOME%/conf/settings.xml)）</h3><p>其中 %M2_HOME% 代表 Maven 的安装目录</p>\n<h2 id=\"Maven生命周期函数\"><a href=\"#Maven生命周期函数\" class=\"headerlink\" title=\"Maven生命周期函数\"></a>Maven生命周期函数</h2><h3 id=\"clean\"><a href=\"#clean\" class=\"headerlink\" title=\"clean\"></a>clean</h3><h3 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h3><p>build包含以下阶段</p>\n<ol>\n<li>validate（验证）</li>\n<li>compile（编译）</li>\n<li>test （测试）</li>\n<li>package （打包）</li>\n<li>verity（检查）</li>\n<li>install（安装）</li>\n<li>deploy（部署）</li>\n</ol>\n<h3 id=\"site\"><a href=\"#site\" class=\"headerlink\" title=\"site\"></a>site</h3><h3 id=\"Maven的各个生命周期函数都是依赖于插件来做的\"><a href=\"#Maven的各个生命周期函数都是依赖于插件来做的\" class=\"headerlink\" title=\"Maven的各个生命周期函数都是依赖于插件来做的\"></a>Maven的各个生命周期函数都是依赖于插件来做的</h3><p><img src=\"/2021/04/14/Maven/%E6%8F%92%E4%BB%B6.png\"></p>\n<h2 id=\"使用IDEA集成Maven创建JavaEE项目\"><a href=\"#使用IDEA集成Maven创建JavaEE项目\" class=\"headerlink\" title=\"使用IDEA集成Maven创建JavaEE项目\"></a>使用IDEA集成Maven创建JavaEE项目</h2><p>最新版IDEA已经可以集成Maven创建。后续使用Spring可以更为方便的配置。</p>\n<h2 id=\"dependencyManagement和dependecy的区别\"><a href=\"#dependencyManagement和dependecy的区别\" class=\"headerlink\" title=\"dependencyManagement和dependecy的区别\"></a>dependencyManagement和dependecy的区别</h2><h2 id=\"packaging的区别\"><a href=\"#packaging的区别\" class=\"headerlink\" title=\"packaging的区别\"></a>packaging的区别</h2><p>1.pom工程：用在父级工程或聚合工程中。用来做jar包的版本控制。</p>\n<p>2.war工程：将会打包成war，发布在服务器上的工程。如网站或服务。</p>\n<p>3.jar工程：将会打包成jar用作jar包使用。</p>\n<h2 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"scope\"></a>scope</h2><p>scope各种取值详解</p>\n<p>scope取值    有效范围（compile, runtime, test）    依赖传递    例子<br>compile    all    是    spring-core<br>provided    compile, test    否    servlet-api<br>runtime    runtime, test    是    JDBC驱动<br>test    test    否    JUnit<br>system    compile, test    是<br>正如上表所示，</p>\n<p>compile ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。</p>\n<p>provided ：在编译、测试时有效，但是在运行时无效。例如：servlet-api，运行项目时，容器已经提供，就不需要Maven重复地引入一遍了。</p>\n<p>runtime ：在运行、测试时有效，但是在编译代码时无效。例如：JDBC驱动实现，项目代码编译只需要JDK提供的JDBC接口，只有在测试或运行项目时才需要实现上述接口的具体JDBC驱动。</p>\n<p>test ：只在测试时有效，例如：JUnit。</p>\n<p>system ：在编译、测试时有效，但是在运行时无效。和provided的区别是，使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量。</p>\n","categories":["框架"],"tags":["依赖管理"]},{"title":"MongoDB","url":"/2021/08/17/MongoDB/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>是一个NoSQL数据库</p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ol>\n<li>对数据库的高并发读写</li>\n<li>对海量数据库的高效率存储和访问</li>\n<li>对数据库的高拓展性和可用性</li>\n</ol>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li>没有事务一致性</li>\n<li>数据库的读写实时性</li>\n<li>复杂查询能力不足</li>\n</ol>\n<h1 id=\"命令操作\"><a href=\"#命令操作\" class=\"headerlink\" title=\"命令操作\"></a>命令操作</h1><h2 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h2><h2 id=\"删\"><a href=\"#删\" class=\"headerlink\" title=\"删\"></a>删</h2><h2 id=\"改\"><a href=\"#改\" class=\"headerlink\" title=\"改\"></a>改</h2><h2 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h2><p>查需要先use对应的数据库</p>\n<h1 id=\"MongoRepository操作\"><a href=\"#MongoRepository操作\" class=\"headerlink\" title=\"MongoRepository操作\"></a>MongoRepository操作</h1><h2 id=\"创建实体对象\"><a href=\"#创建实体对象\" class=\"headerlink\" title=\"创建实体对象\"></a>创建实体对象</h2><p>使用注释标注对应的key和表名</p>\n<h2 id=\"创建MongoDb操作接口\"><a href=\"#创建MongoDb操作接口\" class=\"headerlink\" title=\"创建MongoDb操作接口\"></a>创建MongoDb操作接口</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xxxRepository extends MongoRepository&lt;xxx, [数据类型]&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注册到Spring\"><a href=\"#注册到Spring\" class=\"headerlink\" title=\"注册到Spring\"></a>注册到Spring</h2><h2 id=\"使用Repository的集成CRUD方法\"><a href=\"#使用Repository的集成CRUD方法\" class=\"headerlink\" title=\"使用Repository的集成CRUD方法\"></a>使用Repository的集成CRUD方法</h2><h2 id=\"按照JPA规范写CRUD接口\"><a href=\"#按照JPA规范写CRUD接口\" class=\"headerlink\" title=\"按照JPA规范写CRUD接口\"></a>按照JPA规范写CRUD接口</h2>","categories":["数据库"],"tags":["NoSQL"]},{"title":"Mybatis-Plus","url":"/2021/07/30/Mybatis-Plus/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><h2 id=\"pojo\"><a href=\"#pojo\" class=\"headerlink\" title=\"pojo\"></a>pojo</h2><h2 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h2><p>mysql和pojo的属性对应，pojo驼峰命名在mysql中以下划线<code>_</code>分割大小写</p>\n<h2 id=\"mapper\"><a href=\"#mapper\" class=\"headerlink\" title=\"mapper\"></a>mapper</h2><p>创建对应mapper接口，继承BaseMapper（注意指定范型）</p>\n<h2 id=\"日志输出\"><a href=\"#日志输出\" class=\"headerlink\" title=\"日志输出\"></a>日志输出</h2><p>properties或者yml中:<br>mybatis-plus.configuration.log-impl: xxx</p>\n<h1 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h1><h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p>insert(POJO)  BaseMapper<br>save(POJO) IService</p>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><p>updateById(POJO)</p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><h3 id=\"单个删除\"><a href=\"#单个删除\" class=\"headerlink\" title=\"单个删除\"></a>单个删除</h3><p>deleteById(Id)</p>\n<h3 id=\"批量删除\"><a href=\"#批量删除\" class=\"headerlink\" title=\"批量删除\"></a>批量删除</h3><p>deleteBatchIds(Arrays.asList(1,2,3))</p>\n<h3 id=\"Map条件删除\"><a href=\"#Map条件删除\" class=\"headerlink\" title=\"Map条件删除\"></a>Map条件删除</h3><p>deleteByMap(map)</p>\n<h3 id=\"逻辑删除\"><a href=\"#逻辑删除\" class=\"headerlink\" title=\"逻辑删除\"></a>逻辑删除</h3><p>表中添加deleted字段，POJO属性中同样，并使用注解@TableLogic<br>0为存在，1为删除<br>最好配置上自动填充。<br>deletedById(Id)</p>\n<h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><h3 id=\"动态批量查询\"><a href=\"#动态批量查询\" class=\"headerlink\" title=\"动态批量查询\"></a>动态批量查询</h3><p>比如按照id为1,2,3来批量查询：userMapper.selectBatchIds(Arrays.asList(1,2,3))</p>\n<h3 id=\"Map条件查询\"><a href=\"#Map条件查询\" class=\"headerlink\" title=\"Map条件查询\"></a>Map条件查询</h3><p>map.put(“name”, “tian”);<br>userMapper.selectByMap(map);</p>\n<h3 id=\"分页查询\"><a href=\"#分页查询\" class=\"headerlink\" title=\"分页查询\"></a>分页查询</h3><p>配置类中注册分页插件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"meta\">@MapperScan(&quot;com.example.myhospitalplatform.mapper&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisPlusConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//自动填充组件</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MybatisPlusInterceptor <span class=\"title\">mybatisPlusInterceptor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  MybatisPlusInterceptor mybatisPlusInterceptor = <span class=\"keyword\">new</span> MybatisPlusInterceptor();</span><br><span class=\"line\">  mybatisPlusInterceptor.addInnerInterceptor(<span class=\"keyword\">new</span> OptimisticLockerInnerInterceptor());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> mybatisPlusInterceptor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//分页组件</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaginationInnerInterceptor <span class=\"title\">paginationInnerInterceptor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PaginationInnerInterceptor();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用插件中的Page对象来获取（参数：当前页，每页记录数）</p>\n<ol>\n<li>selectPage(page, null);<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page&lt;User&gt; page = <span class=\"keyword\">new</span> Page(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">Page&lt;User&gt; userPage = userMapper.selectPage(page, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">long</span> pages = userPage.getPages();<span class=\"comment\">//总页数</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> current = userPage.getCurrent();<span class=\"comment\">//当前页</span></span><br><span class=\"line\">List&lt;User&gt; records = userPage.getRecords();<span class=\"comment\">//查询数据集合</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> total = userPage.getTotal();<span class=\"comment\">//总记录数</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> hasNext = userPage.hasNext();<span class=\"comment\">//是否有下一个</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> hasPrevious = userPage.hasPrevious();<span class=\"comment\">//是否有上一个</span></span><br></pre></td></tr></table></figure></li>\n<li>selectMapsPage(page, null)</li>\n</ol>\n<h3 id=\"wrapper\"><a href=\"#wrapper\" class=\"headerlink\" title=\"wrapper\"></a>wrapper</h3><p>条件构造器</p>\n<h4 id=\"大小比较\"><a href=\"#大小比较\" class=\"headerlink\" title=\"大小比较\"></a>大小比较</h4><ol>\n<li>lt</li>\n<li>gt</li>\n<li>le</li>\n<li>ge</li>\n</ol>\n<h4 id=\"相等比较\"><a href=\"#相等比较\" class=\"headerlink\" title=\"相等比较\"></a>相等比较</h4><ol>\n<li>eq</li>\n<li>ne</li>\n</ol>\n<h4 id=\"空比较\"><a href=\"#空比较\" class=\"headerlink\" title=\"空比较\"></a>空比较</h4><ol>\n<li>isNull</li>\n<li>isNotNull</li>\n</ol>\n<h4 id=\"区间比较\"><a href=\"#区间比较\" class=\"headerlink\" title=\"区间比较\"></a>区间比较</h4><ol>\n<li>between</li>\n<li>notBetween</li>\n</ol>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><ol>\n<li>orderBy</li>\n<li>orderByDesc</li>\n<li>orderByAsc</li>\n</ol>\n<h4 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h4><ol>\n<li>like</li>\n<li>notLike</li>\n<li>likeLeft</li>\n<li>likeRight</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">QueryWrapper&lt;User&gt; queryWrapper  = <span class=\"keyword\">new</span> QueryWrapper&lt;&gt;();</span><br><span class=\"line\">queryWrapper.ge(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h1><h2 id=\"主键策略（雪花算法）\"><a href=\"#主键策略（雪花算法）\" class=\"headerlink\" title=\"主键策略（雪花算法）\"></a>主键策略（雪花算法）</h2><p>POJO的属性上<br>@TableId(type=IdType.ASSIGN_ID)</p>\n<ol>\n<li>ASSIGN 生成19位id</li>\n<li>生成UUID</li>\n<li>AUTO 自增长</li>\n<li>INPUT 自己放入</li>\n</ol>\n<div class=\"note info\">\n            <p>雪花算法：分布式ID算法<br>0 符号位<br>1-42 时间戳<br>43-52 工作进程<br>53-64 序列号</p>\n          </div>\n\n<h2 id=\"全局主键配置\"><a href=\"#全局主键配置\" class=\"headerlink\" title=\"全局主键配置\"></a>全局主键配置</h2><p>另外可以设置全局主键配置</p>\n<h2 id=\"自动填充\"><a href=\"#自动填充\" class=\"headerlink\" title=\"自动填充\"></a>自动填充</h2><ol>\n<li>在Pojo中的属性使用@TableFiled(xxx, fill = ….)注解<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Date createTime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@TableField(value = &quot;update_time&quot;, fill = FieldFill.INSERT_UPDATE)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Date updateTime;</span><br></pre></td></tr></table></figure></li>\n<li>创建类实现MetaObjectHandler接口，重写insert和update操作</li>\n<li>用@component注册到组建里<br>在执行相应操作的时候，会自动填充对应内容<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMetaObjectHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">MetaObjectHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertFill</span><span class=\"params\">(MetaObject metaObject)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setFieldValByName(<span class=\"string\">&quot;createDate&quot;</span>, LocalDateTime.now(), metaObject);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setFieldValByName(<span class=\"string\">&quot;updateDate&quot;</span>, LocalDateTime.now(), metaObject);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setFieldValByName(<span class=\"string\">&quot;version&quot;</span>, <span class=\"number\">1</span>, metaObject);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setFieldValByName(<span class=\"string\">&quot;deleted&quot;</span>, <span class=\"number\">0</span>, metaObject);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateFill</span><span class=\"params\">(MetaObject metaObject)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setFieldValByName(<span class=\"string\">&quot;updateDate&quot;</span>, LocalDateTime.now(), metaObject);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h1><h2 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h2>防止并发操作，出现丢失更新情况。<br>采用版本号，对照版本号执行操作</li>\n<li>版本号一样，提交，版本号改变</li>\n<li>版本号不同，回滚</li>\n</ol>\n<div class=\"note info\">\n            <p>如何保证版本号是不会出更新问题？<br>使用volatile修饰，保证一致性。</p>\n          </div>\n\n<h2 id=\"使用乐观锁\"><a href=\"#使用乐观锁\" class=\"headerlink\" title=\"使用乐观锁\"></a>使用乐观锁</h2><ol>\n<li>表字段中添加version字段，并在pojo中添加对应属性，使用@version注解</li>\n<li>创建配置类MybatisPlusConfig，启用事务注解（@EnableTransactionManagement），启用mapper扫描（@MapperScan），此时可以删除启动类的MapperScan</li>\n<li>注册乐观锁MybatisPlusInterceptor<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3.4.0新版</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MybatisPlusInterceptor <span class=\"title\">mybatisPlusInterceptor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  MybatisPlusInterceptor mybatisPlusInterceptor = <span class=\"keyword\">new</span> MybatisPlusInterceptor();</span><br><span class=\"line\">  mybatisPlusInterceptor.addInnerInterceptor(<span class=\"keyword\">new</span> OptimisticLockerInnerInterceptor());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> mybatisPlusInterceptor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"mapper的xml如果在resources下\"><a href=\"#mapper的xml如果在resources下\" class=\"headerlink\" title=\"mapper的xml如果在resources下\"></a>mapper的xml如果在resources下</h2><p>要在配置文件（yml）中添加mapper-locations</p>\n","categories":["框架"],"tags":["Java","MySQL"]},{"title":"Mybatis-Plus使用Log4j2输出日志","url":"/2022/06/30/Mybatis-Plus%E4%BD%BF%E7%94%A8Log4j2%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97/","content":"","categories":["框架"],"tags":["Java","MySQL"]},{"title":"Mybatis","url":"/2020/08/26/Mybatis/","content":"<p>ibatis ORM框架 Object对象 Relationship关系 Mapping映射</p>\n<p>介绍：因为原始JDBC的操作代码有很多弊端，因而诞生了MyBatis<br><img src=\"/2020/08/26/Mybatis/JDBC%E7%9A%84%E5%BC%8A%E7%AB%AF.png\"><br><img src=\"/2020/08/26/Mybatis/Mybatis%E7%AE%80%E4%BB%8B.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"开发步骤\"><a href=\"#开发步骤\" class=\"headerlink\" title=\"开发步骤\"></a>开发步骤</h1><ol>\n<li>导入Mybatis包</li>\n<li>创建数据表</li>\n<li>创建数据表对应的实体类（实体的成员变量名要和数据表内的一样）</li>\n<li>编写映射文件xxxMapper.xml（一般映射xml和实体在一个位置）</li>\n<li>编写核心配置文件SqlMapConfig.xml</li>\n<li>编写测试类</li>\n</ol>\n<p><img src=\"/2020/08/26/Mybatis/Mapper%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE.png\"><br><img src=\"/2020/08/26/Mybatis/Mybatis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE.png\"><br><img src=\"/2020/08/26/Mybatis/MybatisTest.png\"></p>\n<h1 id=\"映射文件\"><a href=\"#映射文件\" class=\"headerlink\" title=\"映射文件\"></a>映射文件</h1><p><img src=\"/2020/08/26/Mybatis/%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0.png\"></p>\n<h1 id=\"核心配置文件\"><a href=\"#核心配置文件\" class=\"headerlink\" title=\"核心配置文件\"></a>核心配置文件</h1><p><img src=\"/2020/08/26/Mybatis/Mybatis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png\"></p>\n<h2 id=\"environment\"><a href=\"#environment\" class=\"headerlink\" title=\"environment\"></a>environment</h2><ol>\n<li>transactionManager</li>\n<li>dataSource</li>\n</ol>\n<p><img src=\"/2020/08/26/Mybatis/environments.png\"></p>\n<h2 id=\"mapper\"><a href=\"#mapper\" class=\"headerlink\" title=\"mapper\"></a>mapper</h2><p><img src=\"/2020/08/26/Mybatis/mapper.png\"></p>\n<h2 id=\"properties\"><a href=\"#properties\" class=\"headerlink\" title=\"properties\"></a>properties</h2><p><img src=\"/2020/08/26/Mybatis/properties.png\"></p>\n<h2 id=\"typeAliases\"><a href=\"#typeAliases\" class=\"headerlink\" title=\"typeAliases\"></a>typeAliases</h2><p><img src=\"/2020/08/26/Mybatis/typeAliases.png\"></p>\n<h1 id=\"Mybatis实现增删改查\"><a href=\"#Mybatis实现增删改查\" class=\"headerlink\" title=\"Mybatis实现增删改查\"></a>Mybatis实现增删改查</h1><h2 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h2><p><img src=\"/2020/08/26/Mybatis/insert.png\"><br><img src=\"/2020/08/26/Mybatis/insert2.png\"></p>\n<div class=\"note info\">\n            <p>insert 插入操作默认是不提交事务，需要写sqlSession.commit()，来提交事务。<br>keyProperty=”id”和 useGeneratedKeys=”true” 可以修改主键的属性。</p>\n          </div>\n\n<h2 id=\"删\"><a href=\"#删\" class=\"headerlink\" title=\"删\"></a>删</h2><p><img src=\"/2020/08/26/Mybatis/delete.png\"><br><img src=\"/2020/08/26/Mybatis/delete2.png\"></p>\n<div class=\"note info\">\n            <p>delete 如果有多个参数来确定，可以用Bean</p>\n          </div>\n\n<h2 id=\"改\"><a href=\"#改\" class=\"headerlink\" title=\"改\"></a>改</h2><p><img src=\"/2020/08/26/Mybatis/update.png\"><br><img src=\"/2020/08/26/Mybatis/update2.png\"></p>\n<h2 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h2><p><img src=\"/2020/08/26/Mybatis/select.png\"><br><img src=\"/2020/08/26/Mybatis/select2.png\"></p>\n<p><img src=\"/2020/08/26/Mybatis/%E6%8F%92%E5%85%A5%E7%BB%86%E8%8A%82.png\"></p>\n<h1 id=\"Mybatis相应API\"><a href=\"#Mybatis相应API\" class=\"headerlink\" title=\"Mybatis相应API\"></a>Mybatis相应API</h1><h2 id=\"SqlSessionFactoryBuilder\"><a href=\"#SqlSessionFactoryBuilder\" class=\"headerlink\" title=\"SqlSessionFactoryBuilder\"></a>SqlSessionFactoryBuilder</h2><p><img src=\"/2020/08/26/Mybatis/SqlSessionFactoryBuilder.png\"></p>\n<ol>\n<li>openSession()<br>默认开启一个事务，但是事务不会提交，需要手动提交</li>\n<li>openSession(boolean autoCommit)<br>默认开启事务，自动提交事务</li>\n</ol>\n<h2 id=\"SqlSession\"><a href=\"#SqlSession\" class=\"headerlink\" title=\"SqlSession\"></a>SqlSession</h2><p><img src=\"/2020/08/26/Mybatis/SqlSession.png\"></p>\n<h1 id=\"MyBatis实现Dao层\"><a href=\"#MyBatis实现Dao层\" class=\"headerlink\" title=\"MyBatis实现Dao层\"></a>MyBatis实现Dao层</h1><h2 id=\"手写\"><a href=\"#手写\" class=\"headerlink\" title=\"手写\"></a>手写</h2><ol>\n<li>写一个对应的Mapper接口</li>\n<li>写一个Mapper的实现（里面写SqlSession和执行对应的操作方法）</li>\n<li>写一个Service接口</li>\n<li>写一个Service的实现（实例化Mapper成员，来操作）<div class=\"note info\">\n            <p>Mapper接口和实现是底层操作，Service接口和实现是上层调用。</p>\n          </div>\n\n</li>\n</ol>\n<h2 id=\"接口代理方式（最为常用）\"><a href=\"#接口代理方式（最为常用）\" class=\"headerlink\" title=\"接口代理方式（最为常用）\"></a>接口代理方式（最为常用）</h2><p><img src=\"/2020/08/26/Mybatis/%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91.png\"><br><img src=\"/2020/08/26/Mybatis/%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%912.png\"></p>\n<div class=\"note info\">\n            <p>实际就是写一个Mapper接口，然后写一个Mapper.xml里配置上对应的操作映射关系。操作时由MyBatis来负责Mapper.class的创建，然后使用Mapper实体进行操作。</p>\n          </div>\n\n<h1 id=\"高级映射\"><a href=\"#高级映射\" class=\"headerlink\" title=\"高级映射\"></a>高级映射</h1><p>使用#{xxx}</p>\n<h2 id=\"输入映射\"><a href=\"#输入映射\" class=\"headerlink\" title=\"输入映射\"></a>输入映射</h2><h3 id=\"单个参数\"><a href=\"#单个参数\" class=\"headerlink\" title=\"单个参数\"></a>单个参数</h3><ol>\n<li>基本数据类型、包装类、字符串<br>xxx任意，因为只传入了一个参数。</li>\n<li>POJO或Map（比如HashMap）<br>xxx使用成员变量名，或者Map的key就行。</li>\n</ol>\n<div class=\"note info\">\n            <p>获取参数的底层使用的是get方法。</p>\n          </div>\n<h3 id=\"多个参数\"><a href=\"#多个参数\" class=\"headerlink\" title=\"多个参数\"></a>多个参数</h3><ol>\n<li>基本数据类型、包装类、字符串<br>使用param或arg</li>\n<li>POJO或Map（比如HashMap）<br>使用param或arg，后面写出成员变量名或Map的key<br><img src=\"/2020/08/26/Mybatis/%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B02.png\"></li>\n</ol>\n<h4 id=\"使用-Param注解（重要）\"><a href=\"#使用-Param注解（重要）\" class=\"headerlink\" title=\"使用@Param注解（重要）\"></a>使用@Param注解（重要）</h4><p>在Mapper接口的方法形参上面。名字就对应在#{xxx}里面。不需要考虑参数类型<br><img src=\"/2020/08/26/Mybatis/@Param.png\"></p>\n<div class=\"note info\">\n            <p>Map的@Param只是Map的名字，对应参数，还是需要使用#{map.key}来获取。</p>\n          </div>\n\n<div class=\"note info\">\n            <p>param从1下标开始，arg从0下标开始。<br><img src=\"/2020/08/26/Mybatis/%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0.png\"></p>\n          </div>\n\n<h2 id=\"输出映射\"><a href=\"#输出映射\" class=\"headerlink\" title=\"输出映射\"></a>输出映射</h2><h3 id=\"基本数据类型、包装类、字符串或者它们的数组List\"><a href=\"#基本数据类型、包装类、字符串或者它们的数组List\" class=\"headerlink\" title=\"基本数据类型、包装类、字符串或者它们的数组List\"></a>基本数据类型、包装类、字符串或者它们的数组List</h3><ol>\n<li>Mapper接口的返回类型写为对应的类型即可。比如int，string（这些都是MyBatis定义好的别名）。</li>\n<li>如果要返回数组，Mapper写法不变，返回值的接收用数组或List都行。（int[]或者List尖括号Integer尖括号）</li>\n</ol>\n<h3 id=\"JavaBean及其数组List\"><a href=\"#JavaBean及其数组List\" class=\"headerlink\" title=\"JavaBean及其数组List\"></a>JavaBean及其数组List</h3><ol>\n<li>要返回POJO，查询结果的列名和JavaBean的成员变量对应。如果有出现不对应的情况，要用as 来修改别名，使它们对应。</li>\n<li>要返回POJO的数组，Mapper写法不变，返回值的接收用数组或List都行。（int[]或者List尖括号Integer尖括号）</li>\n</ol>\n<h3 id=\"resultMap\"><a href=\"#resultMap\" class=\"headerlink\" title=\"resultMap\"></a>resultMap</h3><ol>\n<li>resultType：查询结果的列名和JavaBean<strong>一致</strong></li>\n<li>resultMap：查询结果的列名和JavaBean<strong>对应</strong></li>\n</ol>\n<div class=\"note info\">\n            <p>TypeHandler和多表查询需要用到resultMap</p>\n          </div>\n\n<h4 id=\"先定义个resultMap：要配置column（数据表的列名）和property（POJO成员变量名），type写POJO全类名（或别名）\"><a href=\"#先定义个resultMap：要配置column（数据表的列名）和property（POJO成员变量名），type写POJO全类名（或别名）\" class=\"headerlink\" title=\"先定义个resultMap：要配置column（数据表的列名）和property（POJO成员变量名），type写POJO全类名（或别名）\"></a>先定义个resultMap：要配置column（数据表的列名）和property（POJO成员变量名），type写<strong>POJO</strong>全类名（或别名）</h4><p><img src=\"/2020/08/26/Mybatis/resultMap.png\"></p>\n<h4 id=\"然后select标签，resultMap，选择该map即可。\"><a href=\"#然后select标签，resultMap，选择该map即可。\" class=\"headerlink\" title=\"然后select标签，resultMap，选择该map即可。\"></a>然后select标签，resultMap，选择该map即可。</h4><p><img src=\"/2020/08/26/Mybatis/selectResultMap.png\"></p>\n<h1 id=\"动态SQL语句标签\"><a href=\"#动态SQL语句标签\" class=\"headerlink\" title=\"动态SQL语句标签\"></a>动态SQL语句标签</h1><h2 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;if test&#x3D;&quot;[变量][判断符][数值]&quot;&gt;</span><br><span class=\"line\">\txxxxx</span><br><span class=\"line\">&lt;&#x2F;if&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <ol><li>变量：@param的值</li><li>判断符：<br>1）gt(大于)<br>2）lt(小于)<br>3） ==<br>4）!=<br>5）gt xx and == xx(大于等于)<br>6）lt xx and == xx(小于等于)</li><li>常量：基本数据类型的数值，直接写；字符串，要用单引号括起</li><li>连接词：and、or</li><li>没有对应的else</li></ol>\n          </div>\n\n<div class=\"note info\">\n            <p>xml中，大于为&amp;gt，小于为&amp;lt，大于等于是&gt; =</p>\n          </div>\n<h2 id=\"where\"><a href=\"#where\" class=\"headerlink\" title=\"where\"></a>where</h2><p>会自动屏蔽后面第一个碰到的AND单词，从而完成拼接第一重sql语句</p>\n<h2 id=\"choose-when-otherwise\"><a href=\"#choose-when-otherwise\" class=\"headerlink\" title=\"choose-when-otherwise\"></a>choose-when-otherwise</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;choose&gt;</span><br><span class=\"line\">  &lt;when test&#x3D;&quot;xxxx&quot;&gt;</span><br><span class=\"line\">    xxxx</span><br><span class=\"line\">  &lt;&#x2F;when&gt;</span><br><span class=\"line\">  &lt;otherwise&gt;</span><br><span class=\"line\">    xxxx</span><br><span class=\"line\">  &lt;&#x2F;otherwise&gt;</span><br><span class=\"line\">&lt;&#x2F;choose&gt;</span><br></pre></td></tr></table></figure>\n<p>when条件满足，执行when，不满足，则执行otherwise的内容</p>\n<h2 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\"trim\"></a>trim</h2><p>裁剪部分不必要的内容</p>\n<ol>\n<li>prefixOverrides：去除最前面的指定内容</li>\n<li>suffixOverrides：去除最后面的指定内容</li>\n<li>prefix：添加指定内容在最前面</li>\n<li>suffix：添加指定内容在最后面</li>\n</ol>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><p>针对update操作，会自动去除最后面的逗号（，）。相当于特殊的trim</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;set&gt;</span><br><span class=\"line\">  xxx</span><br><span class=\"line\">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"sql-include\"><a href=\"#sql-include\" class=\"headerlink\" title=\"sql-include\"></a>sql-include</h2><p>先用sql标签定义一个sql片段<br>另外其他的部分可以用include标签引用sql标签的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;sql id&#x3D;&quot;123&quot;&gt;</span><br><span class=\"line\">  xxx</span><br><span class=\"line\">&lt;&#x2F;sql&gt;</span><br><span class=\"line\">&lt;select&gt;</span><br><span class=\"line\">  &lt;include refid&#x3D;&quot;123&quot;&#x2F;&gt;</span><br><span class=\"line\">  xxx</span><br><span class=\"line\">&lt;&#x2F;select&gt;  </span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>其他标签也可以放到sql标签内。<br>另外建议把列相关操作放到sql标签内</p>\n          </div>\n<h2 id=\"selectKey\"><a href=\"#selectKey\" class=\"headerlink\" title=\"selectKey\"></a>selectKey</h2><p>一般用于insert操作，将查询结果封装给<strong>输入映射</strong>传入的值，用于插入前的初值初始化。<br>也可以用用于随机生成某个值的场景，比如插入UUID。</p>\n<ol>\n<li>order：相对于insert执行，先还是后（BEFORE/AFTER）</li>\n<li>keyColumn：查询结果的列名</li>\n<li>keyProperty：查询结果赋值给谁，通常是@param的值</li>\n<li>resultType：keyProperty的类型</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;selectKey order&#x3D;&quot;AFTER&quot; keyColumn&#x3D;&quot;increasedId&quot; keyProperty&#x3D;&quot;user.id&quot; resultType&#x3D;&quot;int&quot;&gt;</span><br><span class=\"line\">  select LAST_INSERT_ID() as increasedId</span><br><span class=\"line\">&lt;&#x2F;selectKey&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert\"></a>insert</h2><p>用于插入。另外一下两个可选参数：下面1用于开启自增key，2是表明哪个key是自增的。（只能用于可以自增的数据库。）</p>\n<ol>\n<li>userGeneratedKeys=”true”</li>\n<li>keyProperty=“xxx”</li>\n</ol>\n<h2 id=\"foreach\"><a href=\"#foreach\" class=\"headerlink\" title=\"foreach\"></a>foreach</h2><p>可用于遍历操作，遍历查询或遍历插入（查询多条记录，插入多条记录）。<br><img src=\"/2020/08/26/Mybatis/foreach.png\"></p>\n<ol>\n<li>collection：array/list，或者对应@param里的值</li>\n<li>item：对应便利的参数值</li>\n<li>separator：添加的分隔符 </li>\n<li>open</li>\n<li>cloase</li>\n</ol>\n<div class=\"note info\">\n            <p>插入多个记录，insert和foreach配合。insert标签上这么写，可以获得每条的自增组件。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;insert useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;users.id&quot;&gt;</span><br><span class=\"line\">  xxxx</span><br><span class=\"line\">  &lt;foreach collection&#x3D;&quot;users&quot; item&#x3D;&quot;user&quot; separator&#x3D;&quot;,&quot;&gt;</span><br><span class=\"line\">    xxxx</span><br><span class=\"line\">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>\n          </div>\n\n<h1 id=\"多表查询\"><a href=\"#多表查询\" class=\"headerlink\" title=\"多表查询\"></a>多表查询</h1><h2 id=\"一对一\"><a href=\"#一对一\" class=\"headerlink\" title=\"一对一\"></a>一对一</h2><h3 id=\"数据库表的维护\"><a href=\"#数据库表的维护\" class=\"headerlink\" title=\"数据库表的维护\"></a>数据库表的维护</h3><p>在一张表中维护另外一张表的唯一字段。</p>\n<h3 id=\"POJO的维护\"><a href=\"#POJO的维护\" class=\"headerlink\" title=\"POJO的维护\"></a>POJO的维护</h3><p>在一个POJO中包含另外一张表POJO的成员变量。</p>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><h4 id=\"分次查询\"><a href=\"#分次查询\" class=\"headerlink\" title=\"分次查询\"></a>分次查询</h4><ol>\n<li>先分别写两次查询的select标签</li>\n<li>使用association标签<br>1）property：对应的是另外一张表的POJO成员变量名<br>2）column：是第二次查询的列名<br>3）select：命名空间+id，对应第二次查询的操作id</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;association property&#x3D;&quot;userDetail&quot; columb&#x3D;&quot;id&quot; select&#x3D;&quot;xx.xx.xx.xx&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/08/26/Mybatis/%E5%A4%9A%E6%AC%A1%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%89.png\"></p>\n<h4 id=\"连接查询\"><a href=\"#连接查询\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h4><p>select标签内sql的写法通常用的是左连接查询，使用resultMap，和association。<br>1）property：对应的是另外一张表的POJO成员变量名<br>2）javaType：POJO的全类名<br>3）javaType内部再封装，相同column名要用别名来区分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;association property&#x3D;&quot;userDetail&quot; javaType&#x3D;&quot;com.example.pojo.userDetail&quot;&gt;</span><br><span class=\"line\">  &lt;result property&#x3D;&quot;id&quot; column&#x3D;&quot;uid&quot;&#x2F;&gt;</span><br><span class=\"line\">  xxx</span><br><span class=\"line\">  xxx</span><br><span class=\"line\">&lt;&#x2F;association&gt;  </span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/08/26/Mybatis/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%89.png\"></p>\n<h2 id=\"一对多\"><a href=\"#一对多\" class=\"headerlink\" title=\"一对多\"></a>一对多</h2><p>一个表，对应了多种的表（相同或不同）</p>\n<h3 id=\"数据库表的维护-1\"><a href=\"#数据库表的维护-1\" class=\"headerlink\" title=\"数据库表的维护\"></a>数据库表的维护</h3><p>多个表中同时维护了一个统一的字段（一般是主键）。</p>\n<h3 id=\"POJO的维护-1\"><a href=\"#POJO的维护-1\" class=\"headerlink\" title=\"POJO的维护\"></a>POJO的维护</h3><p>在一个POJO中维护<strong>另一个类的List</strong>（多）</p>\n<h3 id=\"操作-1\"><a href=\"#操作-1\" class=\"headerlink\" title=\"操作\"></a>操作</h3><h4 id=\"分次查询-1\"><a href=\"#分次查询-1\" class=\"headerlink\" title=\"分次查询\"></a>分次查询</h4><p>使用collection、property、column和select标签，将第二次查询得到的内容，依次封装为list。<br>column为两者统一的列，为第二次查询的列，同时也为select提供参数。<br>外层为一个POJO，内部自定义POJO的内容，查询内容为第二个select的内容。<br><img src=\"/2020/08/26/Mybatis/%E5%A4%9A%E6%AC%A1%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%89.png\"></p>\n<h4 id=\"连接查询-1\"><a href=\"#连接查询-1\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h4><p>使用collection、property、ofType、result标签。<br>ofType是内部POJO的类<br>result内部标注POJO的成员变量名（property）和列（column）的关系<br><img src=\"/2020/08/26/Mybatis/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%89.png\"></p>\n<div class=\"note info\">\n            <p>因为一对一，只会得出一个内容；而一对多，会产生多个内容，用collection可以将他们作为数组或者其他集合。</p>\n          </div>\n<h2 id=\"多对多\"><a href=\"#多对多\" class=\"headerlink\" title=\"多对多\"></a>多对多</h2><h3 id=\"数据库表的维护-2\"><a href=\"#数据库表的维护-2\" class=\"headerlink\" title=\"数据库表的维护\"></a>数据库表的维护</h3><p>使用中间表来维护<br><img src=\"/2020/08/26/Mybatis/%E4%B8%AD%E9%97%B4%E8%A1%A8.png\"></p>\n<h3 id=\"POJO的维护-2\"><a href=\"#POJO的维护-2\" class=\"headerlink\" title=\"POJO的维护\"></a>POJO的维护</h3><p>POJO之间各自维护对方的List<br><img src=\"/2020/08/26/Mybatis/POJO%E5%A4%9A%E5%AF%B9%E5%A4%9A.png\"></p>\n<h3 id=\"操作-2\"><a href=\"#操作-2\" class=\"headerlink\" title=\"操作\"></a>操作</h3><h4 id=\"分次查询-2\"><a href=\"#分次查询-2\" class=\"headerlink\" title=\"分次查询\"></a>分次查询</h4><p><img src=\"/2020/08/26/Mybatis/%E5%A4%9A%E6%AC%A1%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%89.png\"></p>\n<h4 id=\"连接查询-2\"><a href=\"#连接查询-2\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h4><p><img src=\"/2020/08/26/Mybatis/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%89.png\"></p>\n<div class=\"note info\">\n            <p>总结：分次查询，每一次查询结果都是封装到一个POJO里；而连接查询，只查询一次，一次性得到所有列，要通过配置关系，将对应列封装到POJO里。</p>\n          </div>\n\n<p><img src=\"/2020/08/26/Mybatis/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2.png\"></p>\n<h1 id=\"Setting\"><a href=\"#Setting\" class=\"headerlink\" title=\"Setting\"></a>Setting</h1><h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><p>Mybatis有两级缓存</p>\n<h3 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h3><p>默认开启一级缓存。（sqlSession级别：同一个sqlSession使用缓存）<br>同一个sqlSession获取相同或不同Mapper：会使用到sql缓存。（如果没有预编译，则表明使用了缓存）<br>不同的sqlSession获取相同或不同Mapper：不会使用到缓存。</p>\n<h3 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h3><p>接口的全类名（命名空间级别：同一个Mapper对象）</p>\n<ol>\n<li>settings里cacheEnabled为true（也是默认开启）</li>\n<li>POJO要实现序列化</li>\n<li>映射文件（Mapper）要开启缓存</li>\n<li>执行的时候要sqlSession.commit()，才会保存缓存</li>\n</ol>\n<p><img src=\"/2020/08/26/Mybatis/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png\"></p>\n<h2 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h2><p>需要的时候才进行加载。<br>默认不开启懒加载</p>\n<h3 id=\"开启懒加载\"><a href=\"#开启懒加载\" class=\"headerlink\" title=\"开启懒加载\"></a>开启懒加载</h3><p>settings里的lazyLoadingEnabled改为true</p>\n<h3 id=\"如果立即加载\"><a href=\"#如果立即加载\" class=\"headerlink\" title=\"如果立即加载\"></a>如果立即加载</h3><p>在association里使用fetchType=“eager”</p>\n<h1 id=\"TypeHandler\"><a href=\"#TypeHandler\" class=\"headerlink\" title=\"TypeHandler\"></a>TypeHandler</h1><p>输入输出映射过程中，参数类型不匹配。（比如Json转换为一个POJO类）</p>\n<div class=\"note info\">\n            <p>如果是不需要经常变化的内容，可以使用JSON（varchar）来存储。<br>经常要变化的，最好使用数据库表。</p>\n          </div>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ol>\n<li>mybatis.xml的configuration里配置typeHandlers。也可以使用package指定typeHandler的包路径。</li>\n<li>手写一个typeHandler（继承BaseTypeHandler/实现TypeHandler），使用@MappedTypes(POJO.class)，@MappedJdbcTypes(JdbcType.xxx)。 xxx是Jdbc的数据类型。</li>\n<li>重写4个方法</li>\n</ol>\n<p><img src=\"/2020/08/26/Mybatis/TypeHandlerConfig.png\"><br><img src=\"/2020/08/26/Mybatis/TypeHandler.png\"></p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习(*)\"></a>练习(*)</h2><p>数组转换为POJO</p>\n<h1 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a>入门案例</h1><ol>\n<li><p>导包<br>mybatis、java-connector</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.5.5&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;5.1.47&lt;&#x2F;version&gt;</span><br><span class=\"line\">    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>mybaties配置文件（mybaties.xml)<br>JDBC的datasource<br>mappers的映射文件：详细见后面配置项mappers</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class=\"line\">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class=\"line\">&lt;!--             上面部分是约束配置,下方是配置属性                      --&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;typeAliases&gt;</span><br><span class=\"line\">        &lt;package name&#x3D;&quot;homework.mybatis_test&quot;&#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;typeAliases&gt;</span><br><span class=\"line\">    &lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class=\"line\">        &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class=\"line\">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class=\"line\">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class=\"line\">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class=\"line\">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&quot;&#x2F;&gt;</span><br><span class=\"line\">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class=\"line\">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;230427055&quot;&#x2F;&gt;</span><br><span class=\"line\">            &lt;&#x2F;dataSource&gt;</span><br><span class=\"line\">        &lt;&#x2F;environment&gt;</span><br><span class=\"line\">    &lt;&#x2F;environments&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;mapper class&#x3D;&quot;homework&#x2F;userMapper.xml&quot;&#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;mappers&gt;</span><br><span class=\"line\">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>映射文件 (xml)<br>在xml中，配置 <strong><em><code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code></em></strong> 以及对应 <strong><em>id</em></strong>，在标签内写对应的sql语句<br>在 <strong><em><code>&lt;select&gt;</code></em></strong> 标签需要写明resultType</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--查询单条user这个javabean--&gt;</span><br><span class=\"line\">&lt;!--resultType是查询必须的 → 不能省略--&gt;</span><br><span class=\"line\">&lt;!--resultType javabean类型 → javabean的全类名--&gt;</span><br><span class=\"line\">&lt;select id&#x3D;&quot;selectUserById&quot; resultType&#x3D;&quot;com.cskaoyan.bean.User&quot;&gt;</span><br><span class=\"line\">    select id,username,password,age,gender from j23_user_t where id &#x3D; #&#123;id&#125;</span><br><span class=\"line\">&lt;&#x2F;select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--查询list--&gt;</span><br><span class=\"line\">&lt;!--如果是查询多条数据，resultType 依然写的是单条记录对应的类型--&gt;</span><br><span class=\"line\">&lt;select id&#x3D;&quot;selectUsers&quot; resultType&#x3D;&quot;com.cskaoyan.bean.User&quot;&gt;</span><br><span class=\"line\">    select id,username,password,age,gender from j23_user_t</span><br><span class=\"line\">&lt;&#x2F;select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--新增insert--&gt;</span><br><span class=\"line\">&lt;!--传入的第二个参数object为user 这样的一个javabean对象 → #&#123;&#125; → javabean的成员变量名（get方法）--&gt;</span><br><span class=\"line\">&lt;insert id&#x3D;&quot;insertUser&quot; &gt;</span><br><span class=\"line\">    insert into j23_user_t (username,password,age,gender)</span><br><span class=\"line\">    values</span><br><span class=\"line\">    (#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;gender&#125;)</span><br><span class=\"line\">&lt;&#x2F;insert&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--修改update--&gt;</span><br><span class=\"line\">&lt;update id&#x3D;&quot;updateUser&quot;&gt;</span><br><span class=\"line\">    update j23_user_t set gender &#x3D; #&#123;gender&#125; where id &#x3D; #&#123;id&#125;</span><br><span class=\"line\">&lt;&#x2F;update&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--删除delete--&gt;</span><br><span class=\"line\">&lt;delete id&#x3D;&quot;deleteUser&quot;&gt;</span><br><span class=\"line\">    delete from j23_user_t where id &#x3D; #&#123;id&#125;</span><br><span class=\"line\">&lt;&#x2F;delete&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过映射文件的namespace和sql语句id执行sql语句<br>SqlSessionFactoryBuilder →  sqlSessionFactory（加载配置文件）  →  sqlSession<br>配置文件可以通过流形式（ibatis.io.Resources)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Homework2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSqlSession sqlSession;</span><br><span class=\"line\">\tstatic SqlSessionFactory sqlSessionFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@BeforeAll</span><br><span class=\"line\">\tpublic static void init()  throws IOException</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSqlSessionFactoryBuilder sqlSessionFactoryBuilder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsqlSessionFactory &#x3D; sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis1.xml&quot;));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@BeforeEach</span><br><span class=\"line\">\tpublic void before()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@AfterEach</span><br><span class=\"line\">\tpublic void after()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsqlSession.commit();</span><br><span class=\"line\">\t\tsqlSession.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Test</span><br><span class=\"line\">\tpublic void test()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tUser user &#x3D; new User(&quot;tian&quot;,&quot;33334421&quot;);</span><br><span class=\"line\">\t\tint insertResult &#x3D; sqlSession.insert(&quot;mapperId.insertUser&quot;, user);</span><br><span class=\"line\">\t\tObject o &#x3D; sqlSession.selectOne(&quot;mapperId.selectUser&quot;, user);</span><br><span class=\"line\">\t\tSystem.out.println(o);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<h1 id=\"sqlSession\"><a href=\"#sqlSession\" class=\"headerlink\" title=\"sqlSession\"></a>sqlSession</h1><p> <strong><em>增删改需要对sqlSession进行commit提交事务</em></strong></p>\n<h2 id=\"查询（select）\"><a href=\"#查询（select）\" class=\"headerlink\" title=\"查询（select）\"></a>查询（select）</h2><p>方式和案例一样，除了xml配置文件的resultType是和JavaBean绑定</p>\n<ul>\n<li>查询一个</li>\n<li>查询多个（List）</li>\n</ul>\n<h2 id=\"新增（insert）\"><a href=\"#新增（insert）\" class=\"headerlink\" title=\"新增（insert）\"></a>新增（insert）</h2><h2 id=\"修改（update）\"><a href=\"#修改（update）\" class=\"headerlink\" title=\"修改（update）\"></a>修改（update）</h2><h2 id=\"删除（delete）\"><a href=\"#删除（delete）\" class=\"headerlink\" title=\"删除（delete）\"></a>删除（delete）</h2><h2 id=\"Junit的-Before、-After、-BeforeClass、-AfterClass注解\"><a href=\"#Junit的-Before、-After、-BeforeClass、-AfterClass注解\" class=\"headerlink\" title=\"Junit的@Before、@After、@BeforeClass、@AfterClass注解\"></a>Junit的@Before、@After、@BeforeClass、@AfterClass注解</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h1 id=\"配置项\"><a href=\"#配置项\" class=\"headerlink\" title=\"配置项\"></a>配置项</h1><ol>\n<li>properties</li>\n</ol>\n<ul>\n<li>单项配置<br>没什么用</li>\n<li>引入文件<br>没什么用</li>\n</ul>\n<ol start=\"2\">\n<li><p>settings</p>\n</li>\n<li><p>typeAliases</p>\n</li>\n</ol>\n<ul>\n<li><p>对单条配置别名</p>\n</li>\n<li><p>批量配置别名</p>\n</li>\n<li><p>mybatis提供的别名</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><p>typeHandlers<br>负责输入/输出映射过程中参数不匹配<br>输入映射<br>输出映射<br>写一个typeHandler继承BaseTypeHandler或实现TypeHandler，并使用范型<br>使用两个注解@MappedTypes(javabean.class) @MappedJdbcTypes(JdbcType.xxx)<br>重写四个方法，使用jackson-databind：ObjectMapper（字符串转换javaBean，或者javaBean转换为字符串）<br>在Mybatis.xml/Spring的配置上配置TypeHandler的package</p>\n</li>\n<li><p>mappers：配置加载映射文件</p>\n</li>\n</ol>\n<ul>\n<li>单个文件</li>\n</ul>\n<ol>\n<li><p>resource：映射文件的该配置文件的相对路径</p>\n</li>\n<li><p>url：绝对路径</p>\n</li>\n<li><p>class<br>好处：防止调用错误，比较容易排查问题<br>缺点：麻烦<br> <strong><em>接口和映射文件(mapper的xml配置），必须是同一级目录，并且同名</em></strong><br> <strong><em>命名空间必须是接口的全类名</em></strong><br> <strong><em>接口中方法名对应sql语句标签id</em></strong></p>\n</li>\n</ol>\n<ul>\n<li><p>多个文件<br>在单个文件的基础上，使用扫描包</p>\n</li>\n<li><p>如何使用接口<br>从sqlSession中获取接口类mapper<br>调用接口方法使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void run()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tUserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);</span><br><span class=\"line\">\tint insertResult &#x3D; mapper.insertUser(&quot;tian&quot;, &quot;123456&quot;);</span><br><span class=\"line\">\tObject selectResult &#x3D; mapper.deleteUser(14);</span><br><span class=\"line\">\tSystem.out.println(selectResult);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>插件：MyBatisCodeHelperPro</p>\n<ul>\n<li>用来查看MyBatis的源码</li>\n<li>接口和映射文件直接切换阅读</li>\n</ul>\n<h1 id=\"log4j\"><a href=\"#log4j\" class=\"headerlink\" title=\"log4j\"></a>log4j</h1><p>日志框架</p>\n<ol>\n<li><p>导包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.2.17&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入配置文件<br>在classpath下放入log4j.properties(具体配置文件可以网上找)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#Appender</span><br><span class=\"line\">#org.apache.log4j.ConsoleAppender（控制台）</span><br><span class=\"line\">#org.apache.log4j.FileAppender（文件）</span><br><span class=\"line\">#org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</span><br><span class=\"line\">#org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</span><br><span class=\"line\">#org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br><span class=\"line\">### direct log messages to stdout ###</span><br><span class=\"line\">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.stdout.Target&#x3D;System.out</span><br><span class=\"line\">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### direct messages to file hibernate.log ###</span><br><span class=\"line\">log4j.appender.file&#x3D;org.apache.log4j.FileAppender</span><br><span class=\"line\">log4j.appender.file.File&#x3D;d:&#x2F;&#x2F;23mybatis.log</span><br><span class=\"line\">log4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">#org.apache.log4j.HTMLLayout（以HTML表格形式布局）</span><br><span class=\"line\">#org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</span><br><span class=\"line\">#org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</span><br><span class=\"line\">#org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</span><br><span class=\"line\">log4j.appender.simple &#x3D; org.apache.log4j.FileAppender</span><br><span class=\"line\">log4j.appender.simple.File&#x3D;d:&#x2F;&#x2F;simple.log</span><br><span class=\"line\">log4j.appender.simple.layout&#x3D;org.apache.log4j.SimpleLayout</span><br><span class=\"line\">#log4j.appender.file2.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.html &#x3D; org.apache.log4j.FileAppender</span><br><span class=\"line\">log4j.appender.html.File&#x3D;d:&#x2F;&#x2F;mybatis.html</span><br><span class=\"line\">log4j.appender.html.layout&#x3D;org.apache.log4j.HTMLLayout</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.ttcc &#x3D; org.apache.log4j.FileAppender</span><br><span class=\"line\">log4j.appender.ttcc.File&#x3D;d:&#x2F;&#x2F;ttcc.log</span><br><span class=\"line\">log4j.appender.ttcc.layout&#x3D;org.apache.log4j.TTCCLayout</span><br><span class=\"line\"></span><br><span class=\"line\">### DEBUG、INFO、WARN、ERROR和FATAL</span><br><span class=\"line\">#日志级别+输出appender</span><br><span class=\"line\">log4j.rootLogger&#x3D;debug ,file,stdout,simple,html,ttcc</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><p>配置文件格式</p>\n</li>\n<li><p>appender</p>\n<ol>\n<li>ConsoleAppender（控制台）</li>\n<li>FileAppender（文件）</li>\n<li>DailyRollingFileAppender（每天产生一个日志文件）</li>\n<li>RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li>\n<li>WriterAppender（将日志信息以流格式发送到任意指定的地方）<br>\n<br></li>\n</ol>\n</li>\n<li><p>appender.file</p>\n</li>\n<li><p>appender.layout</p>\n<ol>\n<li>HTMLLayout</li>\n<li>PatternLayout</li>\n<li>Simple\bLayout</li>\n<li>TTCCLayout<br>\n<br>\n</li>\n</ol>\n</li>\n<li><p>自定义layout</p>\n<ol>\n<li>%d: 时间格式 %d{ABSOLUTE}</li>\n<li>%p: 日志级别 %5p 日志级别占用5个字符。 级别越低，内容越多，低级别包含高级别内容。 配置在rootlogger</li>\n</ol>\n<ul>\n<li>debug</li>\n<li>info</li>\n<li>warn</li>\n<li>error</li>\n<li>fatal</li>\n</ul>\n<ol start=\"3\">\n<li>%c: 类别信息 %c{1} 从后往前补全类</li>\n<li>%L: 显示源代码中第多少行</li>\n<li>%m: message</li>\n<li>%n: 换行</li>\n</ol>\n</li>\n<li><p>自行输出日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"高级映射-1\"><a href=\"#高级映射-1\" class=\"headerlink\" title=\"高级映射\"></a>高级映射</h1><h2 id=\"输入映射-1\"><a href=\"#输入映射-1\" class=\"headerlink\" title=\"输入映射\"></a>输入映射</h2><p>为sql语句提供参数: <code>#&#123;&#125;</code>里面填什么</p>\n<ul>\n<li><strong><em>基本类型、包装类、字符串</em></strong> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">- JavaBean、Map</span><br><span class=\"line\">   JavaBean输入映射使用的是get方法</span><br><span class=\"line\">   - 单个参数</span><br><span class=\"line\">     &#96;&#96;&#96;#&#123;&#125;&#96;&#96;&#96;里面要写 ***JavaBean成员变量*** 或者Map的 ***key***</span><br><span class=\"line\">   - 多个参数</span><br><span class=\"line\">     使用param（下标从1）或者arg（下标从0）</span><br><span class=\"line\">     或者使用注解@Param</span><br></pre></td></tr></table></figure>\n //也可以#{class.function} 或者#{map.key} <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> - insert标签属性</span><br><span class=\"line\">    只针对mysql可以获得自增组件，其他不能获得自增组件的见下方selectKey标签</span><br><span class=\"line\">    ***&#96;&#96;&#96;userGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;...&quot;&#96;&#96;&#96;***  keyProperty和@Param相关</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 输出映射</span><br><span class=\"line\">sql语句查询结果集的封装  mapper接口中的方法返回值来定义结果集</span><br><span class=\"line\">- 基本类型、包装类、字符串</span><br><span class=\"line\">    单条和多条中，接口中方法的返回值是不同的；sql语句查询结果允许的记录数不同</span><br><span class=\"line\">    - 单条记录</span><br><span class=\"line\"></span><br><span class=\"line\">    - 多条记录</span><br><span class=\"line\"></span><br><span class=\"line\">- JavaBean</span><br><span class=\"line\">    JavaBean的成员变量和mysql表的列名不一定一致，需要用到as来处理。输出映射使用的是JavaBean的set方法</span><br><span class=\"line\">    - 单条记录</span><br><span class=\"line\">    </span><br><span class=\"line\">    - 多条记录</span><br><span class=\"line\">        数组和List只有接口返回值不同的区别</span><br><span class=\"line\">        - 数组</span><br><span class=\"line\">        - List</span><br><span class=\"line\"></span><br><span class=\"line\">    - resultMap</span><br><span class=\"line\">        查询结果列名和JavaBean成员变量 对应 （resultType要求名一致）</span><br><span class=\"line\">        将columu和property做对应</span><br><span class=\"line\">        - column: 查询结果的列名</span><br><span class=\"line\">        - property: JavaBean的成员变量名(set)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 动态sql标签</span><br><span class=\"line\">把查询条件放在where标签里</span><br><span class=\"line\">- 一般使用</span><br><span class=\"line\"></span><br><span class=\"line\">- if标签</span><br><span class=\"line\">    test属性：写条件。值可以是输入映射中的值（@Param中的值）</span><br><span class=\"line\">    1. 变量</span><br><span class=\"line\">    2. 常量</span><br><span class=\"line\">        - 数值：直接写</span><br><span class=\"line\">        - 字符串：单引号</span><br><span class=\"line\">        - 布尔类型：直接写在判定条件上</span><br><span class=\"line\">        - 符号：等于（&#x3D;&#x3D;）、不等（!&#x3D;）、大于（gt）、小于（lt）</span><br><span class=\"line\">        - 连接符号：and、or</span><br><span class=\"line\">        - null值：null</span><br><span class=\"line\">        - 字符串长度：‘字符串’.length</span><br><span class=\"line\">        拼接取决于test条件是否为true</span><br><span class=\"line\">    </span><br><span class=\"line\">- where标签</span><br><span class=\"line\">    会自动去掉where后跟着的连接词(and or)</span><br><span class=\"line\">    如果where后没有内容，则不会添加where</span><br><span class=\"line\"></span><br><span class=\"line\">- choose-when-otherwise标签</span><br><span class=\"line\"></span><br><span class=\"line\">- trim标签</span><br><span class=\"line\">    - prefix</span><br><span class=\"line\">    - suffix</span><br><span class=\"line\">    - prefixOverrides</span><br><span class=\"line\">    - suffixOverrides</span><br><span class=\"line\"></span><br><span class=\"line\">- set标签</span><br><span class=\"line\">    相当于前面的trim标签做的一些修改</span><br><span class=\"line\"></span><br><span class=\"line\">- sql-include标签</span><br><span class=\"line\">    sql 标签定义一个sql片段</span><br><span class=\"line\">    include 标签引用sql标签的内容</span><br><span class=\"line\">    可以重复引用sql片段</span><br><span class=\"line\">    ***sql标签内可以嵌套其他标签***</span><br><span class=\"line\">    - 常用场景：</span><br><span class=\"line\">        ***select***</span><br><span class=\"line\">        ***where***</span><br><span class=\"line\">        ***select要选中的表的列***</span><br><span class=\"line\"></span><br><span class=\"line\">- selectKey标签</span><br><span class=\"line\">    用于获得insert新增后的自增值：还有一种方法见上方insert标签属性</span><br><span class=\"line\">    - order</span><br><span class=\"line\">        - before</span><br><span class=\"line\">        - after</span><br><span class=\"line\">    - keyColumn</span><br><span class=\"line\">    - keyProperty</span><br><span class=\"line\">    - resultType </span><br><span class=\"line\"></span><br><span class=\"line\">- foreach遍历</span><br><span class=\"line\">    - 属性</span><br><span class=\"line\">        - collection</span><br><span class=\"line\">        - item</span><br><span class=\"line\">        - separator</span><br><span class=\"line\">        - open</span><br><span class=\"line\">        - close</span><br><span class=\"line\">    </span><br><span class=\"line\">    - 接口形参</span><br><span class=\"line\">        - 数组&#x2F;List</span><br><span class=\"line\">        - @Param注解</span><br><span class=\"line\"></span><br><span class=\"line\">    - 插入单条</span><br><span class=\"line\"></span><br><span class=\"line\">    - 插入多条</span><br><span class=\"line\">        多条信息获得自增组件，后面也是.id</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 多表查询</span><br><span class=\"line\"></span><br><span class=\"line\">## 数据库表关系</span><br><span class=\"line\"></span><br><span class=\"line\">### 一对一</span><br><span class=\"line\"></span><br><span class=\"line\">### 一对多</span><br><span class=\"line\"></span><br><span class=\"line\">### 多对多</span><br><span class=\"line\">通过中间表维护多对多关系</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## JavaBean关系</span><br><span class=\"line\">把附表封装到JavaBean</span><br><span class=\"line\">### 一对一</span><br><span class=\"line\"></span><br><span class=\"line\">### 一对多</span><br><span class=\"line\"></span><br><span class=\"line\">### 多对多</span><br><span class=\"line\">两个JavaBean都封装对方的List成员变量</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 分次查询</span><br><span class=\"line\"></span><br><span class=\"line\">### 一对一分次查询</span><br><span class=\"line\">resultMap里 使用association子标签：property属性、columu属性、select属性（另一个select的resultType是一个JavaBean</span><br><span class=\"line\"></span><br><span class=\"line\">### 一对多分次查询</span><br><span class=\"line\">resultMap里 使用collection标签：property属性、columu属性、select属性（另一张resultMap的resultType是一个resultMap，result里再封装一个JavaBean）</span><br><span class=\"line\"></span><br><span class=\"line\">### 多对多分次查询</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 连接查询</span><br><span class=\"line\">左连接查询：from左表连接右表</span><br><span class=\"line\">javabean中封装另一个javabean的list </span><br><span class=\"line\">使用collection标签，offtype属性</span><br><span class=\"line\"></span><br><span class=\"line\">### 一对一连接查询</span><br><span class=\"line\">javabean中封装另一个javabean</span><br><span class=\"line\">select标签使用resultMap封装</span><br><span class=\"line\">如果有相同列名，要用as起别名</span><br><span class=\"line\"></span><br><span class=\"line\">在resultMap使用association标签封装</span><br><span class=\"line\"></span><br><span class=\"line\">- association标签</span><br><span class=\"line\">    property：父标签type的javabean成员变量名</span><br><span class=\"line\">    columu：查询结果的列名：为第二次查询提供参数</span><br><span class=\"line\">    select：第二次查询的 ***命名空间+id***</span><br><span class=\"line\"></span><br><span class=\"line\">### 一对多连接查询</span><br><span class=\"line\"></span><br><span class=\"line\">### 多对多连接查询</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Mybatis的settings</span><br><span class=\"line\"></span><br><span class=\"line\">## 缓存cache</span><br><span class=\"line\">Mybatis有两级缓存</span><br><span class=\"line\"></span><br><span class=\"line\">### 一级缓存</span><br><span class=\"line\">默认开启一级缓存</span><br><span class=\"line\">sqlSession保存在一级缓存，在sqlSession执行commit后失效</span><br><span class=\"line\"></span><br><span class=\"line\">### 二级缓存</span><br><span class=\"line\">命名空间类型或接口的全类名来自同一个mapper对象</span><br><span class=\"line\"></span><br><span class=\"line\">settings里添加cacheEnabled为true(默认值为true)</span><br><span class=\"line\">映射结果要序列化（implement Serializable）</span><br><span class=\"line\">mapper映射文件里开启缓存（添加cache标签）</span><br><span class=\"line\"></span><br><span class=\"line\">如果开启了二级缓存，执行sqlSession的commit或close后才会把sqlSession放入缓存</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 懒加载</span><br><span class=\"line\">默认不开启</span><br><span class=\"line\">settings标签开启</span><br><span class=\"line\">仅限于分次查询：在需要的查询时候才进行查询</span><br><span class=\"line\"></span><br><span class=\"line\">如果想要立刻加载：association或collection中使用fetchType：eager</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># MyBatis中使用事务</span><br><span class=\"line\"></span><br><span class=\"line\">## 注册DataSourceTransactionManager</span><br><span class=\"line\"></span><br><span class=\"line\">## 配置</span><br><span class=\"line\">- xml配置</span><br><span class=\"line\"></span><br><span class=\"line\">- javaConfig配置</span><br><span class=\"line\"></span><br><span class=\"line\"># pageHelper</span><br><span class=\"line\"></span><br><span class=\"line\">## 引入依赖</span><br></pre></td></tr></table></figure>\n<dependency>\n <groupId>com.github.pagehelper</groupId>\n <artifactId>pagehelper-spring-boot-starter</artifactId>\n <version>1.2.5</version>\n</dependency>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## SpringBoot配置</span><br></pre></td></tr></table></figure>\npagehelper:\nhelper-dialect: mysql\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 开启分页</span><br><span class=\"line\">Service层负责</span><br></pre></td></tr></table></figure>\nPageHelper.startPage\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 其他操作</span><br></pre></td></tr></table></figure>\nPageInfo<T> pageInfo = new PageInfo<>(name)\nPageInfo.getTotal()\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## @JsonFormat()</span><br><span class=\"line\"></span><br><span class=\"line\"># mysql相关</span><br><span class=\"line\"></span><br><span class=\"line\">## #&#123;&#125; 和 $&#123;&#125;的区别</span><br><span class=\"line\">预编译 和 字符串拼接</span><br><span class=\"line\"></span><br><span class=\"line\">#&#123;&#125; 不能用于排序</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 如果一个sql的Mapper的参数没有@Param注解，则可以直接使用这个参数的成员变量</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## mysql的连表</span><br><span class=\"line\">left join</span><br><span class=\"line\">right join</span><br><span class=\"line\">inner join</span><br><span class=\"line\"></span><br><span class=\"line\">## 一个sql如何count多个值</span><br><span class=\"line\">使用case when then函数</span><br><span class=\"line\">SELECT </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 相关注解</span><br><span class=\"line\">@SELECT(Sql语句)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># tk-mybatis&#x2F;mybatis-plus</span><br><span class=\"line\"></span><br><span class=\"line\">## 导包</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用注解绑定sql和DTO</span><br><span class=\"line\"></span><br><span class=\"line\">## 配置datasource</span><br><span class=\"line\"></span><br><span class=\"line\">## 写Mapper接口继承tk的Mapper</span><br><span class=\"line\"></span><br><span class=\"line\">## SpringBoot配置mapper属性</span><br><span class=\"line\">type-aliases-package</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># jdbctype和java对应关系</span><br><span class=\"line\">| jdbctype|javaClass|</span><br><span class=\"line\">| ---|---|</span><br><span class=\"line\">| JDBC Type|Java Type|</span><br><span class=\"line\">| CHAR|String|</span><br><span class=\"line\">| VARCHAR|String|</span><br><span class=\"line\">| LONGVARCHAR|String|</span><br><span class=\"line\">| NUMERIC|java.math.BigDecimal|</span><br><span class=\"line\">| DECIMAL|java.math.BigDecimal|</span><br><span class=\"line\">| BIT|boolean|</span><br><span class=\"line\">| BOOLEAN|boolean|</span><br><span class=\"line\">| TINYINT|byte|</span><br><span class=\"line\">| SMALLINT|short|</span><br><span class=\"line\">| INTEGER|INTEGER|</span><br><span class=\"line\">| BIGINT|long|</span><br><span class=\"line\">| REAL|float|</span><br><span class=\"line\">| FLOAT|double|</span><br><span class=\"line\">| DOUBLE|double|</span><br><span class=\"line\">| BINARY|byte[]|</span><br><span class=\"line\">| VARBINARY|byte[]|</span><br><span class=\"line\">| LONGVARBINARY|byte[]|</span><br><span class=\"line\">| DATE|java.sql.Date|</span><br><span class=\"line\">| TIME|java.sql.Time|</span><br><span class=\"line\">| TIMESTAMP|java.sql.Timestamp|</span><br><span class=\"line\">| CLOB|Clob|</span><br><span class=\"line\">| BLOB|Blob|</span><br><span class=\"line\">| ARRAY|Array|</span><br><span class=\"line\">| DISTINCT|mapping of underlying type|</span><br><span class=\"line\">| STRUCT|Struct|</span><br><span class=\"line\">| REF|Ref|</span><br><span class=\"line\">| DATALINK|java.net.URL[color&#x3D;red][&#x2F;color]|</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># SpringBoot整合mybatis</span><br><span class=\"line\">## 导包</span><br><span class=\"line\">mybatis-spring-boot-starter</span><br><span class=\"line\"></span><br><span class=\"line\">## xxxMapper</span><br><span class=\"line\"></span><br><span class=\"line\">## xxxMapper.xml</span><br></pre></td></tr></table></figure>\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zhg.demo.mybatis.mapper.UserMapper\">\n <select id=\"findAll\" resulttype=\"User\">\n     SELECT * FROM tb_user\n </select>\n</mapper>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## yml配置</span><br></pre></td></tr></table></figure>\ntype-aliases-package：mysql对应的实体位置\nmapper-locations：classpath：mapper/*.xml\nconfiguration:\n ...\n```</T></li>\n</ul>\n","categories":["框架"],"tags":["Java","MySQL"]},{"title":"Mybatis-Plus多数据源配置","url":"/2022/06/18/Mybatis-Plus%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>项目很多时候并不是单一操作一个数据源，可能有多个，所以该案例提供一个多数据源操作的典型。<br>SpringBoot + Mybatis-Plus + druid</p>\n<h1 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h1><p>mybatis-plus官方提供了多数据源的jar包（dynamic-datasource-spring-boot-starter）</p>\n<ol>\n<li>dynamic-datasource-spring-boot-starter</li>\n<li>mybatis-plus-boot-starter</li>\n<li>druid (提供数据库连接池)</li>\n</ol>\n","categories":["框架"],"tags":["Java","MySQL"]},{"title":"Mysql","url":"/2020/09/02/Mysql/","content":"<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><h2 id=\"开启远程连接\"><a href=\"#开启远程连接\" class=\"headerlink\" title=\"开启远程连接\"></a>开启远程连接</h2><p>配置文件/etc/mysql/my.cnf ，增加 bind-address = 0.0.0.0<br>并在mysql的数据库中，增加用户的连接权限</p>\n<h1 id=\"数据库基础\"><a href=\"#数据库基础\" class=\"headerlink\" title=\"数据库基础\"></a>数据库基础</h1><h2 id=\"数据库、数据库管理系统、数据库系统\"><a href=\"#数据库、数据库管理系统、数据库系统\" class=\"headerlink\" title=\"数据库、数据库管理系统、数据库系统\"></a>数据库、数据库管理系统、数据库系统</h2><h2 id=\"关系型数据库和非关系型数据库\"><a href=\"#关系型数据库和非关系型数据库\" class=\"headerlink\" title=\"关系型数据库和非关系型数据库\"></a>关系型数据库和非关系型数据库</h2><h3 id=\"关系型数据库\"><a href=\"#关系型数据库\" class=\"headerlink\" title=\"关系型数据库\"></a>关系型数据库</h3><p>不仅存储数据本身，还存储数据之间的关系。具有天然的表格性。</p>\n<h3 id=\"非关系型数据库\"><a href=\"#非关系型数据库\" class=\"headerlink\" title=\"非关系型数据库\"></a>非关系型数据库</h3><p>也称NoSQL。NoSQL并不是为了否定关系型数据库，而是作为关系型数据库的一种补充。数据是大块组合在一起。</p>\n<h2 id=\"数据在表的形式（Mysql）\"><a href=\"#数据在表的形式（Mysql）\" class=\"headerlink\" title=\"数据在表的形式（Mysql）\"></a>数据在表的形式（Mysql）</h2><p>表的一行称为记录。一条记录对应一个Java对象。</p>\n<h1 id=\"SQL简介\"><a href=\"#SQL简介\" class=\"headerlink\" title=\"SQL简介\"></a>SQL简介</h1><h2 id=\"结构化的查询语言\"><a href=\"#结构化的查询语言\" class=\"headerlink\" title=\"结构化的查询语言\"></a>结构化的查询语言</h2><p>SQL是结构化查询语言（Structured Query Language）的缩写。专门用作关系型数据库的语言。</p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><p>SQL是一种通用语言。<br>简单易学，并且强有力，可以很灵活的对数据库进行操作。<br>语言寿命很长。<br>不区分大小写。</p>\n<div class=\"note info\">\n            <p>建议关键字都使用大写，从而进行区分</p>\n          </div>\n\n<h1 id=\"数据导入和导出\"><a href=\"#数据导入和导出\" class=\"headerlink\" title=\"数据导入和导出\"></a>数据导入和导出</h1><h2 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h2><h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p>mysql -u $user -p db_name &lt; file.sql</p>\n<h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>source file.sql</p>\n<h2 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h2><h3 id=\"CMD-1\"><a href=\"#CMD-1\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p>mysqldump -u $user -p db_name &gt; file.sql</p>\n<h3 id=\"MySQL-1\"><a href=\"#MySQL-1\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>软件内导出</p>\n<h1 id=\"数据定义语言（DDL）\"><a href=\"#数据定义语言（DDL）\" class=\"headerlink\" title=\"数据定义语言（DDL）\"></a>数据定义语言（DDL）</h1><h2 id=\"CREATE\"><a href=\"#CREATE\" class=\"headerlink\" title=\"CREATE\"></a>CREATE</h2><h3 id=\"创数据库\"><a href=\"#创数据库\" class=\"headerlink\" title=\"创数据库\"></a>创数据库</h3><p>CREATE DATEBASE [if note exists] db_name [specifications]</p>\n<h3 id=\"创表\"><a href=\"#创表\" class=\"headerlink\" title=\"创表\"></a>创表</h3><p>CREATE TABLE tb_name (col_name1 dtype1, …) [specifications]</p>\n<h2 id=\"SHOW\"><a href=\"#SHOW\" class=\"headerlink\" title=\"SHOW\"></a>SHOW</h2><h3 id=\"查数据库\"><a href=\"#查数据库\" class=\"headerlink\" title=\"查数据库\"></a>查数据库</h3><p>SHOW DATABASES;<br>SHOW CREATE DATABASE db_name;</p>\n<h3 id=\"查表\"><a href=\"#查表\" class=\"headerlink\" title=\"查表\"></a>查表</h3><p>SHOW TABLES;<br>SHOW TABLES IN db_name;<br>DESCRIBE tb_name/DESC tb_name;<br>SHOW CREATE TABLE tb_name;</p>\n<h2 id=\"ALTER\"><a href=\"#ALTER\" class=\"headerlink\" title=\"ALTER\"></a>ALTER</h2><h3 id=\"修改数据库\"><a href=\"#修改数据库\" class=\"headerlink\" title=\"修改数据库\"></a>修改数据库</h3><p>ALTER DATABASE db_name [specifications]</p>\n<h3 id=\"修改表和表中元素\"><a href=\"#修改表和表中元素\" class=\"headerlink\" title=\"修改表和表中元素\"></a>修改表和表中元素</h3><ol>\n<li>ADD（添加列）<br>ALTER TABLE tb_name ADD COLUMU new_col_name dtype;<br>ALTER TABLE tb_name ADD COLUMU new_col_name dtype AFTER col_name;<br>ALTER TABLE tb_name ADD COLUMU new_col_name dtype FIRST;</li>\n<li>CHANGE（修给列名）<br>ALTER TABLE tb_name CHANGE COLUMU col_name new_col_name;</li>\n<li>MODIFY（修改列属性）<br>ALTER TABLE tb_name MODIFY COLUMU col_name dtype;</li>\n<li>DROP（删除列）<br>ALTER TABLE tb_name DROP COLUMU col_name;</li>\n<li>修改表的字符集和校对规则<br>ALTER TABLE tb_name [specifications]</li>\n</ol>\n<h2 id=\"DROP\"><a href=\"#DROP\" class=\"headerlink\" title=\"DROP\"></a>DROP</h2><h3 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h3><p>DROP DATABASE db_name;</p>\n<h3 id=\"删除表\"><a href=\"#删除表\" class=\"headerlink\" title=\"删除表\"></a>删除表</h3><p>DROP TABLE tb_name;</p>\n<h2 id=\"RENAME（可以用作迁移表）\"><a href=\"#RENAME（可以用作迁移表）\" class=\"headerlink\" title=\"RENAME（可以用作迁移表）\"></a>RENAME（可以用作迁移表）</h2><p>RENAME TABLE db1.tb_name to db2.tb_name;</p>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><h2 id=\"整数\"><a href=\"#整数\" class=\"headerlink\" title=\"整数\"></a>整数</h2><h3 id=\"TINYINT\"><a href=\"#TINYINT\" class=\"headerlink\" title=\"TINYINT\"></a>TINYINT</h3><p>1字节，256</p>\n<h3 id=\"SMALLINT\"><a href=\"#SMALLINT\" class=\"headerlink\" title=\"SMALLINT\"></a>SMALLINT</h3><p>2字节，65535</p>\n<h3 id=\"MEDIUMINT\"><a href=\"#MEDIUMINT\" class=\"headerlink\" title=\"MEDIUMINT\"></a>MEDIUMINT</h3><p>3字节，…</p>\n<h3 id=\"INT\"><a href=\"#INT\" class=\"headerlink\" title=\"INT\"></a>INT</h3><p>4字节，43亿</p>\n<h3 id=\"BIGINT\"><a href=\"#BIGINT\" class=\"headerlink\" title=\"BIGINT\"></a>BIGINT</h3><p>8字节，…</p>\n<h2 id=\"小数\"><a href=\"#小数\" class=\"headerlink\" title=\"小数\"></a>小数</h2><h3 id=\"FLOAT-M-D\"><a href=\"#FLOAT-M-D\" class=\"headerlink\" title=\"FLOAT(M,D)\"></a>FLOAT(M,D)</h3><h3 id=\"DOUBLE-M-D\"><a href=\"#DOUBLE-M-D\" class=\"headerlink\" title=\"DOUBLE(M,D)\"></a>DOUBLE(M,D)</h3><h3 id=\"DECIMAL-M-D\"><a href=\"#DECIMAL-M-D\" class=\"headerlink\" title=\"DECIMAL(M,D)\"></a>DECIMAL(M,D)</h3><p>定点数</p>\n<h2 id=\"日期和时间类型\"><a href=\"#日期和时间类型\" class=\"headerlink\" title=\"日期和时间类型\"></a>日期和时间类型</h2><h3 id=\"DATETIME\"><a href=\"#DATETIME\" class=\"headerlink\" title=\"DATETIME\"></a>DATETIME</h3><p>DATETIME默认为null，存储与时区无关。</p>\n<h3 id=\"TIMESTAMP\"><a href=\"#TIMESTAMP\" class=\"headerlink\" title=\"TIMESTAMP\"></a>TIMESTAMP</h3><p>TIMESTAMP默认为NOW( )，存储与时区有关。存储基于基准时间经历的秒数。<br>SET time_zone = ‘+8:00’ //修改时区</p>\n<h2 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h2><h3 id=\"CHAR-M\"><a href=\"#CHAR-M\" class=\"headerlink\" title=\"CHAR(M)\"></a>CHAR(M)</h3><p>固定长度，最多255个字符，即最大255个字节。</p>\n<h3 id=\"VARCHAR-M\"><a href=\"#VARCHAR-M\" class=\"headerlink\" title=\"VARCHAR(M)\"></a>VARCHAR(M)</h3><p>变长，version5之前长度按照字节，version5后按照字符。version5之前最大255，version5之后最大65532个。<br>L+1（用1个字节表示长度）</p>\n<h3 id=\"TINYTEXT\"><a href=\"#TINYTEXT\" class=\"headerlink\" title=\"TINYTEXT\"></a>TINYTEXT</h3><p>L+1</p>\n<h3 id=\"MEDIUMTEXT\"><a href=\"#MEDIUMTEXT\" class=\"headerlink\" title=\"MEDIUMTEXT\"></a>MEDIUMTEXT</h3><p>L+2</p>\n<h3 id=\"LONGTEXT\"><a href=\"#LONGTEXT\" class=\"headerlink\" title=\"LONGTEXT\"></a>LONGTEXT</h3><p>L+3</p>\n<h3 id=\"ENUM\"><a href=\"#ENUM\" class=\"headerlink\" title=\"ENUM\"></a>ENUM</h3><p>枚举类型，枚举只能保存其中的一个元素。<br>如果设置为not null，插入时如果没有赋值，则会自动插入默认值。</p>\n<h3 id=\"SET\"><a href=\"#SET\" class=\"headerlink\" title=\"SET\"></a>SET</h3><p>集合类型，集合可以保存其中的多个元素，并且根据定义的顺序排列好。</p>\n<h2 id=\"二进制类型（很少使用）\"><a href=\"#二进制类型（很少使用）\" class=\"headerlink\" title=\"二进制类型（很少使用）\"></a>二进制类型（很少使用）</h2><h1 id=\"数据操作语言（DML）\"><a href=\"#数据操作语言（DML）\" class=\"headerlink\" title=\"数据操作语言（DML）\"></a>数据操作语言（DML）</h1><ol>\n<li>INSERT</li>\n<li>UPDATE</li>\n<li>DELETE</li>\n</ol>\n<h2 id=\"INSERT\"><a href=\"#INSERT\" class=\"headerlink\" title=\"INSERT\"></a>INSERT</h2><div class=\"note info\">\n            <ol><li>插入的数据应与字段数据类型相同。</li><li>数据的大小应在列的规定范围内。</li><li>在values中列出的数据</li><li>字符串和日期数据应包好在单引号中</li><li>插入空值 INSERT INTO table_name VALUE(NULL) 必须写上null</li></ol>\n          </div>\n\n<h3 id=\"INTO\"><a href=\"#INTO\" class=\"headerlink\" title=\"INTO\"></a>INTO</h3><p>NSERT INTO tb_name col_name VALUES (value…..)</p>\n<h2 id=\"UPDATE\"><a href=\"#UPDATE\" class=\"headerlink\" title=\"UPDATE\"></a>UPDATE</h2><h3 id=\"SET-1\"><a href=\"#SET-1\" class=\"headerlink\" title=\"SET\"></a>SET</h3><p>UPDATE tb_name SET col_name = value [WHERE where]</p>\n<div class=\"note info\">\n            <p>一定要注意WHERE，如果不想全局修改，就一定要用WHERE</p>\n          </div>\n\n<h2 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h2><h3 id=\"FROM\"><a href=\"#FROM\" class=\"headerlink\" title=\"FROM\"></a>FROM</h3><p>DELETE FROM table_name [WHERE where]</p>\n<div class=\"note info\">\n            <ol><li>不使用WHERE将删除表中所有记录。</li><li>DELETE删除的单位是行。</li><li>删除表要用DROP。</li></ol>\n          </div>\n\n<h1 id=\"数据查询语言（DQL）\"><a href=\"#数据查询语言（DQL）\" class=\"headerlink\" title=\"数据查询语言（DQL）\"></a>数据查询语言（DQL）</h1><p>Select 子句 + From 子句 + Where 子句</p>\n<h2 id=\"简单查询\"><a href=\"#简单查询\" class=\"headerlink\" title=\"简单查询\"></a>简单查询</h2><h2 id=\"计算表达式和值\"><a href=\"#计算表达式和值\" class=\"headerlink\" title=\"计算表达式和值\"></a>计算表达式和值</h2><h2 id=\"查询表中字段\"><a href=\"#查询表中字段\" class=\"headerlink\" title=\"查询表中字段\"></a>查询表中字段</h2><h2 id=\"使用WHERE过滤\"><a href=\"#使用WHERE过滤\" class=\"headerlink\" title=\"使用WHERE过滤\"></a>使用WHERE过滤</h2><p>WHERE role = value<br>WHERE role BETWEEN value1 AND value2<br>WHERE role IN value<br>WHERE role LIKE ‘x%’</p>\n<ol>\n<li>知道首字符的模糊查询 田%</li>\n<li>包含某个字符的模糊查询 %田%</li>\n<li>去掉首字符的模糊查询 _%田%</li>\n</ol>\n<div class=\"note info\">\n            <p>%匹配任意数量字符。<br>_只能匹配一个字符。</p>\n          </div>\n\n<h2 id=\"给字段起别名\"><a href=\"#给字段起别名\" class=\"headerlink\" title=\"给字段起别名\"></a>给字段起别名</h2><p>SELECT role AS another_name</p>\n<h2 id=\"去除重复行\"><a href=\"#去除重复行\" class=\"headerlink\" title=\"去除重复行\"></a>去除重复行</h2><p>SELECT DISTINCT …</p>\n<div class=\"note info\">\n            <p>DISTINCT是对所有字段去重，所以必须多个字段对应都相同时，才会进行去重。且DISTINCT必须放在查询字段的最前面。</p>\n          </div>\n\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>ORDER BY role //默认生序<br>ORDER BY role DESC //降序</p>\n<div class=\"note info\">\n            <p>排序可以对非查询字段进行，只不过非查询字段的排序不会显示在结果中。<br>排序还可以对计算字段进行排序，如果计算结果不是查询字段，结果也不显示。</p>\n          </div>\n\n<h2 id=\"限制结果集的数量\"><a href=\"#限制结果集的数量\" class=\"headerlink\" title=\"限制结果集的数量\"></a>限制结果集的数量</h2><p>LIMIT x OFFSET y</p>\n<div class=\"note info\">\n            <p>使用LIMIT可以很方便进行分页查询</p>\n          </div>\n\n<h2 id=\"计算字段\"><a href=\"#计算字段\" class=\"headerlink\" title=\"计算字段\"></a>计算字段</h2><p>使用时会给计算字段加别名</p>\n<h2 id=\"聚合函数\"><a href=\"#聚合函数\" class=\"headerlink\" title=\"聚合函数\"></a>聚合函数</h2><ol>\n<li>COUNT()：COUNT(*)统计记录，COUNT()统计字段非NULL的个数。</li>\n<li>SUM()</li>\n<li>AVG()</li>\n<li>MAX()</li>\n<li>MIN()</li>\n</ol>\n<div class=\"note info\">\n            <p>要计算字段不同值的统计：可以对字段的先用DISTINCT去重，再用聚合函数统计。</p>\n          </div>\n\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>使用GROUP BY role来进行分组。</p>\n<ol>\n<li>搭配聚合函数来用</li>\n<li>使用GROUP_CONCAT()：可以讲包含的内容一起输出在结果。</li>\n<li>多字段分组：就是多个字段同时相等的时候才为一组。</li>\n<li>HAVING过滤分组</li>\n</ol>\n<div class=\"note info\">\n            <p>WHERE是过滤记录的，而HAVING是来过滤分组的</p>\n          </div>\n<div class=\"note info\">\n            <p>一般DBMS在进行分组的时候，都会进行排序，如果没有明确的ORDER BY子句，就应该假定是有序的</p>\n          </div>\n\n<h2 id=\"SELECT-顺序\"><a href=\"#SELECT-顺序\" class=\"headerlink\" title=\"SELECT 顺序\"></a>SELECT 顺序</h2><ol>\n<li>语法顺序：SELECT -&gt; FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</li>\n<li>执行顺序：FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</li>\n</ol>\n<p>详细的执行流程：</p>\n<ol>\n<li>首先是从 FROM 开始执行的。在这个阶段，如果是多表连接查询，还会经历以下几个步骤：</li>\n</ol>\n<ul>\n<li>通过 CROSS JOIN 求得笛卡尔乘积，得到虚拟表 vt1-1;</li>\n<li>通过 ON 进行连接，在 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2;</li>\n<li>如果是外连接，还会在 vt1-2 的基础上添加外部行，得到虚拟表 vt1-3;</li>\n</ul>\n<ol start=\"2\">\n<li>如果连接的表不止两张，还会重复上面步骤，直到所有表都处理完成。这个过程完成之后，我们就得到了虚拟表 vt-1，也就是我们的原始数据。</li>\n<li>WHERE 会在 vt-1 的基础上进行筛选，得到虚拟表 vt-2。 3. GROUP BY 会在 vt-2 的基础上行分组，得到虚拟表 vt-3。 </li>\n<li>HAVING 会在 vt-3 的基础上对分组进行筛选，得到虚拟表 vt-4。 </li>\n<li>SELECT 会在 vt-4 的基础上提取想要的字段，得到虚拟表 vt-5。</li>\n<li>DISTINCT 会在 vt-5 的基础上，去掉重复行，得到虚拟表 vt-6。</li>\n<li>ORDER BY 会按照指定的字段对 vt-6 进行排序，得到虚拟表 vt-7。</li>\n<li>LIMIT 会在 vt-7 的基础上提取指定的记录，得到虚拟表 vt-8。</li>\n</ol>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">AND（&amp;&amp;）</span><br><span class=\"line\">OR（||）</span><br><span class=\"line\">NOT （!）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;、｜、^、~、&lt;&lt;、&gt;&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"逆序输出\"><a href=\"#逆序输出\" class=\"headerlink\" title=\"逆序输出\"></a>逆序输出</h1><p>select * from tablename order by filename1 desc;</p>\n<h1 id=\"限制条数\"><a href=\"#限制条数\" class=\"headerlink\" title=\"限制条数\"></a>限制条数</h1><p>select * from tablename order by filename1 desc LIMIT 20;<br>注意LIMIT要在ORDER BY的后面</p>\n","categories":["数据库"],"tags":["MySQL"]},{"title":"Nginx","url":"/2020/09/11/Nginx/","content":"<h2 id=\"Nginx使用\"><a href=\"#Nginx使用\" class=\"headerlink\" title=\"Nginx使用\"></a>Nginx使用</h2><h2 id=\"Nginx配置\"><a href=\"#Nginx配置\" class=\"headerlink\" title=\"Nginx配置\"></a>Nginx配置</h2>","categories":["框架"],"tags":["分布式","反向代理"]},{"title":"PipeLine","url":"/2022/03/30/PipeLine/","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在做订单业务的时候，需要多个逻辑操作流水线依次执行，所以采用管道设计模式，将操作分解分拆。</p>\n<p>本质上，是责任链 + 工厂模式。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><h2 id=\"1-流水线内容\"><a href=\"#1-流水线内容\" class=\"headerlink\" title=\"1. 流水线内容\"></a>1. 流水线内容</h2><h3 id=\"1-1-流水线统一内容接口PipelineContext\"><a href=\"#1-1-流水线统一内容接口PipelineContext\" class=\"headerlink\" title=\"1.1 流水线统一内容接口PipelineContext\"></a>1.1 流水线统一内容接口PipelineContext</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PipelineContext</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-某业务相关抽象内容类AbstractPipelineContext\"><a href=\"#1-2-某业务相关抽象内容类AbstractPipelineContext\" class=\"headerlink\" title=\"1.2 某业务相关抽象内容类AbstractPipelineContext\"></a>1.2 某业务相关抽象内容类AbstractPipelineContext</h3><p>在此处，是订单业务相关核心业务，一定不会更改的，所以定义了orderId</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderAbstractPipelineContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">PipelineContext</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String orderId;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-某业务具体内容-xxxPipelineContext\"><a href=\"#1-3-某业务具体内容-xxxPipelineContext\" class=\"headerlink\" title=\"1.3 某业务具体内容 xxxPipelineContext\"></a>1.3 某业务具体内容 xxxPipelineContext</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderPipelineContext</span> <span class=\"keyword\">extends</span> <span class=\"title\">OrderAbstractPipelineContext</span> </span>&#123;</span><br><span class=\"line\">    Long userId;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-回调类接口-PipelineCallback\"><a href=\"#1-4-回调类接口-PipelineCallback\" class=\"headerlink\" title=\"1.4 回调类接口 PipelineCallback\"></a>1.4 回调类接口 PipelineCallback</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PipelineCallback</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">onDone</span><span class=\"params\">(PipelineContext pipelineContext)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-具体回调类-xxxPipelineCallback\"><a href=\"#1-5-具体回调类-xxxPipelineCallback\" class=\"headerlink\" title=\"1.5 具体回调类 xxxPipelineCallback\"></a>1.5 具体回调类 xxxPipelineCallback</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 2. 流水线业务</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.1 流水线处理接口 PipelineHandler</span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"comment\">//单纯定义一个接口，表明是流水线</span></span><br><span class=\"line\"><span class=\"comment\">//有需要可以从这里增加功能</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PipelineHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 是否采用异步方式执行</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAsync</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 执行交易具体业务&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true则继续执行下一个Handler，否则结束Handler Chain的执行直接返回</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">handle</span><span class=\"params\">(PipelineContext context)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 回调函数</span></span><br><span class=\"line\"><span class=\"comment\">    PipelineCallback getPipelineCallback();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-某业务相关抽象处理流水线-AbstractPipelineHandler\"><a href=\"#2-2-某业务相关抽象处理流水线-AbstractPipelineHandler\" class=\"headerlink\" title=\"2.2 某业务相关抽象处理流水线 AbstractPipelineHandler\"></a>2.2 某业务相关抽象处理流水线 AbstractPipelineHandler</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractPipelineHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">PipelineHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-具体流水线-xxxPipelineHandler\"><a href=\"#2-3-具体流水线-xxxPipelineHandler\" class=\"headerlink\" title=\"2.3 具体流水线 xxxPipelineHandler\"></a>2.3 具体流水线 xxxPipelineHandler</h3><p>继承AbstractPipeline，重写对应的handle方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> InitPipelineHandler extends AbstractPipelineHandler &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> OrderService orderService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> OrderItemService orderItemService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InitPipeline</span><span class=\"params\">(OrderService orderService,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            OrderItemService orderItemService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.orderService = orderService;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.orderItemService = orderItemService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAsync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//在这里，处理订单内容</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handle</span><span class=\"params\">(PipelineContext context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//todo...</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\">publice PipelineCallback <span class=\"title\">getPipelineCallback</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//根据是否需要回调，返回null或者具体的回调类</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-流水线链\"><a href=\"#3-流水线链\" class=\"headerlink\" title=\"3. 流水线链\"></a>3. 流水线链</h2><h3 id=\"3-1-流水线业务节点-PipelineHandlerNode\"><a href=\"#3-1-流水线业务节点-PipelineHandlerNode\" class=\"headerlink\" title=\"3.1 流水线业务节点 PipelineHandlerNode\"></a>3.1 流水线业务节点 PipelineHandlerNode</h3><p>链表结构，将流水线业务串成链表，有序执行。<br>并定义执行操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class PipelineHandlerNode &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> PipelineHandler pipelineHandler;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> PipelineHandlerNode nextNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//执行管道流水线</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execPipelineHandler</span><span class=\"params\">(PipelineContext pipelineContext)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行当前流水线业务</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> success = pipelineHandler.handle(pipelineContext);</span><br><span class=\"line\">            <span class=\"comment\">//执行回调</span></span><br><span class=\"line\">            execCallBack(pipelineHandler.getCallback(), pipelineContext, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (pipelineHandler.isAsync()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//TODO 如果为true，则采用异步线程去执行任务</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    nextNode.exec(pipelineContext);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            execCallBack(pipelineHandler.getCallback(), pipelineContext, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">            nextNode = pipelineHandler.nextNode;</span><br><span class=\"line\">            nextNode.handle(pipelineContext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//执行回调方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">execCallBack</span><span class=\"params\">(PipelineCallback pipeCallback, PipelineContext pipelineContext, Throwable exception)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (pipeCallback != <span class=\"keyword\">null</span> &amp;&amp; exception == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              pipeCallback.onDone(pipelineContext);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              log.warn(<span class=\"string\">&quot;业务操作出错&quot;</span>);</span><br><span class=\"line\">              <span class=\"keyword\">assert</span> ex != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">              log.warn(ex.getCause().toString());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;回调异常&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-流水线接口-Pipeline\"><a href=\"#3-2-流水线接口-Pipeline\" class=\"headerlink\" title=\"3.2 流水线接口 Pipeline\"></a>3.2 流水线接口 Pipeline</h3><p>接口方法，将业务添加至队伍头还是队伍尾<br>并且继承外部调用接口OutboundInvoker</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Pipeline</span> <span class=\"keyword\">extends</span> <span class=\"title\">OutboundInvoker</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addHead</span><span class=\"params\">(PipelineHandler... pipelineHandlers)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addTail</span><span class=\"params\">(PipelineHandler... pipelineHandlers)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-抽象流水线类-AbstractPipeline\"><a href=\"#3-3-抽象流水线类-AbstractPipeline\" class=\"headerlink\" title=\"3.3 抽象流水线类 AbstractPipeline\"></a>3.3 抽象流水线类 AbstractPipeline</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractPipeline</span> <span class=\"keyword\">implements</span> <span class=\"title\">Pipeline</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//头部哑节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PipelineHandlerNode head = <span class=\"keyword\">new</span> PipelineHandlerNode();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PipelineHandlerNode tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PipelineContext context = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbstractTransPipeline</span><span class=\"params\">(PipelineContext pipelineContext)</span>     </span>&#123;</span><br><span class=\"line\">        context = PipelineContext;</span><br><span class=\"line\">        tail = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(PipelineHandler... handlers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//哑节点的下一个必定是第一个</span></span><br><span class=\"line\">        PipelineHandlerNode first = head.getNext();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (TransHandler handler : handlers) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//头插法</span></span><br><span class=\"line\">            PipelineHandlerNode newNode = <span class=\"keyword\">new</span> PipelineHandlerNode();</span><br><span class=\"line\">            newNode.setPipeHandler(handler);</span><br><span class=\"line\">            newNode.setNext(first);</span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head.setNext(first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(PipelineHandler... handlers)</span> </span>&#123;</span><br><span class=\"line\">        PipelineHandlerNode last = tail;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (PipelineHandler handler : handlers) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//尾插法</span></span><br><span class=\"line\">            PipelineHandlerNode newNode = <span class=\"keyword\">new</span> PipelineHandlerNode();</span><br><span class=\"line\">            newNode.setPipeHandler(handler);</span><br><span class=\"line\">            last.setNext(newNode);</span><br><span class=\"line\">            last = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tail = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-具体流水线业务类-xxxPipeline\"><a href=\"#3-4-具体流水线业务类-xxxPipeline\" class=\"headerlink\" title=\"3.4 具体流水线业务类 xxxPipeline\"></a>3.4 具体流水线业务类 xxxPipeline</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderPipeline</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractPipeline</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OrderPipeline</span><span class=\"params\">(PipelineContext pipelineContext)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(pipelineContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            getHead().getNext().exec(getContext());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;pipeline系统运行异常.&quot;</span>, ex);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-流水线工厂\"><a href=\"#4-流水线工厂\" class=\"headerlink\" title=\"4. 流水线工厂\"></a>4. 流水线工厂</h2><h3 id=\"4-1-流水线工厂接口-PipelineFactory\"><a href=\"#4-1-流水线工厂接口-PipelineFactory\" class=\"headerlink\" title=\"4.1 流水线工厂接口 PipelineFactory\"></a>4.1 流水线工厂接口 PipelineFactory</h3><p>在工厂接口，定义建造方法<br>此处是建造一个外部调用的类，从而使得工厂得以启动</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PipelineFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">OutboundInvoker <span class=\"title\">build</span><span class=\"params\">(T obj)</span></span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-具体业务抽象流水线工厂-AbstractPipelineFactory\"><a href=\"#4-2-具体业务抽象流水线工厂-AbstractPipelineFactory\" class=\"headerlink\" title=\"4.2 具体业务抽象流水线工厂 AbstractPipelineFactory\"></a>4.2 具体业务抽象流水线工厂 AbstractPipelineFactory</h3><p>在这里定义业务的具体工作流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractPipelineFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">PipelineFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> OutboundInvoker <span class=\"title\">build</span><span class=\"params\">(T obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建流水线内容</span></span><br><span class=\"line\">        PipelineContext pipeContext = createContext();</span><br><span class=\"line\">        <span class=\"comment\">//将obj转换为context</span></span><br><span class=\"line\">        context = convert(obj, context);</span><br><span class=\"line\">        <span class=\"comment\">//创建流水线对象</span></span><br><span class=\"line\">        Pipeline pipeline = createPipeline(context);</span><br><span class=\"line\">        <span class=\"comment\">//构造成具体的流水线</span></span><br><span class=\"line\">        doBuild(pipeline);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> pipeline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> PipelineContext <span class=\"title\">createContext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Pipeline <span class=\"title\">createPipeline</span><span class=\"params\">(PipelineContext pipelineContext)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">doBuild</span><span class=\"params\">(Pipeline pipeline)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(T obj, PipelineContext pipelineContext)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-具体业务的流水线-xxxPipelineFactory\"><a href=\"#4-3-具体业务的流水线-xxxPipelineFactory\" class=\"headerlink\" title=\"4.3 具体业务的流水线 xxxPipelineFactory\"></a>4.3 具体业务的流水线 xxxPipelineFactory</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderPipelineFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractPipelineFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//具体的业务Handler</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValidateHandler validateHandler;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> InitOrderHandler initOrderHandler;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SubStockHandler subStockHandler;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LogisticalHandler logisticalHandler;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClearCartItemHandler clearCartItemHandler;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SendMessageHandler sendMessageHandler;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建自己业务的Context</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> PipelineContext <span class=\"title\">createContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> OrderPipelineContext();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建自己业务的流水线对象</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Pipeline <span class=\"title\">createPipeline</span><span class=\"params\">(PipelineContext pipelineContext)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> OrderPipeline(pipelineContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//构建自己的流水线业务</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\">Protected <span class=\"keyword\">void</span> <span class=\"title\">doBuild</span><span class=\"params\">(Pipeline pipeline)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//按照流水线顺序执行</span></span><br><span class=\"line\">        pipeline.addTail(validateHandler);</span><br><span class=\"line\">        pipeline.addTail(initOrderHandler);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建对象转换器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(T obj, PipelineContext pipelineContext)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//根据业务自己做</span></span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-外部调用\"><a href=\"#5-外部调用\" class=\"headerlink\" title=\"5. 外部调用\"></a>5. 外部调用</h2><h3 id=\"5-1-外部调用接口-OutboundInvoker\"><a href=\"#5-1-外部调用接口-OutboundInvoker\" class=\"headerlink\" title=\"5.1 外部调用接口 OutboundInvoker\"></a>5.1 外部调用接口 OutboundInvoker</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OutboundInvoker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 启动流程.&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 终止流程.&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用于获取返回值&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    &lt;T extends TransHandlerContext&gt; <span class=\"function\">T <span class=\"title\">getContext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-外部实际调用\"><a href=\"#5-2-外部实际调用\" class=\"headerlink\" title=\"5.2 外部实际调用\"></a>5.2 外部实际调用</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">doInvoke</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doInvoke</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">        TransOutboundInvoker invoker = orderProcessPipelineFactory.build(request);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//启动pipeline</span></span><br><span class=\"line\">        invoker.start(); <span class=\"comment\">//启动流程（pipeline来处理）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获取业务内容</span></span><br><span class=\"line\">        AbsTransHandlerContext context = invoker.getContext();</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","categories":["设计模式"],"tags":["Java"]},{"title":"RabbitMQ","url":"/2021/12/01/RabbitMQ/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h1 id=\"模型介绍\"><a href=\"#模型介绍\" class=\"headerlink\" title=\"模型介绍\"></a>模型介绍</h1><h1 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h1><h1 id=\"SpringAMQP\"><a href=\"#SpringAMQP\" class=\"headerlink\" title=\"SpringAMQP\"></a>SpringAMQP</h1><h2 id=\"WorkQueue模型\"><a href=\"#WorkQueue模型\" class=\"headerlink\" title=\"WorkQueue模型\"></a>WorkQueue模型</h2><p>多个消费者绑定一个队列，一个消息只能被一个消费者消费。默认是轮训机制。</p>\n<ol>\n<li>prefetch</li>\n</ol>\n<h2 id=\"发布订阅模型\"><a href=\"#发布订阅模型\" class=\"headerlink\" title=\"发布订阅模型\"></a>发布订阅模型</h2><p>允许将一个消息发送给多个消费者，因此需要引入exchange</p>\n<div class=\"note info\">\n            <p>exchange只负责转发，不负责存储，路由失败则消息丢失。</p>\n          </div>\n\n<h2 id=\"Fanout\"><a href=\"#Fanout\" class=\"headerlink\" title=\"Fanout\"></a>Fanout</h2><ol>\n<li>配置FanoutConfig<br>声明FanoutExchange<br>声明队列<br>绑定队列和交换机<br>（以上都是用Bean实现）</li>\n<li>各个Bean<br>队列：Queue<br>交换机：FanoutExchange<br>绑定关系：Binding </li>\n</ol>\n<h2 id=\"Direct\"><a href=\"#Direct\" class=\"headerlink\" title=\"Direct\"></a>Direct</h2><p>根据规则，发送消息到指定队列<br>绑定的时候指定RoutingKey<br>一个队列可以绑定多个Key<br>通过@RabbitListener注解绑定</p>\n<h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><p>发布订阅，必须是多个单词的列表<br>绑定可以用通配：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 表示0个或多个</span><br><span class=\"line\">* 表示1个</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息转换器\"><a href=\"#消息转换器\" class=\"headerlink\" title=\"消息转换器\"></a>消息转换器</h2><p>如果要修改消息转换器，需要定义一个MessageConverter的Bean。<br>推荐用JSON方法序列化（Jackson）<br>发布者和消费者都需要配置该Bean</p>\n","categories":["框架"],"tags":["分布式","消息队列"]},{"title":"Reactor实现","url":"/2024/04/22/Reactor%E5%AE%9E%E7%8E%B0/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Reactor基于Unix的内核响应，实现对网络通信的快速接收和响应。</p>\n<p>优点：</p>\n<ol>\n<li>快响应</li>\n<li>多线程</li>\n</ol>\n<h1 id=\"相关知识\"><a href=\"#相关知识\" class=\"headerlink\" title=\"相关知识\"></a>相关知识</h1><h2 id=\"Unix-网络编程\"><a href=\"#Unix-网络编程\" class=\"headerlink\" title=\"Unix 网络编程\"></a>Unix 网络编程</h2><ol>\n<li>基于TCP的socket编程</li>\n</ol>\n<h2 id=\"Unix-系统编程\"><a href=\"#Unix-系统编程\" class=\"headerlink\" title=\"Unix 系统编程\"></a>Unix 系统编程</h2><ol>\n<li>Unix内核高级IO：poll &amp; epoll</li>\n<li>多线程：pthread</li>\n</ol>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><ol>\n<li>抽象工厂</li>\n<li>建筑者模式</li>\n<li>单例</li>\n</ol>\n<h1 id=\"版本迭代\"><a href=\"#版本迭代\" class=\"headerlink\" title=\"版本迭代\"></a>版本迭代</h1><h2 id=\"Edition-1：基础功能与框架\"><a href=\"#Edition-1：基础功能与框架\" class=\"headerlink\" title=\"Edition 1：基础功能与框架\"></a>Edition 1：基础功能与框架</h2><h2 id=\"Edition-2：设计模式封装\"><a href=\"#Edition-2：设计模式封装\" class=\"headerlink\" title=\"Edition 2：设计模式封装\"></a>Edition 2：设计模式封装</h2><h2 id=\"Edition-3：epoll\"><a href=\"#Edition-3：epoll\" class=\"headerlink\" title=\"Edition 3：epoll\"></a>Edition 3：epoll</h2><p>使用epoll管理客户端和服务端的通信。<br>参考：epoll</p>\n<h2 id=\"Edition-4：多线程\"><a href=\"#Edition-4：多线程\" class=\"headerlink\" title=\"Edition 4：多线程\"></a>Edition 4：多线程</h2><h2 id=\"Edition-5：eventfd通信\"><a href=\"#Edition-5：eventfd通信\" class=\"headerlink\" title=\"Edition 5：eventfd通信\"></a>Edition 5：eventfd通信</h2>","categories":["项目"],"tags":["C++","多线程","UNIX网络编程"]},{"title":"Redis","url":"/2020/09/14/Redis/","content":"<h1 id=\"数据库知识\"><a href=\"#数据库知识\" class=\"headerlink\" title=\"数据库知识\"></a>数据库知识</h1><h2 id=\"NoSql\"><a href=\"#NoSql\" class=\"headerlink\" title=\"NoSql\"></a>NoSql</h2><p>NoSql 为了解决CPU和内存压力、解决IO压力，而诞生的数据库类型。</p>\n<h2 id=\"NoSql概述\"><a href=\"#NoSql概述\" class=\"headerlink\" title=\"NoSql概述\"></a>NoSql概述</h2><p>NoSql = Not Only Sql，是非关系型数据库</p>\n<ol>\n<li>不遵循sql语句</li>\n<li>不支持ACID</li>\n<li>远超SQL性能</li>\n</ol>\n<h2 id=\"NoSql适用场景\"><a href=\"#NoSql适用场景\" class=\"headerlink\" title=\"NoSql适用场景\"></a>NoSql适用场景</h2><ol>\n<li>对数据高并发读写</li>\n<li>海量数据读写</li>\n<li>对数据高拓展性</li>\n</ol>\n<h2 id=\"NoSql不适用场景\"><a href=\"#NoSql不适用场景\" class=\"headerlink\" title=\"NoSql不适用场景\"></a>NoSql不适用场景</h2><ol>\n<li>需要事务支持</li>\n<li>基于Sql的结构化存储</li>\n</ol>\n<div class=\"note info\">\n            <p>用不着Sql和用了Sql也没用的，可以考虑用NoSql</p>\n          </div>\n\n<h2 id=\"常见NoSql\"><a href=\"#常见NoSql\" class=\"headerlink\" title=\"常见NoSql\"></a>常见NoSql</h2><h3 id=\"Memcache\"><a href=\"#Memcache\" class=\"headerlink\" title=\"Memcache\"></a>Memcache</h3><h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><p><img src=\"/2020/09/14/Redis/Redis.png\"></p>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><p><img src=\"/2020/09/14/Redis/MongoDB.png\"></p>\n<h2 id=\"行式数据库\"><a href=\"#行式数据库\" class=\"headerlink\" title=\"行式数据库\"></a>行式数据库</h2><h2 id=\"列式数据库\"><a href=\"#列式数据库\" class=\"headerlink\" title=\"列式数据库\"></a>列式数据库</h2><h2 id=\"Hbase\"><a href=\"#Hbase\" class=\"headerlink\" title=\"Hbase\"></a>Hbase</h2><h2 id=\"Cassandra\"><a href=\"#Cassandra\" class=\"headerlink\" title=\"Cassandra\"></a>Cassandra</h2><h2 id=\"图数据库\"><a href=\"#图数据库\" class=\"headerlink\" title=\"图数据库\"></a>图数据库</h2><h2 id=\"DB-Engines数据库\"><a href=\"#DB-Engines数据库\" class=\"headerlink\" title=\"DB-Engines数据库\"></a>DB-Engines数据库</h2><h1 id=\"Redis简介\"><a href=\"#Redis简介\" class=\"headerlink\" title=\"Redis简介\"></a>Redis简介</h1><ol>\n<li>开源的key-value型数据库</li>\n<li>支持的value类型很多</li>\n<li>对数据类型支持丰富的操作，且是原子性的</li>\n<li>支持排序</li>\n<li>数据缓存在内存</li>\n<li>持久化：周期性将更新数据存储在硬盘</li>\n<li>master-slave同步</li>\n</ol>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p><img src=\"/2020/09/14/Redis/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png\"></p>\n<h2 id=\"Redis的安装\"><a href=\"#Redis的安装\" class=\"headerlink\" title=\"Redis的安装\"></a>Redis的安装</h2><ol>\n<li>redis.io官网下载</li>\n<li>解压，并准备gcc环境</li>\n<li>make编译</li>\n<li>make install安装</li>\n</ol>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><p>默认安装的二进制路径在/usr/local/bin<br>redis-benchmark：性能测试工具<br>redis-check-aof：修复有问题的aof文件（rdb和aof）<br>redis-check-dump：修复有问题的dump.rdb文件<br>redis-sentinal：redis集群使用<br>redis-server：redis服务器启动命令<br>redis-cli：客户端</p>\n<h2 id=\"Redis的配置文件\"><a href=\"#Redis的配置文件\" class=\"headerlink\" title=\"Redis的配置文件\"></a>Redis的配置文件</h2><p>在文件夹下的redis.conf</p>\n<h2 id=\"redis的保护模式和密码\"><a href=\"#redis的保护模式和密码\" class=\"headerlink\" title=\"redis的保护模式和密码\"></a>redis的保护模式和密码</h2><p>requirepass 「password」<br>连接到redis的时候，使用auth 「password」登陆</p>\n<h2 id=\"Redis启动\"><a href=\"#Redis启动\" class=\"headerlink\" title=\"Redis启动\"></a>Redis启动</h2><h2 id=\"前端启动（不推荐）\"><a href=\"#前端启动（不推荐）\" class=\"headerlink\" title=\"前端启动（不推荐）\"></a>前端启动（不推荐）</h2><p>使用redis-cli启动，关闭窗口后，redis也关闭。</p>\n<h2 id=\"后端启动（推荐）\"><a href=\"#后端启动（推荐）\" class=\"headerlink\" title=\"后端启动（推荐）\"></a>后端启动（推荐）</h2><ol>\n<li>复制redis.conf进/etc/redis下</li>\n<li>修改redis.conf里的daemonize no改为yes</li>\n<li>使用redis-server启动：redis-server /etc/redis.conf （不需要-c）</li>\n<li>之后即可使用redis-cli访问</li>\n<li>如果需要关闭，redis-cli里输入shutdown；或者使用ps杀进程。</li>\n</ol>\n<div class=\"note info\">\n            <p>多端口</p>\n          </div>\n\n<h2 id=\"Redis连接\"><a href=\"#Redis连接\" class=\"headerlink\" title=\"Redis连接\"></a>Redis连接</h2><p>在配置文件，注释bind，允许外部连接。<br>命令行：redis-cli -h host -p port -a password</p>\n<h2 id=\"Redis的一些细节\"><a href=\"#Redis的一些细节\" class=\"headerlink\" title=\"Redis的一些细节\"></a>Redis的一些细节</h2><ol>\n<li>默认端口为6379</li>\n<li>默认16个（0-15）数据库，优先使用0</li>\n<li>所有数据库密码相同（统一管理）</li>\n<li>Redis是单线程+多路IO复用</li>\n</ol>\n<h1 id=\"Redis的数据类型\"><a href=\"#Redis的数据类型\" class=\"headerlink\" title=\"Redis的数据类型\"></a>Redis的数据类型</h1><h2 id=\"Key\"><a href=\"#Key\" class=\"headerlink\" title=\"Key\"></a>Key</h2><p>key * ：查看当前库所有key<br>exists key：判断key是否存在<br>type key：查看key类型<br>del key：删除key<br>unlink key：根据key，选择非阻塞删除（仅仅将key从keyspace中删除，真正的删除后续异步会进行）<br>expire key 10：key 10秒后过期<br>ttl key：key多久过期，-1表示永不过期，-2表示已过期<br>select [id]：切换数据库<br>dbsize：查看当前数据库key的数量<br>flushdb：清空当前库<br>flushall：清空全部库</p>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>二进制安全的：即String可以保存任何数据，比如JPG或者序列化的对象。<br>最基本数据类型，value最大512MB</p>\n<h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><p>set  [key]  [value]<br>get [key]<br>mset [key1]  [value1]…<br>mget [key1]  [value1]…<br>incr [key]：原子性<br>decr [key]：原子性<br>incrby [key]  [num]：指定num步长增加value<br>setex [key]  [expire_time]  [value]<br>msetex<br>setnx [key]<br>msetnx<br>append [key]<br>getrange [key]  [num1]  [num2]<br>getset [key]  [value] :  以旧换新，以新值替换旧值。</p>\n<div class=\"note info\">\n            <p>NX：key不存在，可以把key-value存入<br>XX：key存在时，可以把key-value存入，与NX互斥<br>EX：key超时秒数<br>PX：key超时毫秒数，与EX互斥<br>单线程原子性：指单条指令完成的操作。<br>多线程原子性：其他线程不能打断的操作。<br>mset 原子性，有一个失败全部失败</p>\n          </div>\n\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>简单动态字符串，内部结构实际上类似于Java的ArrayList，采用预分配空间冗余空间，减少内存的频繁分配。内部的字符串实际分配的空间capacity一般要高于实际长度len。<br>字符串小于1M，每次扩容加倍。<br>字符串大于1M，每次增加1M。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>单键多值，redis列表是简单的字符串列表，按顺序插入，可以在头部和尾部都可以插入。<br>底层是双向链表，通过索引下标的操作中间的节点性能会比较差。</p>\n<h2 id=\"常用指令-1\"><a href=\"#常用指令-1\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><p>lpush/rpush [key]  [value1]  [value2]  [value3]<br>lpop/rpop [key]<br>rpoplpush [key1]  [key2]<br>lrange [key]  [start]  [stop]：按照元素下标获取元素。（0是第一个元素，-1是右边第一个元素） 0 到 -1 表示是全部。<br>lindex [key]  [index]<br>llen [key]：获取列表长度<br>linsert [key] before [value]  [new value]<br>lrem [key]  [n]  [value]：从左边删除n个值<br>lset [key]  [index]  [value]：key的index改为value</p>\n<h2 id=\"数据结构-1\"><a href=\"#数据结构-1\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>List为快速链表，quickList。<br>列元素较少的时候，会使用连续的一块内存，结构是zipList（压缩列表）<br>列元素多的时候，会以zipList为单位组成双向链表。<br>既满足了快速插入删除的性能，又不会出现太大的空间冗余。</p>\n<h3 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h3><p>压缩列表ziplist结构本身就是一个连续的内存块，由表头、若干个entry节点和压缩列表尾部标识符zlend组成，通过一系列编码规则，提高内存的利用率，使用于存储整数和短字符串。<br>压缩列表ziplist结构的缺点是：每次插入或删除一个元素时，都需要进行频繁的调用realloc()函数进行内存的扩展或减小，然后进行数据”搬移”，甚至可能引发连锁更新，造成严重效率的损失。</p>\n<h3 id=\"quickList\"><a href=\"#quickList\" class=\"headerlink\" title=\"quickList\"></a>quickList</h3><p>列元素较多的时候，会转变为quickList，quickList是有zipList为单位组成的双向链表。<br>quicklist宏观上是一个双向链表，因此，它具有一个双向链表的有点，进行插入或删除操作时非常方便，虽然复杂度为O(n)，但是不需要内存的复制，提高了效率，而且访问两端元素复杂度为O(1)。<br>quicklist微观上是一片片entry节点，每一片entry节点内存连续且顺序存储，可以通过二分查找以 log2(n)的复杂度进行定位。</p>\n<div class=\"note info\">\n            <p>quickList的存储方式有点像B树</p>\n          </div>\n\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>可以自动排重，String类型的无序集合。底层是value为null的hash表，添加、查找、删除时间复杂度都是O(1)</p>\n<h2 id=\"常用指令-2\"><a href=\"#常用指令-2\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><p>sadd [key]  [value]<br>smembers [key]：查询key的set集合中所有值<br>sismembers [key]  [value]：value是否是key中的值，1是，0否<br>scard [key]：返回key的元素个数<br>srem [key]  [value1]  [value2]….：删除集合中的value<br>spop [key]：随机吐出一个值（会删除）<br>srandmember [key]  [n]：随机从key的集合中取n个值，不会删除<br>smove [key1]  [key2]  [value]：把value从key1移动到key2中<br>sinter [key1]  [key2]：key1和key2的交集<br>sunion [key1]  [key2]：key1和key2的并集<br>sdiff [key1]  [key2]：key1和key2的差集</p>\n<h2 id=\"数据结构-2\"><a href=\"#数据结构-2\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>底层是使用dict字典，字典使用hash来实现的。<br>Java里的HashSet内部使用的是HashMap，只不过所有value指向同一个对象。<br>Redis也是，Set内部使用的是Hash，所有value指向同一个内部值。（？？？）</p>\n<h2 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h2><p>Redis的Hash是一个String类型的field和value的映射表，特别适合存储对象。<br>key 对应了一整个对象的field，field内部的id又对应了相应的value。<br>类似于Java的<code>Map&lt;String,Object&gt;</code><br>Hash的存储特点，取值容易，修改值也容易：通过key：field来获取。</p>\n<h2 id=\"常用指令-3\"><a href=\"#常用指令-3\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><p>hset [key]  [value]<br>hget [key]  [value]<br>hmset [key]  [field1]  [value1]  [field2]  [value2]：批量设置关系<br>hexists [key]  [field]<br>hkeys [key]<br>hincrby [key]  [field]  [num]<br>hsetnx [key]  [field]  [value]</p>\n<h2 id=\"数据结构-3\"><a href=\"#数据结构-3\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>长度较短的时候，使用zipList<br>长度较长的时候，则使用hashTable</p>\n<h2 id=\"Zset（SortedSet）\"><a href=\"#Zset（SortedSet）\" class=\"headerlink\" title=\"Zset（SortedSet）\"></a>Zset（SortedSet）</h2><p>有序的没有重复元素的集合，每个成员关联一个Score，被用来按照最低到最高来排列元素。<br>集合成员是唯一的，但是评分可以有相同的。</p>\n<h2 id=\"常用指令-4\"><a href=\"#常用指令-4\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><p>zadd [key]  [score1]  [value1]  [score2]  [value2]<br>zrange [key]  [start]  [end]  [withscores]：包含值<br>zrangebyscore [key]  [min]  [max]  [withscores]  [limit offset count]：score从min到max(闭区间)的值，按照递增<br>zrevrangebyscore [key]  [max]  [min]  [withscores]  [limit offset count]：同上，递减排序<br>zincrby [key]  [num]  [value]：增加score值<br>zrem [key]  [value]<br>zcount [key]  [min]  [max]<br>zrank [key]  [value]：返回key下value的排名，0为第一</p>\n<h2 id=\"数据结构-4\"><a href=\"#数据结构-4\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>比较特别的数据结构，一方面类似于Java的Map，可以给score修改值，另一方面又类似于TreeSet，可以按照score进行排序。<br>底层使用两个数据结构，一个Hash，关系value和score，一个跳表，用于给value排序。</p>\n<p><img src=\"/2020/09/14/Redis/%E8%B7%B3%E8%A1%A8.png\"></p>\n<h1 id=\"Redis的配置\"><a href=\"#Redis的配置\" class=\"headerlink\" title=\"Redis的配置\"></a>Redis的配置</h1><h2 id=\"UNIT\"><a href=\"#UNIT\" class=\"headerlink\" title=\"UNIT\"></a>UNIT</h2><p>配置大小单位，最小单位是bytes，不支持bit，不区分大小写</p>\n<h2 id=\"INCLUDES\"><a href=\"#INCLUDES\" class=\"headerlink\" title=\"INCLUDES\"></a>INCLUDES</h2><p>包含其他的配置文件</p>\n<h2 id=\"MODULES\"><a href=\"#MODULES\" class=\"headerlink\" title=\"MODULES\"></a>MODULES</h2><h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p>127.0.0.1 限定本地连接</p>\n<h2 id=\"protected-mode\"><a href=\"#protected-mode\" class=\"headerlink\" title=\"protected-mode\"></a>protected-mode</h2><p>保护模式，yes为开启，只能本地连接；no则允许网络连接。</p>\n<h2 id=\"port\"><a href=\"#port\" class=\"headerlink\" title=\"port\"></a>port</h2><p>端口号</p>\n<h2 id=\"tcp-backlog\"><a href=\"#tcp-backlog\" class=\"headerlink\" title=\"tcp-backlog\"></a>tcp-backlog</h2><p>backlog是一个连接队列<br><img src=\"/2020/09/14/Redis/backlog.png\"></p>\n<h2 id=\"timeout\"><a href=\"#timeout\" class=\"headerlink\" title=\"timeout\"></a>timeout</h2><p>超时</p>\n<h2 id=\"tcp-keepalive\"><a href=\"#tcp-keepalive\" class=\"headerlink\" title=\"tcp-keepalive\"></a>tcp-keepalive</h2><h2 id=\"GENERNAL\"><a href=\"#GENERNAL\" class=\"headerlink\" title=\"GENERNAL\"></a>GENERNAL</h2><h2 id=\"daemonize\"><a href=\"#daemonize\" class=\"headerlink\" title=\"daemonize\"></a>daemonize</h2><p>Redis 默认不是以守护进程的⽅式运⾏，可以通过该配置项修改，使⽤yes启动守护进程，即后台启动</p>\n<h2 id=\"pidfile\"><a href=\"#pidfile\" class=\"headerlink\" title=\"pidfile\"></a>pidfile</h2><p>存放pid的位置</p>\n<h2 id=\"loglevel\"><a href=\"#loglevel\" class=\"headerlink\" title=\"loglevel\"></a>loglevel</h2><p>指定⽇志记录级别，Redis共⽀持四个级别：debug、verbose、notice、warning</p>\n<h2 id=\"logfile\"><a href=\"#logfile\" class=\"headerlink\" title=\"logfile\"></a>logfile</h2><p>日志文件路径</p>\n<h2 id=\"databases\"><a href=\"#databases\" class=\"headerlink\" title=\"databases\"></a>databases</h2><p>数据库数量</p>\n<h2 id=\"SECURITY\"><a href=\"#SECURITY\" class=\"headerlink\" title=\"SECURITY\"></a>SECURITY</h2><h2 id=\"requirepass\"><a href=\"#requirepass\" class=\"headerlink\" title=\"requirepass\"></a>requirepass</h2><p>设置密码，使用命令行设置密码是临时的，而在配置文件里设置则是永久的。</p>\n<h2 id=\"LIMITS\"><a href=\"#LIMITS\" class=\"headerlink\" title=\"LIMITS\"></a>LIMITS</h2><h2 id=\"maxclients\"><a href=\"#maxclients\" class=\"headerlink\" title=\"maxclients\"></a>maxclients</h2><p>默认10000个最大连接数</p>\n<h2 id=\"maxmemory（重要）\"><a href=\"#maxmemory（重要）\" class=\"headerlink\" title=\"maxmemory（重要）\"></a>maxmemory（重要）</h2><p>必须设置，否则内存占满，会使得服务器死机。<br>一旦达到最大值，redis会按照规则移除数据。<br>最大可以设置512GB</p>\n<h2 id=\"maxmemory-policy（淘汰机制）\"><a href=\"#maxmemory-policy（淘汰机制）\" class=\"headerlink\" title=\"maxmemory-policy（淘汰机制）\"></a>maxmemory-policy（淘汰机制）</h2><p>移除规则。<br>volatile-lru：从已设置过期时间的数据集中挑选最近最少使⽤的数据淘汰<br>volatile-lfu：从已设置过期的Keys中，删除⼀段时间内使⽤次数最少使⽤ 的key<br>volatile-ttl：从已设置过期时间的数据集中挑选最近将要过期的数据进⾏淘汰<br>volatile-random：从已设置过期时间的数据集中随机选择数据淘汰<br>allkeys-lru：从数据集中挑选最近最少使⽤的数据淘汰<br>allkeys-lfu：从所有的keys中，删除⼀段时间内使⽤次数最少的key<br>allkeys-random：从数据集中随机选择数据淘汰<br>no-enviction（驱逐）：禁⽌驱逐数据（不采⽤任何淘汰策略。默认即此配置），内存不⾜时，针<br>对写操作，返回错误信息</p>\n<h1 id=\"Redis发布和订阅\"><a href=\"#Redis发布和订阅\" class=\"headerlink\" title=\"Redis发布和订阅\"></a>Redis发布和订阅</h1><p>发布订阅是一种消息通信模式，发送者（pub）发送，订阅者（sub）接收。<br>Redis客户端可以订阅任意数量的频道。</p>\n<h2 id=\"发布和订阅命令\"><a href=\"#发布和订阅命令\" class=\"headerlink\" title=\"发布和订阅命令\"></a>发布和订阅命令</h2><h2 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h2><p>publish channel hello</p>\n<h2 id=\"订阅\"><a href=\"#订阅\" class=\"headerlink\" title=\"订阅\"></a>订阅</h2><p>subscribe channel</p>\n<div class=\"note info\">\n            <p>发布的消息没有持久化，所以只能收到订阅后发布的消息。</p>\n          </div>\n\n<h1 id=\"Redis6的新数据类型\"><a href=\"#Redis6的新数据类型\" class=\"headerlink\" title=\"Redis6的新数据类型\"></a>Redis6的新数据类型</h1><h2 id=\"Bitmaps\"><a href=\"#Bitmaps\" class=\"headerlink\" title=\"Bitmaps\"></a>Bitmaps</h2><p>计算机数据都是以二进制存储的，如果合理地操作位，可以提高内存使用率和开发效率。</p>\n<ol>\n<li>Bitmaps本身不是数据结构，它就是个字符串（key-value），但是可以对字符串的位进行操作。</li>\n<li>单独提供了一系列命令，可以把Bitmaps想象成一个以位为单位的数组，每个单元存0或1，下标即位Bitmaps的偏移量，默认偏移量从0开始。</li>\n</ol>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>setbit [key]  [offset]  [value]<br>getbit [key]  [offset1]<br>bitcount [key]  [start]  [end]：统计bit为1的数量。<br>bitop [and/or/not/xor]  [destkey]  [key1]  [key2]…：将多个Bitmaps执行操作，并保存在destkey中。</p>\n<div class=\"note info\">\n            <p>setbit的id如果以特定数字开头，最好将id减去这个数字开头，以防偏移量过大，导致的资源浪费和性能慢。<br>初始化Bitmaps，如果偏移量过大，初始化会很慢，会导致Redis堵塞。</p>\n          </div>\n\n<h2 id=\"与Set的比较\"><a href=\"#与Set的比较\" class=\"headerlink\" title=\"与Set的比较\"></a>与Set的比较</h2><p>Set一个单位占64位，而Bitmaps只占1位，同样大的数据量，Bitmaps可以大大节省内存空间。并且随着时间推移，Bitmaps的内存优势会无限放大。<br>但是，如果访问数据量太小，Bitmaps会有大量0占用空间，从而浪费了很多内存空间和效率，此时不适合使用Bitmaps。</p>\n<h2 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h2><p>工作中，会遇到各种统计相关的功能需求。PageView可以使用incr或incrby来实现，但是如果要针对特殊用户UniqueVisitor、独立IP数、搜索记录等去重计数等基数问题，则会十分麻烦。<br>传统解决方案：</p>\n<ol>\n<li>保存在mysql，使用discount或者count来计算</li>\n<li>使用Redis的hash、set、bitmaps来处理</li>\n</ol>\n<p>虽然这种方式处理精准，但是随着时间推移，数据量会越来越大，会非常不切实际。<br>因此Redis提出了降低精度来平衡空间的算法，HyperLogLog，用做基数统计。<br>只用12kb，即可计算出2^64个不同元素的基数。</p>\n<div class=\"note info\">\n            <p>求集合不同元素的个数，称为基数问题。<br>{1,3,5,7,5,7,8}，则基数集为{1,3,5,7,8}，5个不重复的数，基数为5。</p>\n          </div>\n\n<div class=\"note info\">\n            <p>但是HyperLogLog只能根据输入元素来计算，不能返回输入的元素。</p>\n          </div>\n\n<h2 id=\"常用指令-5\"><a href=\"#常用指令-5\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><p>pfadd [key]  [element1]  [element2]…<br>pfcount [key]<br>pfmerge [desykey]  [sourcekey1]  [sourcekey2]…：把一个或多个HLL合并，然后存储在新的HLL里。</p>\n<h2 id=\"数据结构（？）\"><a href=\"#数据结构（？）\" class=\"headerlink\" title=\"数据结构（？）\"></a>数据结构（？）</h2><h2 id=\"Geospatial\"><a href=\"#Geospatial\" class=\"headerlink\" title=\"Geospatial\"></a>Geospatial</h2><p>增加了GEO类型，地理信息的缩写，该元素是一个二维坐标，在地图上就经纬度。</p>\n<h2 id=\"常用命令-1\"><a href=\"#常用命令-1\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>geoadd [key]  [longitude]  [latitude]  [member]<br>geopos [key]  [member1]  [member2]…<br>geodist [key]  [member1]  [member2]  [unit].：获取两个位置的直线距路（m、km、mi、ft）<br>georadius [key]  [longitude]  [latitude]  [radis]  [unit]：获取给定经纬度为中心，找出某一半径内的元素。</p>\n<h1 id=\"Jedis\"><a href=\"#Jedis\" class=\"headerlink\" title=\"Jedis\"></a>Jedis</h1><h2 id=\"使用Jedis控制Redis\"><a href=\"#使用Jedis控制Redis\" class=\"headerlink\" title=\"使用Jedis控制Redis\"></a>使用Jedis控制Redis</h2><ol>\n<li>导包</li>\n<li>创建Jedis对象</li>\n<li>执行操作</li>\n</ol>\n<div class=\"note info\">\n            <p>如果出现连接超时的错误，先看网络是否畅通、服务是否开启，然后再看保护模式是否关闭，再检查服务器的防火墙设置。</p>\n          </div>\n\n<h2 id=\"Jedis方法\"><a href=\"#Jedis方法\" class=\"headerlink\" title=\"Jedis方法\"></a>Jedis方法</h2><p>Redis的命令就是一个一个方法，操作和Redis基本无差。</p>\n<h1 id=\"Redission\"><a href=\"#Redission\" class=\"headerlink\" title=\"Redission\"></a>Redission</h1><h1 id=\"Redis练习\"><a href=\"#Redis练习\" class=\"headerlink\" title=\"Redis练习\"></a>Redis练习</h1><h2 id=\"手机验证码\"><a href=\"#手机验证码\" class=\"headerlink\" title=\"手机验证码\"></a>手机验证码</h2><ol>\n<li>生成6位验证码</li>\n<li>过期时间15分钟</li>\n<li>每个手机每天三次机会</li>\n</ol>\n<h1 id=\"SpringBoot整合\"><a href=\"#SpringBoot整合\" class=\"headerlink\" title=\"SpringBoot整合\"></a>SpringBoot整合</h1><h2 id=\"导包\"><a href=\"#导包\" class=\"headerlink\" title=\"导包\"></a>导包</h2><p><img src=\"/2020/09/14/Redis/springboot-redis%E5%AF%BC%E5%8C%85.png\"><br>必要时，可以添加序列化用的包<br><img src=\"/2020/09/14/Redis/springboot-redis%E5%AF%BC%E5%8C%852.png\"></p>\n<h2 id=\"properties或者yml文件中，配置redis的配置\"><a href=\"#properties或者yml文件中，配置redis的配置\" class=\"headerlink\" title=\"properties或者yml文件中，配置redis的配置\"></a>properties或者yml文件中，配置redis的配置</h2><p><img src=\"/2020/09/14/Redis/redis%E9%85%8D%E7%BD%AE.png\"></p>\n<h2 id=\"添加redis配置类\"><a href=\"#添加redis配置类\" class=\"headerlink\" title=\"添加redis配置类\"></a>添加redis配置类</h2><h1 id=\"Redis事务\"><a href=\"#Redis事务\" class=\"headerlink\" title=\"Redis事务\"></a>Redis事务</h1><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按照顺序地执行。事务执行的过程，不会受其他客户端操作的影响。<br>串联多个命令，防止其他命令插队！</p>\n<h2 id=\"Multi、Exec、Discard\"><a href=\"#Multi、Exec、Discard\" class=\"headerlink\" title=\"Multi、Exec、Discard\"></a>Multi、Exec、Discard</h2><ol>\n<li>multi<br>组队，将之后的命令依次放到队列当中</li>\n<li>exec<br>执行，将组队内的命令真正执行</li>\n<li>discard<br>丢弃，放弃组队，不执行命令</li>\n</ol>\n<div class=\"note info\">\n            <ol><li>组队阶段命令如果有任何一个有错误，执行时就会直接discard</li><li>组织阶段命令没有错误，但是执行时出现错误，成功的部分会被执行，仅错误的命令不会执行。</li></ol>\n          </div>\n\n<h2 id=\"为什么需要事务\"><a href=\"#为什么需要事务\" class=\"headerlink\" title=\"为什么需要事务\"></a>为什么需要事务</h2><p>多个用户同时操作Redis内，要防止其他用户命令操作影响。</p>\n<h2 id=\"事务冲突问题\"><a href=\"#事务冲突问题\" class=\"headerlink\" title=\"事务冲突问题\"></a>事务冲突问题</h2><h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>先上锁，操作完成后再解锁。<br>实际例子：表锁、行锁、读锁、写锁<br>优点：完全稳定<br>缺点：效率低下</p>\n<h3 id=\"乐观锁（CAS）\"><a href=\"#乐观锁（CAS）\" class=\"headerlink\" title=\"乐观锁（CAS）\"></a>乐观锁（CAS）</h3><p>先不上锁，通过版本号来执行，每次更新操作会更新一个版本号，执行操作前，检查版本号（即此期间别人有没有更新这个数据。如果有更新，则不继续执行。<br>Redis使用的是CAS机制。<br>实际例子：多读的应用类型，提高吞吐量。抢票就是典型的乐观锁，一堆人抢票，最终只有一个人抢到。</p>\n<h4 id=\"watch-key-keys…\"><a href=\"#watch-key-keys…\" class=\"headerlink\" title=\"watch key [keys…]\"></a>watch key [keys…]</h4><p>监视key，如果key在执行exec前被修改，则取消事务（discard）。<br>是一种乐观锁</p>\n<h2 id=\"Redis事务的三个特性\"><a href=\"#Redis事务的三个特性\" class=\"headerlink\" title=\"Redis事务的三个特性\"></a>Redis事务的三个特性</h2><h2 id=\"单独的隔离操作\"><a href=\"#单独的隔离操作\" class=\"headerlink\" title=\"单独的隔离操作\"></a>单独的隔离操作</h2><p>队列的命令，按照序列化顺序地执行，事务执行过程，不会被其他客户端影响。</p>\n<h2 id=\"事务没有隔离级别\"><a href=\"#事务没有隔离级别\" class=\"headerlink\" title=\"事务没有隔离级别\"></a>事务没有隔离级别</h2><p>各个事务没有提交前，都不会被执行。</p>\n<h2 id=\"事务没有原子性\"><a href=\"#事务没有原子性\" class=\"headerlink\" title=\"事务没有原子性\"></a>事务没有原子性</h2><p>事务的队列中命令，可以部分被执行，没有回滚。</p>\n<h2 id=\"应用案例：秒杀\"><a href=\"#应用案例：秒杀\" class=\"headerlink\" title=\"应用案例：秒杀\"></a>应用案例：秒杀</h2><h2 id=\"基础框架\"><a href=\"#基础框架\" class=\"headerlink\" title=\"基础框架\"></a>基础框架</h2><ol>\n<li>判空（userId和productId）</li>\n<li>连接redis</li>\n<li>拼接key，等到库存key和秒杀成功的用户key</li>\n<li>判断库存是否存在，没存在，则说明秒杀未开始</li>\n<li>判断用户是否已经成功秒杀过（不允许再次成功购买）</li>\n<li>获取库存数量，判断数量是否小于1，小于1，则结束秒杀</li>\n<li>执行秒杀（库存-1，将购买成功的用户放入秒杀成功用户key）</li>\n<li>返回</li>\n</ol>\n<h2 id=\"叠加事务\"><a href=\"#叠加事务\" class=\"headerlink\" title=\"叠加事务\"></a>叠加事务</h2><p>linux工具：ab（httpd-tools）</p>\n<ol>\n<li>连接超时问题<br>相应不了过多的连接请求，使用连接池来处理。</li>\n<li>超卖问题<br>商品秒杀完了，但是还能继续卖，使用乐观锁来处理。<br>1）监视库存<br>2）组队<br>3）执行</li>\n<li>乐观锁导致库存遗留问题<br>哪怕有多个用户同时抢到商品，但是因为乐观锁，导致版本不一致，导致抢到的用户都无法进行购买，可以利用lua脚本（操作原子性）或者分布式锁来处理。</li>\n</ol>\n<h1 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h1><h2 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h2><p>每隔一段时间，定期将快照（snapshot）保存到硬盘。<br>优点：<br>1、快照保存数据极快，还原数据极快<br>2、适合大规模数据恢复<br>3、对数据完整性和一致性要求不高<br>4、节约磁盘空间<br>适⽤于容灾备份<br>缺点：<br>1、⼩内存机器不适合使⽤（内存的数据要被fork，需要2倍的膨胀性）<br>2、RDB机制符合要求就会照快照，可能会丢失数据<br>3、写时复制技术，数据庞大的时候很消耗性能，在一些毫秒级操作无法相应用户<br>快照条件：<br>1、服务器正常关闭时 ./bin/redis-cli shutdown<br>2、key满⾜持久化策略时，会进⾏快照</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>在redis.conf的，SNAPSHOTTING中<br>有关于持久化文件的文件名；保存的路径名；还有持久化策略的配置。<br><img src=\"/2020/09/14/Redis/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5.png\"><br><img src=\"/2020/09/14/Redis/%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE.png\"></p>\n<div class=\"note info\">\n            <p>持久化策略中，比如设置60s 操作10次，前10次操作完成后，会先对前10次进行持久化，从第11次开始，重新计时60s，执行后面的10次操作。</p>\n          </div>\n<h3 id=\"stop-writes-on-bgsave-error配置\"><a href=\"#stop-writes-on-bgsave-error配置\" class=\"headerlink\" title=\"stop-writes-on-bgsave-error配置\"></a>stop-writes-on-bgsave-error配置</h3><p>Redis无法写入磁盘时，直接关闭Redis写操作，默认yes开启。</p>\n<h3 id=\"rdbcompression\"><a href=\"#rdbcompression\" class=\"headerlink\" title=\"rdbcompression\"></a>rdbcompression</h3><p>对于存储在硬盘的快照，可以执行LZF算法(?)进行压缩。<br>会消耗CPU，默认是yes。</p>\n<h3 id=\"rdbchecksum\"><a href=\"#rdbchecksum\" class=\"headerlink\" title=\"rdbchecksum\"></a>rdbchecksum</h3><p>检查完整性，存储快照前，使用CRC64算法来检查数据。<br>大约消耗10%的性能，默认是yes，没有需要可以关闭。</p>\n<h2 id=\"save和bgsave命令的区别\"><a href=\"#save和bgsave命令的区别\" class=\"headerlink\" title=\"save和bgsave命令的区别\"></a>save和bgsave命令的区别</h2><p>save：只处理保存，执行的时候阻塞其他所有操作，作为手动处理，不常用，性能较差。<br>bgsave：在后台异步进行保存，redis同时可以相应用户请求。</p>\n<h2 id=\"flushall命令\"><a href=\"#flushall命令\" class=\"headerlink\" title=\"flushall命令\"></a>flushall命令</h2><p>执行flushall，也会产生dump.rdb文件，但是里面是空的。</p>\n<h2 id=\"RDB的备份\"><a href=\"#RDB的备份\" class=\"headerlink\" title=\"RDB的备份\"></a>RDB的备份</h2><p>Redis会fork一个子进程来进行持久化，把数据先写到临时文件中，持久化结束以后，再把临时文件替换上次持久化好的文件。<br>主进程是不进行任何IO操作的，确保极高的性能，但是可能最后一次持久化的数据可能丢失（缓冲区写失败）。</p>\n<div class=\"note info\">\n            <p>临时文件作为缓冲区，防止写入一半时候，程序被杀或者意外崩溃，导致原先保存好的数据丢失。</p>\n          </div>\n<h3 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork\"></a>fork</h3><p>复制一个和当前进程一摸一样的进程。（操作系统提供的fork指令）</p>\n<div class=\"note info\">\n            <p>写时复制技术，linux出于效率，引入了。</p>\n          </div>\n<h2 id=\"RDB的恢复\"><a href=\"#RDB的恢复\" class=\"headerlink\" title=\"RDB的恢复\"></a>RDB的恢复</h2><p>直接把之前的RDB文件，替换到当前的RDB即可。<br>redis会自动读取RDB文件。</p>\n<h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2><p>Append Only FIle，以日志形式来执行写操作（只记录写，不记录读），只许追加，不允许修改。<br>Redis启动之前，会根据AOF内容从前到后执行一次数据恢复工作。<br>aof文件和rdb文件路径相同。<br>优点：</p>\n<ol>\n<li>备份机制更健全、丢失数据概率更低</li>\n<li>可读的日志文本，可以减少误操作<br>缺点：</li>\n<li>比RDB占用更多的空间</li>\n<li>备份和恢复速度更慢</li>\n<li>每次读写同步，数据大的时候有性能压力</li>\n<li>存在个别bug，造成不能恢复</li>\n</ol>\n<h2 id=\"AOF持久化流程\"><a href=\"#AOF持久化流程\" class=\"headerlink\" title=\"AOF持久化流程\"></a>AOF持久化流程</h2><ol>\n<li>客户端的请求写命令被append追加到aof文件中</li>\n<li>aof_buf根据持久化策略将sync同步到磁盘的aof中</li>\n<li>aof文件大小超过重写基准或者手动重写，重写压缩aof</li>\n<li>Redis启动时会根据aof文件恢复内容<h2 id=\"AOF默认不开启\"><a href=\"#AOF默认不开启\" class=\"headerlink\" title=\"AOF默认不开启\"></a>AOF默认不开启</h2><h2 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"appendonly\"><a href=\"#appendonly\" class=\"headerlink\" title=\"appendonly\"></a>appendonly</h3>默认不开启，开启后面添加yes<br>开启了后，会读取aof，而不会读取rdb<h3 id=\"appendfilename\"><a href=\"#appendfilename\" class=\"headerlink\" title=\"appendfilename\"></a>appendfilename</h3>aof文件名<h3 id=\"appendfsync\"><a href=\"#appendfsync\" class=\"headerlink\" title=\"appendfsync\"></a>appendfsync</h3>同步配置：<br>always：始终同步，每次操作都会被记录在redis<br>everysec：每秒同步，每秒记录日志一次，宕机则最后一秒的内容无法保存<br>no：不主动同步，交给系统来处理<h3 id=\"rewrite\"><a href=\"#rewrite\" class=\"headerlink\" title=\"rewrite\"></a>rewrite</h3>AOF文件越来越大，当AOF超过一定阈值的时候，保留可恢复数据的最小指令集。可以使用bgwriteaof<br>原理：fork出一个新进程将文件重写，redis4.0之后就是rdb快照，以二进制形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。<br>重写条件：aof是上次rewrite后大小的一倍，且大于64M时，会进行重写。<br>重写流程：</li>\n<li>bgwriteaof触发重写，如果当前有bgsave或者bgwriteaof，则阻塞等待命令。</li>\n<li>主进程fork一个子进程执行重写，保证主进程不会阻塞。</li>\n<li>子进程遍历redis内存中数据到临时文件，同时写入到aof_buf和aof_rewrite_buf，保证aof文件完整和之后新的数据修改不会丢失。</li>\n<li>子进程写完aof文件后，向主进程发信息，父进程更新统计信息；父进程再将aof_rewrite_buf的内容添加到aof中。</li>\n<li>使用新aof文件替换旧aof文件。<h3 id=\"no-appendfsync-on-rewrite\"><a href=\"#no-appendfsync-on-rewrite\" class=\"headerlink\" title=\"no-appendfsync-on-rewrite\"></a>no-appendfsync-on-rewrite</h3>yes：不写入aof，只写入缓存，用户请求不会阻塞，宕机则丢失该缓存数据<br>no：向硬盘里写入，可能发生阻塞<h3 id=\"auto-aof-rewrite-percentage\"><a href=\"#auto-aof-rewrite-percentage\" class=\"headerlink\" title=\"auto-aof-rewrite-percentage\"></a>auto-aof-rewrite-percentage</h3>设定重写基准值<h3 id=\"auto-aof-rewrite-min-size\"><a href=\"#auto-aof-rewrite-min-size\" class=\"headerlink\" title=\"auto-aof-rewrite-min-size\"></a>auto-aof-rewrite-min-size</h3>重写基准值，最小文件64M时才是重写<h2 id=\"AOF备份和恢复\"><a href=\"#AOF备份和恢复\" class=\"headerlink\" title=\"AOF备份和恢复\"></a>AOF备份和恢复</h2>跟RDB一样。<h3 id=\"异常恢复\"><a href=\"#异常恢复\" class=\"headerlink\" title=\"异常恢复\"></a>异常恢复</h3>遇到AOF损坏，使用/usr/local/bin/redis-check-aof–fix appendonly.aof 进行恢复</li>\n</ol>\n<div class=\"note info\">\n            <p>官方建议，两个都启用。<br>如果对数据不敏感，可以单独使用RDB<br>不建议单独使用AOF，因为存在部分bug<br>如果只做纯内存缓存，可以不使用持久化</p>\n          </div>\n\n<h1 id=\"Redis的主从复制\"><a href=\"#Redis的主从复制\" class=\"headerlink\" title=\"Redis的主从复制\"></a>Redis的主从复制</h1><h2 id=\"一主两仆\"><a href=\"#一主两仆\" class=\"headerlink\" title=\"一主两仆\"></a>一主两仆</h2><p>主机数据更新后，自动根据策略把数据复制到从机上。<br>优点：</p>\n<ol>\n<li>读写分离，分担压力（写为主、读为从）</li>\n<li>容灾快速恢复</li>\n</ol>\n<h2 id=\"如何配置\"><a href=\"#如何配置\" class=\"headerlink\" title=\"如何配置\"></a>如何配置</h2><ol>\n<li>创建一个文件夹</li>\n<li>复制redis.conf到文件夹</li>\n<li>新建三个redis-xxx.conf文件（一主两从）</li>\n<li>三个配置文件分别include文件夹的redis.conf，配置pidfile、port、dbfilename</li>\n<li>启动这三个redis（info replication查看主从信息）</li>\n<li>在两个从库上使用salveof  [ip]  [port] （也可以在配置中配置，永久保存）</li>\n</ol>\n<div class=\"note info\">\n            <p>如果从服务器挂掉，重新启动后，并不会变成从服务器，而需要重新配置。<br>主服务器挂掉，重启后，还是保持主从关系。</p>\n          </div>\n\n<h2 id=\"复制原理\"><a href=\"#复制原理\" class=\"headerlink\" title=\"复制原理\"></a>复制原理</h2><ol>\n<li>从服务器连接到主服务器后，向主服务器发送同步消息（sync命令）</li>\n<li>主服务器接收从服务器的同步消息，先把主服务器的数据持久化，再把持久化的rdb发送给从服务器，从服务器拿到rdb后，进行读取（全量复制）</li>\n<li>每次主服务器写操作后，都会将数据同步到从服务器（增量复制）</li>\n</ol>\n<h2 id=\"全量复制\"><a href=\"#全量复制\" class=\"headerlink\" title=\"全量复制\"></a>全量复制</h2><p>从服务器接收主数据库文件数据后，持久化后再读取到内存。<br>用于初次复制或其它无法进行部分复制的情况，将主节点中的所有数据都发送给从节点。<br>以下两种情况会发生全量复制：</p>\n<ol>\n<li>从服务器首次启动或者重启</li>\n<li>从服务器掉线重连<h2 id=\"增量复制\"><a href=\"#增量复制\" class=\"headerlink\" title=\"增量复制\"></a>增量复制</h2>主服务器继续将新的修改命令依次传给从服务器，完成同步</li>\n</ol>\n<h2 id=\"薪火相传\"><a href=\"#薪火相传\" class=\"headerlink\" title=\"薪火相传\"></a>薪火相传</h2><p>主服务器具有从服务器，从服务器再拥有从服务器，依次循环。</p>\n<h2 id=\"反客为主\"><a href=\"#反客为主\" class=\"headerlink\" title=\"反客为主\"></a>反客为主</h2><p>主服务器挂掉后，其中某个从服务器可以立刻成为主服务器。<br>命令：salveof no one</p>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><p>自动的反客为主，后台检测主服务器是否故障。</p>\n<h2 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>自定义文件夹，创建sentinel.conf文件（名字必须是这个）<br>添加内容：sentinel monitor mymaster [ip]  [port]  [num]（mymaster是一个名称，num是至少有多少个哨兵同意迁移）</p>\n<h2 id=\"启动哨兵\"><a href=\"#启动哨兵\" class=\"headerlink\" title=\"启动哨兵\"></a>启动哨兵</h2><p>redis-sentinel sentinel-conf</p>\n<h2 id=\"哪个从服务器成为主机\"><a href=\"#哪个从服务器成为主机\" class=\"headerlink\" title=\"哪个从服务器成为主机\"></a>哪个从服务器成为主机</h2><p>根据配置文件中的salve-priority（replica-priority），值最小的作为主机。<br>主机挂掉重启后，就会变为从机。</p>\n<ol>\n<li>选择salve-priority（replica-priority）最小的</li>\n<li>选择偏移量最大的（指根据原数据相比内容相应最全的）</li>\n<li>选择runid最小的（redis启动时，随机生成40位的runid）<h2 id=\"复制延迟\"><a href=\"#复制延迟\" class=\"headerlink\" title=\"复制延迟\"></a>复制延迟</h2>所有写都是在master上，再同步更新到slave上的，所以同步过程会有延迟，系统繁忙时，延迟则会严重；salve机器越多，延迟则会越明显。<h2 id=\"Java实现\"><a href=\"#Java实现\" class=\"headerlink\" title=\"Java实现\"></a>Java实现</h2>JedisSentinelPool<br>在里面添加 ip: port<br><img src=\"/2020/09/14/Redis/JedisSentinelPool.png\"></li>\n</ol>\n<h1 id=\"Redis集群\"><a href=\"#Redis集群\" class=\"headerlink\" title=\"Redis集群\"></a>Redis集群</h1><p>redis容量不够，该如何处理<br>redis并发写操作，该如何分摊<br>因为引出了Redis集群：</p>\n<ol>\n<li>实现了对Redis的水平扩充，N个Redis节点，每个节点存储总数据的1/N</li>\n<li>通过分区（partition）来提供程序的可用性（availability），即部分服务器挂掉后，仍然可以部分使用。<h2 id=\"无中心化集群\"><a href=\"#无中心化集群\" class=\"headerlink\" title=\"无中心化集群\"></a>无中心化集群</h2>任意服务器都是集群入口，将访问可以互相传递，找到所需要的操作。<h2 id=\"配置-3\"><a href=\"#配置-3\" class=\"headerlink\" title=\"配置\"></a>配置</h2>关闭appendonly<br>开启daemonize<br>pidfile<br>dbfilename<br>port<br>cluster-enabled yes 集群模式<br>cluster-config-file nodes-port.conf<br>cluster-node-timeout 15000 节点失联时间<br><img src=\"/2020/09/14/Redis/%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE.png\"><h2 id=\"启动这些Redis，并配置为集群\"><a href=\"#启动这些Redis，并配置为集群\" class=\"headerlink\" title=\"启动这些Redis，并配置为集群\"></a>启动这些Redis，并配置为集群</h2>启动redis，并确保nodes-xxx.conf文件生成<br>然后进入 cd /opt/redis-xxx/src<br>使用redis-cli –cluster create –cluster-replicas 1 ip1:port1 ip2:port2 …. ：–cluster-replicas 1 表示每1个主节点，创建一个从节点。分配原则是尽量主从不在一个IP地址上，且主服务器也是在不同ip。</li>\n</ol>\n<h2 id=\"如何连接\"><a href=\"#如何连接\" class=\"headerlink\" title=\"如何连接\"></a>如何连接</h2><p>redis-cli -c -p 6379<br>-c : 采用集群连接，数据会自动切换到相应写主机。</p>\n<h2 id=\"slots\"><a href=\"#slots\" class=\"headerlink\" title=\"slots\"></a>slots</h2><p>一个Redis集群有16384个slot，每个健都属于这16384中的一个。<br>集群使用CRC16(key)%16384来计算属于哪个slot，CRC16：key和CRC16的校验和</p>\n<h2 id=\"同时添加多个key\"><a href=\"#同时添加多个key\" class=\"headerlink\" title=\"同时添加多个key\"></a>同时添加多个key</h2><p>mset name{user} tian age{user} 18 : 根据user作为计算CRC16校验和的slot来添加</p>\n<h2 id=\"查看key对应的slot\"><a href=\"#查看key对应的slot\" class=\"headerlink\" title=\"查看key对应的slot\"></a>查看key对应的slot</h2><p>cluster keyslot key</p>\n<h2 id=\"查看slot里的key\"><a href=\"#查看slot里的key\" class=\"headerlink\" title=\"查看slot里的key\"></a>查看slot里的key</h2><p>要到对应的服务器中，使用cluster countkeysinslot num</p>\n<h2 id=\"故障恢复\"><a href=\"#故障恢复\" class=\"headerlink\" title=\"故障恢复\"></a>故障恢复</h2><ol>\n<li>如果主节点下线，从立刻成为主服务器，原先的主节点上线后，自动成为从节点。（超时15秒，视为下线）</li>\n<li>如果主从都挂掉，并且cluster-require-full-coverage为yes，那整个集群都会挂掉；如果为no，只有该主从对应的slot内容不能使用，其他可以使用。</li>\n</ol>\n<h2 id=\"集群Jedis开发\"><a href=\"#集群Jedis开发\" class=\"headerlink\" title=\"集群Jedis开发\"></a>集群Jedis开发</h2><p>用HostAndPort或者Set都可以</p>\n<h2 id=\"Redis集群的缺点\"><a href=\"#Redis集群的缺点\" class=\"headerlink\" title=\"Redis集群的缺点\"></a>Redis集群的缺点</h2><p>多键操作不被允许<br>多键Redis事务不被支持，lua脚本也不被支持<br>由于集群方案出现较晚，很多公司已经采用其他集群方案，要迁移至cluster的复杂度较高。<br><img src=\"/2020/09/14/Redis/JedisCluster.png\"></p>\n<h1 id=\"Redis相关问题\"><a href=\"#Redis相关问题\" class=\"headerlink\" title=\"Redis相关问题\"></a>Redis相关问题</h1><h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><h1 id=\"Redisson\"><a href=\"#Redisson\" class=\"headerlink\" title=\"Redisson\"></a>Redisson</h1><p>redisson 是基于redis的扩展库，使得redis除了应用于缓存以外，还能做队列等数据结构，直接使用的分布式锁，以及人物调度器等。</p>\n<h2 id=\"使用1-SpringBoot整合Redisson\"><a href=\"#使用1-SpringBoot整合Redisson\" class=\"headerlink\" title=\"使用1: SpringBoot整合Redisson\"></a>使用1: SpringBoot整合Redisson</h2><h2 id=\"导包-1\"><a href=\"#导包-1\" class=\"headerlink\" title=\"导包\"></a>导包</h2><p>spring-data-redis<br>redisson-spring-boot-starter</p>\n<h2 id=\"写yml配置\"><a href=\"#写yml配置\" class=\"headerlink\" title=\"写yml配置\"></a>写yml配置</h2><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">   <span class=\"attr\">redisson:</span> </span><br><span class=\"line\">      <span class=\"attr\">file:</span> <span class=\"string\">classpath:redisson.yaml</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span> <span class=\"string\">|</span></span><br><span class=\"line\">        <span class=\"attr\">clusterServersConfig:</span></span><br><span class=\"line\">          <span class=\"attr\">idleConnectionTimeout:</span> <span class=\"number\">10000</span></span><br><span class=\"line\">          <span class=\"attr\">connectTimeout:</span> <span class=\"number\">10000</span></span><br><span class=\"line\">          <span class=\"attr\">timeout:</span> <span class=\"number\">3000</span></span><br><span class=\"line\">          <span class=\"attr\">retryAttempts:</span> <span class=\"number\">3</span></span><br><span class=\"line\">          <span class=\"attr\">retryInterval:</span> <span class=\"number\">1500</span></span><br><span class=\"line\">          <span class=\"attr\">failedSlaveReconnectionInterval:</span> <span class=\"number\">3000</span></span><br><span class=\"line\">          <span class=\"attr\">failedSlaveCheckInterval:</span> <span class=\"number\">60000</span></span><br><span class=\"line\">          <span class=\"attr\">password:</span> <span class=\"literal\">null</span></span><br><span class=\"line\">          <span class=\"attr\">subscriptionsPerConnection:</span> <span class=\"number\">5</span></span><br><span class=\"line\">          <span class=\"attr\">clientName:</span> <span class=\"literal\">null</span></span><br><span class=\"line\">          <span class=\"attr\">loadBalancer:</span> <span class=\"type\">!&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt;</span> &#123;&#125;</span><br><span class=\"line\">          <span class=\"attr\">subscriptionConnectionMinimumIdleSize:</span> <span class=\"number\">1</span></span><br><span class=\"line\">          <span class=\"attr\">subscriptionConnectionPoolSize:</span> <span class=\"number\">50</span></span><br><span class=\"line\">          <span class=\"attr\">slaveConnectionMinimumIdleSize:</span> <span class=\"number\">24</span></span><br><span class=\"line\">          <span class=\"attr\">slaveConnectionPoolSize:</span> <span class=\"number\">64</span></span><br><span class=\"line\">          <span class=\"attr\">masterConnectionMinimumIdleSize:</span> <span class=\"number\">24</span></span><br><span class=\"line\">          <span class=\"attr\">masterConnectionPoolSize:</span> <span class=\"number\">64</span></span><br><span class=\"line\">          <span class=\"attr\">readMode:</span> <span class=\"string\">&quot;SLAVE&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">subscriptionMode:</span> <span class=\"string\">&quot;SLAVE&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">nodeAddresses:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">&quot;redis://127.0.0.1:7004&quot;</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">&quot;redis://127.0.0.1:7001&quot;</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">&quot;redis://127.0.0.1:7000&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">scanInterval:</span> <span class=\"number\">1000</span></span><br><span class=\"line\">          <span class=\"attr\">pingConnectionInterval:</span> <span class=\"number\">0</span></span><br><span class=\"line\">          <span class=\"attr\">keepAlive:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">          <span class=\"attr\">tcpNoDelay:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"attr\">threads:</span> <span class=\"number\">16</span></span><br><span class=\"line\">        <span class=\"attr\">nettyThreads:</span> <span class=\"number\">32</span></span><br><span class=\"line\">        <span class=\"attr\">codec:</span> <span class=\"type\">!&lt;org.redisson.codec.MarshallingCodec&gt;</span> &#123;&#125;</span><br><span class=\"line\">        <span class=\"attr\">transportMode:</span> <span class=\"string\">&quot;NIO&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"写配置类\"><a href=\"#写配置类\" class=\"headerlink\" title=\"写配置类\"></a>写配置类</h2><p>RedissconProperties.class<br>RedissonAutoConfigurationCustomizer<br>RedissonAutoConfiguration</p>\n","categories":["数据库"],"tags":["NoSQL","Redis"]},{"title":"Redisson","url":"/2022/07/14/Redisson/","content":"","categories":["框架"],"tags":["分布式","Redis"]},{"title":"RocketMQ","url":"/2020/09/22/RocketMQ/","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>秒杀业务，需要执行分布式事务，通过RocketMq来作为中间桥梁，架通订单生成和支付业务。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"消息队列对比\"><a href=\"#消息队列对比\" class=\"headerlink\" title=\"消息队列对比\"></a>消息队列对比</h1><h2 id=\"ActiveMq\"><a href=\"#ActiveMq\" class=\"headerlink\" title=\"ActiveMq\"></a>ActiveMq</h2><h2 id=\"RabbitMq\"><a href=\"#RabbitMq\" class=\"headerlink\" title=\"RabbitMq\"></a>RabbitMq</h2><p>AMQP协议实现的，比较多应用在金融业。</p>\n<h2 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h2><p>分布式、支持分区的、多副本的，基于Zookeeper协调的内部分布式消息系统，<br>最大的特征：实事处理大量数据以满足需求场景，经常用于大数据相关</p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><p>Producer - Topic - Consumer</p>\n<h3 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>消息生产者</p>\n<h3 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><p>消息消费者</p>\n<h3 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h3><p>消息的主题，将消息进行标签分类的逻辑单元</p>\n<h2 id=\"衍生概念\"><a href=\"#衍生概念\" class=\"headerlink\" title=\"衍生概念\"></a>衍生概念</h2><h3 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h3><p>中转站，负责存储和转发消息。有时也称Server<br>内部存储了多个Topic</p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><p>消息的物理队列，Topic下默认8个队列，可以修改</p>\n<h3 id=\"ProducerGroup\"><a href=\"#ProducerGroup\" class=\"headerlink\" title=\"ProducerGroup\"></a>ProducerGroup</h3><p>生产组</p>\n<h3 id=\"ConsumerGroup\"><a href=\"#ConsumerGroup\" class=\"headerlink\" title=\"ConsumerGroup\"></a>ConsumerGroup</h3><p>消费组，同样消费逻辑的消费者</p>\n<h3 id=\"NameServer\"><a href=\"#NameServer\" class=\"headerlink\" title=\"NameServer\"></a>NameServer</h3><p>注册中心：</p>\n<ol>\n<li>每个Broker启动的时候会向namesrv注册</li>\n<li>Producer发送消息的时候根据Topic获取路由到Broker⾥⾯Topic的信息</li>\n<li>Consumer根据Topic到Namesrv获取Topic的路由到Broker的信息</li>\n</ol>\n<h1 id=\"代码相关类\"><a href=\"#代码相关类\" class=\"headerlink\" title=\"代码相关类\"></a>代码相关类</h1><h2 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h2><ol>\n<li>topic</li>\n<li>tags<br>topic下的标签，可以再细分</li>\n<li>keys</li>\n<li>flag</li>\n<li>body</li>\n<li>waitStoreMsgOK</li>\n</ol>\n<h1 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h1><h2 id=\"主从切换\"><a href=\"#主从切换\" class=\"headerlink\" title=\"主从切换\"></a>主从切换</h2><h2 id=\"同步复制、异步复制\"><a href=\"#同步复制、异步复制\" class=\"headerlink\" title=\"同步复制、异步复制\"></a>同步复制、异步复制</h2><p>最安全，但是因为过高的IO，效率不高</p>\n<h2 id=\"同步刷盘、异步刷盘\"><a href=\"#同步刷盘、异步刷盘\" class=\"headerlink\" title=\"同步刷盘、异步刷盘\"></a>同步刷盘、异步刷盘</h2><h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"Linux-Mac\"><a href=\"#Linux-Mac\" class=\"headerlink\" title=\"Linux/Mac\"></a>Linux/Mac</h2><p>参考官网</p>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h2><p>参考<a href=\"https://github.com/apache/rocketmq-docker\">https://github.com/apache/rocketmq-docker</a></p>\n<h1 id=\"SpringBoot整合\"><a href=\"#SpringBoot整合\" class=\"headerlink\" title=\"SpringBoot整合\"></a>SpringBoot整合</h1><h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.rocketmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>xxx<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"RocketMQ的配置\"><a href=\"#RocketMQ的配置\" class=\"headerlink\" title=\"RocketMQ的配置\"></a>RocketMQ的配置</h3><p>broker的配置，broker.conf</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#RocketMQ详细配置解释</span></span><br><span class=\"line\"><span class=\"comment\">#所属集群名字</span></span><br><span class=\"line\"><span class=\"string\">brokerClusterName=rocketmq-cluster</span></span><br><span class=\"line\"><span class=\"comment\">#broker 名字，注意此处不同的配置文件填写的不一样</span></span><br><span class=\"line\"><span class=\"string\">brokerName=broker-a|broker-b</span></span><br><span class=\"line\"><span class=\"comment\">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class=\"line\"><span class=\"string\">brokerId=0</span></span><br><span class=\"line\"><span class=\"comment\">#nameServer 地址，分号分割</span></span><br><span class=\"line\"><span class=\"string\">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span></span><br><span class=\"line\"><span class=\"comment\">#在发送消息时，自动创建服务器不存在的 topic，默认创建的队列数</span></span><br><span class=\"line\"><span class=\"string\">defaultTopicQueueNums=4</span></span><br><span class=\"line\"><span class=\"comment\">#是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭</span></span><br><span class=\"line\"><span class=\"string\">autoCreateTopicEnable=true</span></span><br><span class=\"line\"><span class=\"comment\">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class=\"line\"><span class=\"string\">autoCreateSubscriptionGroup=true</span></span><br><span class=\"line\"><span class=\"comment\">#Broker 对外服务的监听端口</span></span><br><span class=\"line\"><span class=\"string\">listenPort=10911</span></span><br><span class=\"line\"><span class=\"comment\">#删除文件时间点，默认凌晨 4 点</span></span><br><span class=\"line\"><span class=\"string\">deleteWhen=04</span></span><br><span class=\"line\"><span class=\"comment\">#文件保留时间，默认 48 小时</span></span><br><span class=\"line\"><span class=\"string\">fileReservedTime=120</span></span><br><span class=\"line\"><span class=\"comment\">#commitLog 每个文件的大小默认 1G</span></span><br><span class=\"line\"><span class=\"string\">mapedFileSizeCommitLog=1073741824</span></span><br><span class=\"line\"><span class=\"comment\">#ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整</span></span><br><span class=\"line\"><span class=\"string\">mapedFileSizeConsumeQueue=300000</span></span><br><span class=\"line\"><span class=\"comment\">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class=\"line\"><span class=\"comment\">#redeleteHangedFileInterval=120000</span></span><br><span class=\"line\"><span class=\"comment\">#检测物理文件磁盘空间</span></span><br><span class=\"line\"><span class=\"string\">diskMaxUsedSpaceRatio=88</span></span><br><span class=\"line\"><span class=\"comment\">#存储路径</span></span><br><span class=\"line\"><span class=\"string\">storePathRootDir=/usr/local/rocketmq/store</span></span><br><span class=\"line\"><span class=\"comment\">#commitLog 存储路径</span></span><br><span class=\"line\"><span class=\"string\">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span></span><br><span class=\"line\"><span class=\"comment\">#消费队列存储路径存储路径</span></span><br><span class=\"line\"><span class=\"string\">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span></span><br><span class=\"line\"><span class=\"comment\">#消息索引存储路径</span></span><br><span class=\"line\"><span class=\"string\">storePathIndex=/usr/local/rocketmq/store/index</span></span><br><span class=\"line\"><span class=\"comment\">#checkpoint 文件存储路径</span></span><br><span class=\"line\"><span class=\"string\">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span></span><br><span class=\"line\"><span class=\"comment\">#abort 文件存储路径</span></span><br><span class=\"line\"><span class=\"string\">abortFile=/usr/local/rocketmq/store/abort</span></span><br><span class=\"line\"><span class=\"comment\">#限制的消息大小</span></span><br><span class=\"line\"><span class=\"string\">maxMessageSize=65536</span></span><br><span class=\"line\"><span class=\"comment\">#flushCommitLogLeastPages=4</span></span><br><span class=\"line\"><span class=\"comment\">#flushConsumeQueueLeastPages=2</span></span><br><span class=\"line\"><span class=\"comment\">#flushCommitLogThoroughInterval=10000</span></span><br><span class=\"line\"><span class=\"comment\">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class=\"line\"><span class=\"comment\">#Broker 的角色</span></span><br><span class=\"line\"><span class=\"comment\">#- ASYNC_MASTER 异步复制 Master</span></span><br><span class=\"line\"><span class=\"comment\">#- SYNC_MASTER 同步双写 Master</span></span><br><span class=\"line\"><span class=\"comment\">#- SLAVE</span></span><br><span class=\"line\"><span class=\"string\">brokerRole=ASYNC_MASTER</span></span><br><span class=\"line\"><span class=\"comment\">#刷盘方式</span></span><br><span class=\"line\"><span class=\"comment\">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class=\"line\"><span class=\"comment\">#- SYNC_FLUSH 同步刷盘</span></span><br><span class=\"line\"><span class=\"string\">flushDiskType=ASYNC_FLUSH</span></span><br><span class=\"line\"><span class=\"comment\">#checkTransactionMessageEnable=false</span></span><br><span class=\"line\"><span class=\"comment\">#发消息线程池数量</span></span><br><span class=\"line\"><span class=\"comment\">#sendMessageThreadPoolNums=128</span></span><br><span class=\"line\"><span class=\"comment\">#拉消息线程池数量</span></span><br><span class=\"line\"><span class=\"comment\">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"SpringBoot程序的配置\"><a href=\"#SpringBoot程序的配置\" class=\"headerlink\" title=\"SpringBoot程序的配置\"></a>SpringBoot程序的配置</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rocketmq:</span></span><br><span class=\"line\">  <span class=\"attr\">name-server:</span> <span class=\"string\">localhost:9876</span></span><br><span class=\"line\">  <span class=\"attr\">producer:</span></span><br><span class=\"line\">    <span class=\"attr\">group:</span> <span class=\"string\">producer1</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Java代码\"><a href=\"#Java代码\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h2><h3 id=\"Message-1\"><a href=\"#Message-1\" class=\"headerlink\" title=\"Message\"></a>Message</h3><p>在消息队列中，最主要的是依靠一个最终的消息信号，作为信息传递。<br>在这里，自己随便使用一个Entity作为Message的PayLoad。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;官方Message接口</span><br><span class=\"line\">public interface Message&lt;T&gt; &#123;</span><br><span class=\"line\">    T getPayload();</span><br><span class=\"line\"></span><br><span class=\"line\">    MessageHeaders getHeaders();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public Class MyEntity &#123;</span><br><span class=\"line\">    String id;</span><br><span class=\"line\">    String username;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Producer-1\"><a href=\"#Producer-1\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>创建一个Producer，向对应的Topic发送消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerComponent</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Resource</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">send</span><span class=\"params\">(String topic, String msg)</span> </span>&#123;</span><br><span class=\"line\">\t  <span class=\"comment\">//使用convertAndSend,会自动把Object转换为Message类</span></span><br><span class=\"line\">\t\trocketMQTemplate.convertAndSend(topic, msg);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Consumer-1\"><a href=\"#Consumer-1\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@RocketMQMessageListener(topic = &quot;trf&quot;, consumerGroup = &quot;consumer1&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumerComponent</span> <span class=\"keyword\">implements</span> <span class=\"title\">RocketMQListener</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(msg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"延迟发送消息\"><a href=\"#延迟发送消息\" class=\"headerlink\" title=\"延迟发送消息\"></a>延迟发送消息</h1><p>有时候，业务需要将消息延迟发送（比如超时取消），则此时需要用延迟消息。<br>定时任务也能做超时取消。<br>delayLevel级别：<br>1 5 10 30 sec<br>1 2 3 4 5 6 7 8 9 10 20 30 min<br>1 2 hour</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//RocketMQTemplate.class</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SendResult <span class=\"title\">syncSend</span><span class=\"params\">(String destination, Message&lt;?&gt; message, <span class=\"keyword\">long</span> timeout, <span class=\"keyword\">int</span> delayLevel)</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"事务型消息\"><a href=\"#事务型消息\" class=\"headerlink\" title=\"事务型消息\"></a>事务型消息</h1><h2 id=\"事务监听器\"><a href=\"#事务监听器\" class=\"headerlink\" title=\"事务监听器\"></a>事务监听器</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public SendResult </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事务生产者\"><a href=\"#事务生产者\" class=\"headerlink\" title=\"事务生产者\"></a>事务生产者</h2><h1 id=\"源码相关\"><a href=\"#源码相关\" class=\"headerlink\" title=\"源码相关\"></a>源码相关</h1><h1 id=\"有序消息和无序消息\"><a href=\"#有序消息和无序消息\" class=\"headerlink\" title=\"有序消息和无序消息\"></a>有序消息和无序消息</h1><p>默认的消息消费是无序消费的，即16个Quque，是随机发送的。<br>看@RocketMQListener源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"RocketMQ消费线程\"><a href=\"#RocketMQ消费线程\" class=\"headerlink\" title=\"RocketMQ消费线程\"></a>RocketMQ消费线程</h1><p>消费线程默认是20个，可以在</p>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><h2 id=\"sendDefaultImpl-call-timeout\"><a href=\"#sendDefaultImpl-call-timeout\" class=\"headerlink\" title=\"sendDefaultImpl call timeout\"></a>sendDefaultImpl call timeout</h2><p>Docker部署下，如果没有配置公网IP，可能使用的是自己的Docker的内网IP，需要在配置broker.conf里brokerIP，改为公网IP。<br>broker.conf：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">brokerClusterName &#x3D; DefaultCluster</span><br><span class=\"line\">brokerName &#x3D; broker-abc</span><br><span class=\"line\">brokerId &#x3D; 0</span><br><span class=\"line\">deleteWhen &#x3D; 04</span><br><span class=\"line\">fileReservedTime &#x3D; 48</span><br><span class=\"line\">brokerRole &#x3D; ASYNC_MASTER</span><br><span class=\"line\">flushDiskType &#x3D; ASYNC_FLUSH</span><br><span class=\"line\">brokerIP1 &#x3D; 192.168.0.102\t\t&#x2F;&#x2F;更改此处ip</span><br></pre></td></tr></table></figure>\n<p>本人是将配置文件，挂载到docker内部中，再使用</p>\n","categories":["框架"],"tags":["分布式","消息队列"]},{"title":"Servlet","url":"/2021/04/06/Servlet/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Servlet是用来开发动态Web资源。Servlet是个接口（interface类）</p>\n<span id=\"more\"></span>\n\n<h1 id=\"子类\"><a href=\"#子类\" class=\"headerlink\" title=\"子类\"></a>子类</h1><h2 id=\"GenericServlet\"><a href=\"#GenericServlet\" class=\"headerlink\" title=\"GenericServlet\"></a>GenericServlet</h2><h2 id=\"HttpServlet\"><a href=\"#HttpServlet\" class=\"headerlink\" title=\"HttpServlet\"></a>HttpServlet</h2><div class=\"note info\">\n            <ol><li>编译所需要的javax.servlet并不在JDK中，可以使用-classpath 指定一个jar包。（在Tomcat的lib中有servlet-api.jar）</li><li>servlet没有独立的运行能力。</li></ol>\n          </div>\n\n<h1 id=\"Class文件和Tomcat关联\"><a href=\"#Class文件和Tomcat关联\" class=\"headerlink\" title=\"Class文件和Tomcat关联\"></a>Class文件和Tomcat关联</h1><p>通过发布应用，使用标准JavaEE项目目录结构<br><img src=\"/2021/04/06/Servlet/JavaEE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png\"></p>\n<h1 id=\"访问Servlet\"><a href=\"#访问Servlet\" class=\"headerlink\" title=\"访问Servlet\"></a>访问Servlet</h1><p>任何WEB-INF下的都不能被浏览器访问到，需要使用配置映射。<br><img src=\"/2021/04/06/Servlet/%E8%AE%BF%E9%97%AEServlet%E9%85%8D%E7%BD%AE.png\"></p>\n<div class=\"note info\">\n            <p>如何希望Servlet输出到浏览器文本中，应该将内容写到相应报文的实体中（ServletResponse)<br>res.getWriter().println(xxx);</p>\n          </div>\n\n<h2 id=\"Servlet执行过程\"><a href=\"#Servlet执行过程\" class=\"headerlink\" title=\"Servlet执行过程\"></a>Servlet执行过程</h2><ol>\n<li>浏览器访问地址，浏览器会构建http请求报文</li>\n<li>报文到达主机后，connector会获取到它，把请求报文封装为Request对象，并生成Response对象，用来填充相应数据。</li>\n<li>将Request和Response对象交给Engine，Engine挑选哪个Host来处理。</li>\n<li>Host来挑选对应的Context来处理，传递两个对象。</li>\n<li>Context拿到对应服务器应用，实例化对象，调用Service方法，返回Response对象到Connector。</li>\n<li>Connector读取Response的内容，封装成一定格式的响应报文，返回给浏览器。</li>\n</ol>\n<div class=\"note info\">\n            <p>Servlet只会实例化对象一次。（单例模式）</p>\n          </div>\n<h1 id=\"使用IDEA开发Servlet\"><a href=\"#使用IDEA开发Servlet\" class=\"headerlink\" title=\"使用IDEA开发Servlet\"></a>使用IDEA开发Servlet</h1><h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p><img src=\"/2021/04/06/Servlet/1.png\"><br><img src=\"/2021/04/06/Servlet/2.png\"><br><img src=\"/2021/04/06/Servlet/3.png\"><br><img src=\"/2021/04/06/Servlet/4.png\"></p>\n<h2 id=\"配置tomcat\"><a href=\"#配置tomcat\" class=\"headerlink\" title=\"配置tomcat\"></a>配置tomcat</h2><p><img src=\"/2021/04/06/Servlet/5.png\"><br><img src=\"/2021/04/06/Servlet/6.png\"><br><img src=\"/2021/04/06/Servlet/7.png\"><br><img src=\"/2021/04/06/Servlet/8.png\"><br><img src=\"/2021/04/06/Servlet/9.png\"><br><img src=\"/2021/04/06/Servlet/10.png\"></p>\n<h2 id=\"使用GenericServlet\"><a href=\"#使用GenericServlet\" class=\"headerlink\" title=\"使用GenericServlet\"></a>使用GenericServlet</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class MyTest extends GenericServlet &#123;</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;</span><br><span class=\"line\">    res.getWriter().println(123);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用HttpServlet（推荐，分发更细致）\"><a href=\"#使用HttpServlet（推荐，分发更细致）\" class=\"headerlink\" title=\"使用HttpServlet（推荐，分发更细致）\"></a>使用HttpServlet（推荐，分发更细致）</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class MyTest extends HttpServlet &#123;</span><br><span class=\"line\">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class=\"line\">    resp.getWriter().println(123);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>为什么继承GenericServlet要实现Servlet方法，而HttpServlet不用？<br>因为GenericServlet是抽象方法，HttpServlet已经实现过了。</p>\n          </div>\n\n<h2 id=\"使用注解-WebServlet（配置了后不用在web-xml里配置）\"><a href=\"#使用注解-WebServlet（配置了后不用在web-xml里配置）\" class=\"headerlink\" title=\"使用注解@WebServlet（配置了后不用在web.xml里配置）\"></a>使用注解@WebServlet（配置了后不用在web.xml里配置）</h2><p><img src=\"/2021/04/06/Servlet/11.png\"><br>如果name为“value”，可以进一步简化。</p>\n<h1 id=\"IDEA和TomCat的关联\"><a href=\"#IDEA和TomCat的关联\" class=\"headerlink\" title=\"IDEA和TomCat的关联\"></a>IDEA和TomCat的关联</h1><p>实际上IDEA会复制Tomcat的核心内容，然后利用这些内容重新部署运行一个TomCat。</p>\n<h2 id=\"开发目录和部署目录\"><a href=\"#开发目录和部署目录\" class=\"headerlink\" title=\"开发目录和部署目录\"></a>开发目录和部署目录</h2><p>开发目录是自己写代码的区域，是Java文件。<br>部署目录是运行/调试时，按照某个规则，将class文件和web相关联</p>\n<h1 id=\"Servlet生命周期函数\"><a href=\"#Servlet生命周期函数\" class=\"headerlink\" title=\"Servlet生命周期函数\"></a>Servlet生命周期函数</h1><p>LifeCycleServlet</p>\n<h2 id=\"Init\"><a href=\"#Init\" class=\"headerlink\" title=\"Init\"></a>Init</h2><p>只会执行一次，初次访问Servlet执行。<br>一般用于预加载初始化操作，比如查询数据库等，可以放在init里。</p>\n<div class=\"note info\">\n            <p>loadOnStartup=非负数(注解或者web.xml里面配置）可以让init随应用加载而执行。Servlet5里面。</p>\n          </div>\n<h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><p>每次请求都会执行一次。</p>\n<h2 id=\"Destory\"><a href=\"#Destory\" class=\"headerlink\" title=\"Destory\"></a>Destory</h2><h1 id=\"Url-Pattern细节\"><a href=\"#Url-Pattern细节\" class=\"headerlink\" title=\"Url-Pattern细节\"></a>Url-Pattern细节</h1><ol>\n<li>一个Servlet可以配置多个Url-Pattern</li>\n<li>多个Servlet不能配置同一个Url-Pattern</li>\n<li>写法：/xxx 或者 *.后缀</li>\n</ol>\n<h2 id=\"Url-Pattern的匹配优先级\"><a href=\"#Url-Pattern的匹配优先级\" class=\"headerlink\" title=\"Url-Pattern的匹配优先级\"></a>Url-Pattern的匹配优先级</h2><p>/开头的优先级始终高于*.后缀。<br>匹配越精细，优先级越高</p>\n<h2 id=\"特殊Url-Pattern（-）\"><a href=\"#特殊Url-Pattern（-）\" class=\"headerlink\" title=\"特殊Url-Pattern（*）\"></a>特殊Url-Pattern（*）</h2><p>/* 和 /<br>/* 的优先级很高<br>/ 可以访问jsp，是因为tomcat的servlet中配置jsp访问。/ 是默认的Servlet的处理，给没有任何匹配的Url-Pattern的applet来响应的。</p>\n<div class=\"note info\">\n            <p>DefaultServlet（/）处理流程：</p><ol><li>到对应目录，找到对应的文件。找到，以流的形式写出。（但是如果自己实现了/ 的处理，则会按照自己写的来进行处理）</li><li>没找到，则404相应。</li></ol>\n          </div>\n\n<div class=\"note info\">\n            <p>动态资源和静态资源的界限</p>\n          </div>\n\n<h1 id=\"ServletConfig\"><a href=\"#ServletConfig\" class=\"headerlink\" title=\"ServletConfig\"></a>ServletConfig</h1><h2 id=\"获取ServletConfig对象\"><a href=\"#获取ServletConfig对象\" class=\"headerlink\" title=\"获取ServletConfig对象\"></a>获取ServletConfig对象</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ServletConfig servletConfig &#x3D; getServletConfig()</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取ServletContext\"><a href=\"#获取ServletContext\" class=\"headerlink\" title=\"获取ServletContext\"></a>获取ServletContext</h2><p>当前应用下的任何一个Servlet都可以获取到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ServletContext servletContext &#x3D; getServletContext()</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取全局初始化参数\"><a href=\"#获取全局初始化参数\" class=\"headerlink\" title=\"获取全局初始化参数\"></a>获取全局初始化参数</h3><p>全局参数在web-app下配置（或者web.xml）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;配置</span><br><span class=\"line\">&lt;servlet&gt;</span><br><span class=\"line\">  &lt;servlet-name&gt;config&lt;&#x2F;servlet-name&gt;</span><br><span class=\"line\">  &lt;servlet-class&gt;com.cskaoyan.config.ConfigServlet&lt;&#x2F;servlet-class&gt;</span><br><span class=\"line\">  &lt;init-param&gt;</span><br><span class=\"line\">    &lt;param-name&gt;name&lt;&#x2F;param-name&gt;</span><br><span class=\"line\">    &lt;param-value&gt;zhangsan&lt;&#x2F;param-value&gt;</span><br><span class=\"line\">  &lt;&#x2F;init-param&gt;</span><br><span class=\"line\">&lt;&#x2F;servlet&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;获取全局初始化</span><br><span class=\"line\">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class=\"line\">  &#x2F;&#x2F;拿到servletConfig对象  继承父类的方法</span><br><span class=\"line\">  ServletConfig servletConfig &#x3D; getServletConfig();</span><br><span class=\"line\">  String name &#x3D; servletConfig.getInitParameter(&quot;name&quot;);</span><br><span class=\"line\">  System.out.println(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"共享数据参数\"><a href=\"#共享数据参数\" class=\"headerlink\" title=\"共享数据参数\"></a>共享数据参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;设置</span><br><span class=\"line\">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class=\"line\">  ServletContext servletContext &#x3D; getServletContext();</span><br><span class=\"line\">  &#x2F;&#x2F;JDBC  商场的商品信息  List&lt;Type&gt;  电器  衣服  化妆品</span><br><span class=\"line\">  servletContext.setAttribute(&quot;name&quot;, &quot;iphone&quot;);</span><br><span class=\"line\">  &#x2F;&#x2F;servletContext.removeAttribute(&quot;name&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;其他Servlet获取</span><br><span class=\"line\">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class=\"line\">  ServletContext servletContext &#x3D; getServletContext();</span><br><span class=\"line\">  String name &#x3D; (String) servletContext.getAttribute(&quot;name&quot;);</span><br><span class=\"line\">  System.out.println(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取JavaEE的绝对路径\"><a href=\"#获取JavaEE的绝对路径\" class=\"headerlink\" title=\"获取JavaEE的绝对路径\"></a>获取JavaEE的绝对路径</h3><p>因为EE项目的文件是由tomcat来复制一份再进行调用的，所以获取到的文件路径会是tomcat的路径。要获取到真正的绝对路径，需要使用getReadPath()。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">String path1 &#x3D; getServletContext().getRealPath(&quot;1.html&quot;);</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>WEB-INFO是无法被浏览器访问到的。</p>\n          </div>\n\n<h1 id=\"ServletRequest\"><a href=\"#ServletRequest\" class=\"headerlink\" title=\"ServletRequest\"></a>ServletRequest</h1><p>ServletRequest对请求报文的封装。</p>\n<h2 id=\"获取请求报文\"><a href=\"#获取请求报文\" class=\"headerlink\" title=\"获取请求报文\"></a>获取请求报文</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">获取请求方法</span><br><span class=\"line\">String method &#x3D; request.getMethod();</span><br><span class=\"line\">&#x2F;&#x2F;获取请求资源</span><br><span class=\"line\">String requestURI &#x3D; request.getRequestURI();</span><br><span class=\"line\">String requestURL &#x3D; request.getRequestURL().toString();</span><br><span class=\"line\">&#x2F;&#x2F;获取版本协议</span><br><span class=\"line\">String protocol &#x3D; request.getProtocol();</span><br><span class=\"line\">&#x2F;&#x2F;获取请求头</span><br><span class=\"line\">String host &#x3D; request.getHeader(&quot;Host&quot;);</span><br><span class=\"line\">System.out.println(host);</span><br><span class=\"line\"></span><br><span class=\"line\">Enumeration&lt;String&gt; headerNames &#x3D; request.getHeaderNames();</span><br><span class=\"line\">while (headerNames.hasMoreElements()) &#123;</span><br><span class=\"line\">  String headerName &#x3D; headerNames.nextElement();</span><br><span class=\"line\">  String header &#x3D; request.getHeader(headerName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;获取请求体</span><br><span class=\"line\">request.getInputStream()</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>Get和Post的区别：实际上并没有太大区别，只是语义上的不同。</p>\n          </div>\n\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">String remoteAddr &#x3D; request.getRemoteAddr();</span><br><span class=\"line\">int remotePort &#x3D; request.getRemotePort();</span><br><span class=\"line\">String localAddr &#x3D; request.getLocalAddr();</span><br><span class=\"line\">int localPort &#x3D; request.getLocalPort();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"获取请求参数\"><a href=\"#获取请求参数\" class=\"headerlink\" title=\"获取请求参数\"></a>获取请求参数</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;获取单个参数</span><br><span class=\"line\">String username &#x3D; request.getParameter(&quot;username&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;获取数组参数</span><br><span class=\"line\">String[] hobbies &#x3D; request.getParameterValues(&quot;hobby&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;获取多个参数（如果多个表单比较麻烦，可以用这个方法）</span><br><span class=\"line\">Enumeration&lt;String&gt; names &#x3D; request.getParameterNames();</span><br><span class=\"line\">while (names.hasMoreElements()) &#123;</span><br><span class=\"line\">  处理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"封装到Bean\"><a href=\"#封装到Bean\" class=\"headerlink\" title=\"封装到Bean\"></a>封装到Bean</h2><p>Dbutils：BeanHandler、BeanListHandler<br>Bean：属性值必须为private；set和get必须为public；拥有无参构造方法。</p>\n<div class=\"note info\">\n            <p>不能采用判断key的方式，来修改值和获取值，这样会很繁琐。<br>封装Bean采用的是反射技术，获取所有的set和get方法。<br>设置值 setValue = value;<br>获取值 getValue();</p>\n          </div>\n\n<div class=\"note info\">\n            <p>JavaEE项目导包，需要放在WEB-INF/lib中，这样Tomcat才能找到对应的jar包。（运行时必须要有）</p>\n          </div>\n\n<h3 id=\"BeanUtils\"><a href=\"#BeanUtils\" class=\"headerlink\" title=\"BeanUtils\"></a>BeanUtils</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">User user &#x3D; new User();\t\t&#x2F;&#x2F;创建一个Bean对象</span><br><span class=\"line\">BeanUtils.populate(user, request.getParameterMap());  把内容封装到user里</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"请求参数中文乱码\"><a href=\"#请求参数中文乱码\" class=\"headerlink\" title=\"请求参数中文乱码\"></a>请求参数中文乱码</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">request.setCharacterEncoding(&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>Tomcat8处理请求行使用的编码格式是utf-8</p>\n          </div>\n\n<h2 id=\"form表单的路径写法\"><a href=\"#form表单的路径写法\" class=\"headerlink\" title=\"form表单的路径写法\"></a>form表单的路径写法</h2><p>form action=”…path…”</p>\n<h3 id=\"全路径写法\"><a href=\"#全路径写法\" class=\"headerlink\" title=\"全路径写法\"></a>全路径写法</h3><p>因为环境经常需要变更，除非是决定不改，否则不建议使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">form action&#x3D;&quot;http:&#x2F;&#x2F;localhost&#x2F;app&#x2F;servlet1”</span><br></pre></td></tr></table></figure>\n<h3 id=\"相对路径\"><a href=\"#相对路径\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h3><p>过分依赖于当前页面，如果修改了当前页面路径，则无法访问。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">form action&#x3D;&quot;servlet1&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"以-的路径写法\"><a href=\"#以-的路径写法\" class=\"headerlink\" title=\"以/ 的路径写法\"></a>以/ 的路径写法</h3><p>比较好的方式，/应用名/资源名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">form action&#x3D;&quot;&#x2F;app&#x2F;servlet1&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取路径\"><a href=\"#获取路径\" class=\"headerlink\" title=\"获取路径\"></a>获取路径</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">request.getRequestURI();</span><br><span class=\"line\">request.getRequestURL().toSrting();</span><br><span class=\"line\">request.getContextPath();</span><br><span class=\"line\">request.getServletPath();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dispatcher路径写法\"><a href=\"#Dispatcher路径写法\" class=\"headerlink\" title=\"Dispatcher路径写法\"></a>Dispatcher路径写法</h2><h3 id=\"全路径写法（X）\"><a href=\"#全路径写法（X）\" class=\"headerlink\" title=\"全路径写法（X）\"></a>全路径写法（X）</h3><p>error，不行。</p>\n<h3 id=\"相对路径-1\"><a href=\"#相对路径-1\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h3><p>可以，推荐使用</p>\n<h3 id=\"开头路径\"><a href=\"#开头路径\" class=\"headerlink\" title=\"/开头路径\"></a>/开头路径</h3><p>/资源名就行</p>\n<div class=\"note info\">\n            <p>/开头的什么时候加应用名，什么时候不用：<br>如果主体是服务器，那么不要加应用名（路径给服务器使用）<br>如果主体是浏览器，那么一定要加（路径给浏览器用）</p>\n          </div>\n\n<h2 id=\"转发和包含\"><a href=\"#转发和包含\" class=\"headerlink\" title=\"转发和包含\"></a>转发和包含</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class=\"line\">  &#x2F;&#x2F;y:源组件  s:目标组件的路径</span><br><span class=\"line\">  response.setHeader(&quot;Connection&quot;,&quot;close&quot;);</span><br><span class=\"line\">  response.getWriter().println(&quot;dispatcher1&quot;);</span><br><span class=\"line\">  RequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(&quot;&#x2F;dispatcher2&quot;);</span><br><span class=\"line\">  &#x2F;&#x2F;转发</span><br><span class=\"line\">  dispatcher.forward(request, response);</span><br><span class=\"line\">  &#x2F;&#x2F;包含</span><br><span class=\"line\">  dispatcher.include(request, response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"转发\"><a href=\"#转发\" class=\"headerlink\" title=\"转发\"></a>转发</h3><p>A转发给B，A的主动权会交给B来处理。<br>转发：留头不留体</p>\n<h3 id=\"包含\"><a href=\"#包含\" class=\"headerlink\" title=\"包含\"></a>包含</h3><p>A将B的内容包含在自己身上，主动权仍旧在A上。<br>包含：留头也留体 </p>\n<h2 id=\"Context域\"><a href=\"#Context域\" class=\"headerlink\" title=\"Context域\"></a>Context域</h2><p>Servlet的一块空间，可以用来存取数据。随着应用创建而创建，销毁而销毁，仅有一个，空间较大。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">setAttribute(key, value);</span><br><span class=\"line\">getAttribute(key);</span><br><span class=\"line\">removeAttribute(key);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Request域\"><a href=\"#Request域\" class=\"headerlink\" title=\"Request域\"></a>Request域</h2><p>地址每次进行一个请求，就会生成一个Request域。（每次刷新，每次的Request都会不同）<br>但是多个组件可以共享一个Request域，共享里面的Map内容。但是仅限于转发和包含的源组件和目标组件。</p>\n<div class=\"note info\">\n            <p>思考思考Request的使用场景：比如查询Servlet，拿到了数据，转发给另一个Servlet，就可以使用。</p>\n          </div>\n\n\n\n<h1 id=\"ServletResponse\"><a href=\"#ServletResponse\" class=\"headerlink\" title=\"ServletResponse\"></a>ServletResponse</h1><p>对响应报文的封装，HttpServletResponse。</p>\n<h2 id=\"响应报文\"><a href=\"#响应报文\" class=\"headerlink\" title=\"响应报文\"></a>响应报文</h2><ol>\n<li>版本</li>\n<li>状态码</li>\n<li>描述<h2 id=\"设置响应报文\"><a href=\"#设置响应报文\" class=\"headerlink\" title=\"设置响应报文\"></a>设置响应报文</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">response.setStatus(200);</span><br><span class=\"line\">response.setHeader(&quot;Content-Type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出字符到客户端\"><a href=\"#输出字符到客户端\" class=\"headerlink\" title=\"输出字符到客户端\"></a>输出字符到客户端</h2></li>\n</ol>\n<h3 id=\"响应报文乱码问题\"><a href=\"#响应报文乱码问题\" class=\"headerlink\" title=\"响应报文乱码问题\"></a>响应报文乱码问题</h3><p>客户端使用其自己系统的编码格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;如果知道客户的编码格式，可以手动修改</span><br><span class=\"line\">response.setCharacterEncoding(&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>\n<p>更好的方式是，将服务器使用的编码格式，告诉给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;text&#x2F;html:设置服务器编码格式</span><br><span class=\"line\">&#x2F;&#x2F;charset&#x3D;utf-8:告诉客户端服务器使用的编码格式</span><br><span class=\"line\">response.setHeader(&quot;Content-Type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;这种方式也行</span><br><span class=\"line\">response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;手写编码输出</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出字节到客户端\"><a href=\"#输出字节到客户端\" class=\"headerlink\" title=\"输出字节到客户端\"></a>输出字节到客户端</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">String realPath &#x3D; getServletContext().getRealPath(&quot;1.jpg&quot;);</span><br><span class=\"line\">File file &#x3D; new File(realPath);</span><br><span class=\"line\">FileInputStream inputStream &#x3D; new FileInputStream(file);</span><br><span class=\"line\">ServletOutPutStream outputStream &#x3D; response.getOutPutStream();</span><br><span class=\"line\">byte[] bytes &#x3D; new byte[1024];</span><br><span class=\"line\">int length &#x3D; 0;</span><br><span class=\"line\">while((length &#x3D; inputStream.read(bytes)) !&#x3D; -1) &#123;</span><br><span class=\"line\">  outputStream.write(bytes, 0, length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">outputStream.flush();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"页面刷新\"><a href=\"#页面刷新\" class=\"headerlink\" title=\"页面刷新\"></a>页面刷新</h2><h3 id=\"定时刷新\"><a href=\"#定时刷新\" class=\"headerlink\" title=\"定时刷新\"></a>定时刷新</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;全路径</span><br><span class=\"line\">response.setHeader(&quot;refresh&quot;, &quot;2,url&#x3D;https:&#x2F;&#x2F;www.baidu.com&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;相对路径</span><br><span class=\"line\">response.setHeader(&quot;refresh&quot;, &quot;2,url&#x3D;baidu.html&quot;);</span><br><span class=\"line\">&#x2F;&#x2F; &#x2F;应用名&#x2F;资源</span><br><span class=\"line\">response.setHeader(&quot;refresh&quot;, &quot;2,url&#x3D;request.getContextPath() + &quot;&#x2F;baidu.html&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">response.sendRedirect(&quot;https:&#x2F;&#x2F;cn.bing.com&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"页面跳转比较\"><a href=\"#页面跳转比较\" class=\"headerlink\" title=\"页面跳转比较\"></a>页面跳转比较</h3><p>转发、定时刷新、重定向的区别：</p>\n<ol>\n<li>转发只发送一次请求，其他可以发送多次。</li>\n<li>转发的执行主体是服务器，其他执行主体是浏览器。</li>\n<li>转发只能在应用内跳转，其他不受影响。</li>\n<li>转发是request对象引导的，其他是response对象引导的。</li>\n<li>转发可以共享request域，其他不可以。</li>\n<li>重定向状态码是302、307，其他都是200。</li>\n<li>转发地址栏不发生改变，其他会改变。</li>\n</ol>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>浏览器的默认行为：</p>\n<ol>\n<li>对于可以打开的文件，比如html、TXT、css、js、图片等，默认会帮你执行打开操作</li>\n<li>对于无法打开的文件，比如audio、video、exe、zip，默认会帮你执行下载操作</li>\n</ol>\n<p>如果想对可以打开的文件进行下载，要使用下载响应头。<br><img src=\"/2021/04/06/Servlet/%E4%B8%8B%E8%BD%BD%E5%93%8D%E5%BA%94%E5%A4%B4.png\"><br>应用场景：管理系统，报表的导出之类。</p>\n<h1 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h1><p>把文件封装到请求体内，然后服务器解析请求报文，取出请求体的IO流。</p>\n<h2 id=\"form表单\"><a href=\"#form表单\" class=\"headerlink\" title=\"form表单\"></a>form表单</h2><p>input type 设置为 file method 为 post<br><img src=\"/2021/04/06/Servlet/%E4%B8%8A%E4%BC%A0form.png\"></p>\n<h2 id=\"问题一：如果仅上传文件名，而没有数据\"><a href=\"#问题一：如果仅上传文件名，而没有数据\" class=\"headerlink\" title=\"问题一：如果仅上传文件名，而没有数据\"></a>问题一：如果仅上传文件名，而没有数据</h2><p>form表单要添加enctype=multipart/form-data<br><img src=\"/2021/04/06/Servlet/%E4%B8%8A%E4%BC%A0form1.png\"></p>\n<div class=\"note info\">\n            <p>数据内容大小，看content-length</p>\n          </div>\n<h2 id=\"问题二：使用API获取上传的文件，会显示损坏，无法打开\"><a href=\"#问题二：使用API获取上传的文件，会显示损坏，无法打开\" class=\"headerlink\" title=\"问题二：使用API获取上传的文件，会显示损坏，无法打开\"></a>问题二：使用API获取上传的文件，会显示损坏，无法打开</h2><p><img src=\"/2021/04/06/Servlet/%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0%E5%86%85%E5%AE%B9.png\"><br>但是图片已经损坏，无法打开。用txt文件上传，打开后发现有内容分割在txt文件中。</p>\n<h2 id=\"问题三：如果form表单数据和文件同时上传，原先的请求参数则无法获取到内容\"><a href=\"#问题三：如果form表单数据和文件同时上传，原先的请求参数则无法获取到内容\" class=\"headerlink\" title=\"问题三：如果form表单数据和文件同时上传，原先的请求参数则无法获取到内容\"></a>问题三：如果form表单数据和文件同时上传，原先的请求参数则无法获取到内容</h2><p>因为添加了enctype=multipart/form-data，就请求参数的API则无法使用。添加之后，数据结构会发生改变 ，getParamter的API无法使用。</p>\n<h2 id=\"使用第三方工具\"><a href=\"#使用第三方工具\" class=\"headerlink\" title=\"使用第三方工具\"></a>使用第三方工具</h2><p>fileupload<br>依赖：Commons-fileupload<br><a href=\"http://commons.apache.org/proper/commons-fileupload/\">http://commons.apache.org/proper/commons-fileupload/</a></p>\n<h3 id=\"其他配置\"><a href=\"#其他配置\" class=\"headerlink\" title=\"其他配置\"></a>其他配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fileItem.getString(&quot;utf-8&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;上传名中文乱码问题</span><br><span class=\"line\">upload.setHeaderEncoding(&quot;utf-8&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;上传文件大小设置</span><br><span class=\"line\">upload.setFileSizeMax(1024);\t&#x2F;&#x2F;单位是byte</span><br></pre></td></tr></table></figure>\n<h2 id=\"会话技术\"><a href=\"#会话技术\" class=\"headerlink\" title=\"会话技术\"></a>会话技术</h2>","categories":["Web服务器"],"tags":["Web"]},{"title":"Shiro","url":"/2020/09/07/Shiro/","content":"<p>Shiro是负责权限管理的轻量级框架</p>\n<h1 id=\"一、基础概念\"><a href=\"#一、基础概念\" class=\"headerlink\" title=\"一、基础概念\"></a>一、基础概念</h1><h2 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h2><p>用户认证，即确认用户信息<br>匿名资源：不需要认证即可访问的资源</p>\n<h2 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h2><p>用户授权，即访问控制。<br>用户认证后，需要对用户做分类，让其能访问其对应的资源。</p>\n<h2 id=\"权限管理模型\"><a href=\"#权限管理模型\" class=\"headerlink\" title=\"权限管理模型\"></a>权限管理模型</h2><p>基本模型：用户—-权限 （多对多）用户权限表<br>通用模型：建立角色权限，用户—角色—权限  用户角色表 角色权限表</p>\n<span id=\"more\"></span>\n\n<h1 id=\"二、Shiro架构\"><a href=\"#二、Shiro架构\" class=\"headerlink\" title=\"二、Shiro架构\"></a>二、Shiro架构</h1><h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><p>即主体，可以理解为用户</p>\n<h2 id=\"SecurityManager\"><a href=\"#SecurityManager\" class=\"headerlink\" title=\"SecurityManager\"></a>SecurityManager</h2><p>安全管理器，主体的认证和授权，都是通过它来进行</p>\n<h2 id=\"Authenticator\"><a href=\"#Authenticator\" class=\"headerlink\" title=\"Authenticator\"></a>Authenticator</h2><p>认证器</p>\n<h2 id=\"Authorizer\"><a href=\"#Authorizer\" class=\"headerlink\" title=\"Authorizer\"></a>Authorizer</h2><p>授权器</p>\n<h2 id=\"SessionManager\"><a href=\"#SessionManager\" class=\"headerlink\" title=\"SessionManager\"></a>SessionManager</h2><p>Session管理器</p>\n<h2 id=\"SessionDao\"><a href=\"#SessionDao\" class=\"headerlink\" title=\"SessionDao\"></a>SessionDao</h2><h2 id=\"CacheManager\"><a href=\"#CacheManager\" class=\"headerlink\" title=\"CacheManager\"></a>CacheManager</h2><p>缓存管理器，对session和授权数据做缓存</p>\n<h2 id=\"Cryptography\"><a href=\"#Cryptography\" class=\"headerlink\" title=\"Cryptography\"></a>Cryptography</h2><p>密码管理，加密和解密组件</p>\n<h2 id=\"Realm\"><a href=\"#Realm\" class=\"headerlink\" title=\"Realm\"></a>Realm</h2><p>域，要通过realm进行 存取认证、授权相关数据</p>\n<h1 id=\"三、核心功能\"><a href=\"#三、核心功能\" class=\"headerlink\" title=\"三、核心功能\"></a>三、核心功能</h1><h2 id=\"自定义Realm\"><a href=\"#自定义Realm\" class=\"headerlink\" title=\"自定义Realm\"></a>自定义Realm</h2><p>写一个类继承AuthorizingRealm<br>重写认证和授权方法<br><img src=\"/2020/09/07/Shiro/%E8%87%AA%E5%AE%9A%E4%B9%89relam.png\"></p>\n<h3 id=\"自定义认证\"><a href=\"#自定义认证\" class=\"headerlink\" title=\"自定义认证\"></a>自定义认证</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#96;&#96;&#96;</span><br><span class=\"line\">### 自定义授权</span><br></pre></td></tr></table></figure>\n<p>//角色<br>subject.hasRoles(roleList)<br>//权限<br>permisson格式是key-word（role：permisson）<br>subject.isPermitted(permissonList)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">![](授权.png)</span><br><span class=\"line\">## 自定义SessionManager</span><br><span class=\"line\">写一个类集成DeafultWebSessionMangaer，并重新getSessionManager</span><br><span class=\"line\"></span><br><span class=\"line\">## 配置类ShiroConfig</span><br><span class=\"line\">在ShiroConfig类中，主要配置SecurityManager</span><br><span class=\"line\">可以将自定义的Realm、SessionManager配置到SecurityManager中。</span><br><span class=\"line\"></span><br><span class=\"line\">### 自定义ShiroFilter</span><br><span class=\"line\">配置类中自定义Filter，可以实现匿名访问，或者未登陆重定向</span><br><span class=\"line\"></span><br><span class=\"line\">### 配置AOP，实现权限验证</span><br><span class=\"line\"></span><br><span class=\"line\"># 四、SpringBoot中引入shiro</span><br><span class=\"line\"></span><br><span class=\"line\">## 导包 Shiro-Spring</span><br><span class=\"line\">shiro-spring:包含shiro-core和shiro-web</span><br></pre></td></tr></table></figure>\n<dependency>\n    <groupId>org.apache.shiro</groupId>\n    <artifactId>shiro-spring</artifactId>\n    <version>1.4.1</version>\n</dependency>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">## 自定义相应功能</span><br><span class=\"line\"></span><br><span class=\"line\">## 注册组件</span><br><span class=\"line\">ShiroFilterFactoryBean</span><br><span class=\"line\">认证的Map</span><br><span class=\"line\">Filter处理url请求</span><br><span class=\"line\">例如loginUrl，如果没有通过认证，则重定向到默认的loginUrl</span><br><span class=\"line\"></span><br><span class=\"line\">DefaultWebSecurityManager</span><br><span class=\"line\"></span><br><span class=\"line\"># 五、案例</span><br><span class=\"line\">## 案例1 login</span><br><span class=\"line\">### 配置类ShiroConfig</span><br><span class=\"line\">1. 自定义Realm的授权和认证规则</span><br><span class=\"line\">2. 配置Realm进SecurityManager，并把SecurityManager配置为Bean</span><br><span class=\"line\">3. 配置ShiroFilterFactoryBean：用来创建SecurityManager，以及配置过滤链</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n@Configuration\npublic class ShiroConfig {\n\n<pre><code>//自定义Realm\n@Bean(&quot;customRealm&quot;)\npublic Realm getRelam() &#123;\n    return new CustomRealm();\n&#125;\n\n//将自定义Realm装入SecurityManager\n@Bean(&quot;deaultWebSecurityManager&quot;)\npublic DefaultWebSecurityManager getSecurityManager(@Qualifier(&quot;customRealm&quot;) Realm customRealm) &#123;\n    DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();\n    defaultSecurityManager.setRealm(customRealm);\n    return defaultSecurityManager;\n&#125;\n\n//将SecurityManager放入ShiroFilter工厂里\n@Bean\npublic ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(&quot;deaultWebSecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager) &#123;\n    ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n    shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);\n    //创建过滤链\n    Map&lt;String, String&gt; filterMap = new HashMap&lt;String, String&gt;();\n    filterMap.put(&quot;/login&quot;, &quot;authc&quot;);\n    shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);\n    shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);\n\n    return shiroFilterFactoryBean;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">### 登陆时使用</span><br><span class=\"line\">1. 获得SecurityManager</span><br></pre></td></tr></table></figure>\n<p>SecurityManager securityManager = securityManagerFactory.getInstance();</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">2. 通过获取Subject</span><br><span class=\"line\">3. Subject执行认证登陆</span><br><span class=\"line\"></span><br><span class=\"line\">## 角色认证</span><br><span class=\"line\">### 需要自己实现的method</span><br><span class=\"line\">doGetAuthentication</span><br><span class=\"line\">## 角色授权</span><br></pre></td></tr></table></figure>\n<p>subject.hasRole<br>subject.hasRoles<br>subject.hasAllRoles</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">## 权限验证</span><br></pre></td></tr></table></figure>\n<p>subject.isPermitted()<br>subject.isPermittedAll()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 默认拦截器</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>String</th>\n<th>Class</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>authc</td>\n<td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td>\n<td>基于表单的拦截器：如 “<code>/**=authc</code>”，如果没有登录会跳到相应的登录页面登录；<br>主要属性：<br>usernameParam：表单提交的用户名参数名（ username）；<br>passwordParam：表单提交的密码参数名（password）；<br>rememberMeParam：表单提交的密码参数名（rememberMe）；<br>loginUrl：登录页面地址（/login.jsp）；<br>successUrl：登录成功后的默认重定向地址；<br>failureKeyAttribute：登录失败后错误信息存储 key（shiroLoginFailure）；</td>\n</tr>\n<tr>\n<td>authcBasic</td>\n<td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td>\n<td>Basic HTTP 身份验证拦截器，主要属性： applicationName：弹出登录框显示的信息（application）；</td>\n</tr>\n<tr>\n<td>logout</td>\n<td>org.apache.shiro.web.filter.authc.LogoutFilter</td>\n<td>退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/）; 示例 “/logout=logout”</td>\n</tr>\n<tr>\n<td>user</td>\n<td>org.apache.shiro.web.filter.authc.UserFilter</td>\n<td>用户拦截器，用户已经身份验证 / 记住我登录的都可；示例 “/**=user”</td>\n</tr>\n<tr>\n<td>anon</td>\n<td>org.apache.shiro.web.filter.authc.AnonymousFilter</td>\n<td>匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例 “/static/**=anon”</td>\n</tr>\n</tbody></table>\n<pre><code>\n\n\n\n</code></pre>\n","categories":["框架"],"tags":["安全校验"]},{"title":"Spring-AOP","url":"/2020/08/20/Spring-AOP/","content":"<h1 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h1><p>什么是AOP：<br>AOP是面向切面编程，Aspect Oriented Programming</p>\n<h2 id=\"AOP应用场景\"><a href=\"#AOP应用场景\" class=\"headerlink\" title=\"AOP应用场景\"></a>AOP应用场景</h2><ol>\n<li>日志记录</li>\n<li>权限验证</li>\n<li>效率检查</li>\n<li>事务管理</li>\n<li>异常处理</li>\n<li>…</li>\n</ol>\n<span id=\"more\"></span>\n\n<h1 id=\"SpringAOP的基础\"><a href=\"#SpringAOP的基础\" class=\"headerlink\" title=\"SpringAOP的基础\"></a>SpringAOP的基础</h1><h2 id=\"Aspect（切面）\"><a href=\"#Aspect（切面）\" class=\"headerlink\" title=\"Aspect（切面）\"></a>Aspect（切面）</h2><p>穿过多个类而切成的模块化概念。可以理解为JoinPoint+Advice+PointCut<br>Aspect: A modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).</p>\n<h2 id=\"JoinPoint（连接点）\"><a href=\"#JoinPoint（连接点）\" class=\"headerlink\" title=\"JoinPoint（连接点）\"></a>JoinPoint（连接点）</h2><p>程序运行中的某一点，指通知可以加强的位置<br>Join point: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p>\n<h2 id=\"Advice（通知）\"><a href=\"#Advice（通知）\" class=\"headerlink\" title=\"Advice（通知）\"></a>Advice（通知）</h2><p>描述如何在JoinPoint执行AOP加强的逻辑<br>Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.</p>\n<h2 id=\"PointCut（切点）\"><a href=\"#PointCut（切点）\" class=\"headerlink\" title=\"PointCut（切点）\"></a>PointCut（切点）</h2><p>满足JoinPoint执行的地方<br>Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.</p>\n<h2 id=\"Interduction（）\"><a href=\"#Interduction（）\" class=\"headerlink\" title=\"Interduction（）\"></a>Interduction（）</h2><p>Introduction: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)</p>\n<h2 id=\"TargetObject（目标对象）\"><a href=\"#TargetObject（目标对象）\" class=\"headerlink\" title=\"TargetObject（目标对象）\"></a>TargetObject（目标对象）</h2><p>被执行advice之前的对象。<br>Target object: An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.</p>\n<h2 id=\"AOP-proxy（AOP代理对象）\"><a href=\"#AOP-proxy（AOP代理对象）\" class=\"headerlink\" title=\"AOP proxy（AOP代理对象）\"></a>AOP proxy（AOP代理对象）</h2><p>AOP代理对象<br>An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.</p>\n<h2 id=\"Weaving（织入）\"><a href=\"#Weaving（织入）\" class=\"headerlink\" title=\"Weaving（织入）\"></a>Weaving（织入）</h2><p>增强的过程<br>linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.</p>\n<h1 id=\"SpringAOP使用\"><a href=\"#SpringAOP使用\" class=\"headerlink\" title=\"SpringAOP使用\"></a>SpringAOP使用</h1><h2 id=\"使用AspectJ代码风格\"><a href=\"#使用AspectJ代码风格\" class=\"headerlink\" title=\"使用AspectJ代码风格\"></a>使用AspectJ代码风格</h2><h3 id=\"1-配置Config启用AspectJ风格\"><a href=\"#1-配置Config启用AspectJ风格\" class=\"headerlink\" title=\"1. 配置Config启用AspectJ风格\"></a>1. 配置Config启用AspectJ风格</h3><ol>\n<li>JavaConfig<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppConfig</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li>XML<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"2-定义Aspect\"><a href=\"#2-定义Aspect\" class=\"headerlink\" title=\"2. 定义Aspect\"></a>2. 定义Aspect</h3><p>包含以下三个内容：</p>\n<ol>\n<li>PointCut</li>\n<li>JoinPoint（切点表达式/注解）</li>\n<li>Advice（定义哪些PointCut执行加强）</li>\n</ol>\n<p>PointCut只是一个载体，里面直接包含了所有有JointPoints</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//参数是连接点表达式（JoinPoint）</span></span><br><span class=\"line\">    <span class=\"meta\">@PointCut(&quot;execution(&quot;void * *.*.function(..)&quot;)&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">myPointCut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;这是一个切点&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;myPointCut()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">myAdvice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;这是一个Before的建议&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>带?表示可以省略<br>切点表达式：execution( [修饰符?]  [返回值类型]  [包名.类名.方法名(参数)?]  [异常?])</p><ol><li>修饰符可以省略</li><li>返回值、包名、类名、方法名都可以用 * 来表示任意</li><li>包名、类名之间 .. 表示子包或者子类</li><li>参数 .. 表示任意个数参数</li></ol>\n          </div>\n\n<h3 id=\"Advice-PointCut\"><a href=\"#Advice-PointCut\" class=\"headerlink\" title=\"Advice + PointCut\"></a>Advice + PointCut</h3><ol>\n<li>@before</li>\n</ol>\n<ol start=\"2\">\n<li>@after</li>\n</ol>\n<ol start=\"3\">\n<li>@around<br>环绕通知，需要使用ProcessingJoinPoint这个参数。</li>\n</ol>\n<p>ProcessingJoinPoint和JoinPoint的区别：process()，这个方法让原方法继续执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;myAspect&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAspect</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Before(&quot;execution(void aspectj.func.MyTarget.*())&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;前置增强&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@After(&quot;execution(void aspectj.func.MyTarget.*())&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">after</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;后置增强&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"JoinPoint的定义\"><a href=\"#JoinPoint的定义\" class=\"headerlink\" title=\"JoinPoint的定义\"></a>JoinPoint的定义</h4><ol>\n<li>连接点表达式</li>\n</ol>\n<ul>\n<li><p>execution( [修饰符?]  [返回值类型]  [包名.类名.方法名(参数)?]  [异常?]) </p>\n<p>指定类的某个方法</p>\n</li>\n<li><p>within([包名.类名]) </p>\n<p>对该类的所有方法都作为切点</p>\n</li>\n<li><p>this([包名.类名], 代理参数？)</p>\n<p>返回类型是这个类的同一个对象的时候，作为切点<br>如果要Cglib代理类和该类作为同一个，要加代理参数proxyTargetClass=true</p>\n</li>\n<li><p>target([包名.类名])</p>\n<p>将该类的代理对象，作为切点</p>\n</li>\n<li><p>args(参数的类型)：按照参数做切点</p>\n</li>\n<li><p>anotation(注解)：按照注解做切点</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>注解方式</li>\n</ol>\n<ul>\n<li>@within</li>\n<li>@anotaion</li>\n<li>@this</li>\n<li>@target</li>\n<li>@args</li>\n</ul>\n<div class=\"note info\">\n            <p>可以用注解灵活的写一些切点逻辑，详细可以见Spring官方文档</p>\n          </div>\n\n<h2 id=\"Schema-base（不常用）\"><a href=\"#Schema-base（不常用）\" class=\"headerlink\" title=\"Schema-base（不常用）\"></a>Schema-base（不常用）</h2><h1 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h1><h2 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h2><p>继承Proxy类并实现了接口<br>I extends proxy implements Interface</p>\n<h2 id=\"Cglib动态代理\"><a href=\"#Cglib动态代理\" class=\"headerlink\" title=\"Cglib动态代理\"></a>Cglib动态代理</h2><p>继承了原实现类Impl进行代理</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p>createBean()方法：负责创建target和proxy<br>target创建：<br>proxy创建：initializeBean() ——————</p>\n<h1 id=\"HandlerInterceptor\"><a href=\"#HandlerInterceptor\" class=\"headerlink\" title=\"HandlerInterceptor\"></a>HandlerInterceptor</h1><p>实际上是AOP思想的一种实现。可以当作AOP的一种</p>\n<h1 id=\"SpringAOP表达式\"><a href=\"#SpringAOP表达式\" class=\"headerlink\" title=\"SpringAOP表达式\"></a>SpringAOP表达式</h1><h2 id=\"execution\"><a href=\"#execution\" class=\"headerlink\" title=\"execution\"></a>execution</h2><h2 id=\"within\"><a href=\"#within\" class=\"headerlink\" title=\"within\"></a>within</h2><p>针对类下的所有方法执行切入</p>\n<h2 id=\"args\"><a href=\"#args\" class=\"headerlink\" title=\"args\"></a>args</h2><p>针对参数是(xxx)的方法进行切入</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>被执行的代理类就是this里面的类，就对它的方法执行切入</p>\n<h2 id=\"target\"><a href=\"#target\" class=\"headerlink\" title=\"target\"></a>target</h2><p>被执行的目标类如果是里面的类，就对它的方法执行切入<br>就是原类</p>\n<h2 id=\"annotation\"><a href=\"#annotation\" class=\"headerlink\" title=\"annotation\"></a>annotation</h2><p>针对添加对应注解的方法执行切入</p>\n<h2 id=\"混合表达式\"><a href=\"#混合表达式\" class=\"headerlink\" title=\"混合表达式\"></a>混合表达式</h2><p>表达式前加 ! 可以表示不切入</p>\n<h1 id=\"一些源码细节\"><a href=\"#一些源码细节\" class=\"headerlink\" title=\"一些源码细节\"></a>一些源码细节</h1><h2 id=\"代理对象什么时候执行代理的？\"><a href=\"#代理对象什么时候执行代理的？\" class=\"headerlink\" title=\"代理对象什么时候执行代理的？\"></a>代理对象什么时候执行代理的？</h2><p>单例模式，在Spring初始化组件的时候就生成代理类</p>\n<h2 id=\"目标对象去哪里了？\"><a href=\"#目标对象去哪里了？\" class=\"headerlink\" title=\"目标对象去哪里了？\"></a>目标对象去哪里了？</h2><p>目标对象被丢弃，直接生成的是一个代理类</p>\n","categories":["框架"],"tags":["Spring","SpringFramework"]},{"title":"Spring-IOC","url":"/2020/08/19/Spring-IOC/","content":"<h1 id=\"Spring简介\"><a href=\"#Spring简介\" class=\"headerlink\" title=\"Spring简介\"></a>Spring简介</h1><p>Spring容器<br><br></p>\n<h2 id=\"Inverse-Of-Control-控制反转\"><a href=\"#Inverse-Of-Control-控制反转\" class=\"headerlink\" title=\"Inverse Of Control 控制反转\"></a>Inverse Of Control 控制反转</h2><p>字面意思就是原先是自己New出来的，现在交给Spring来创建，实例由Spring容器管理（将控制权交出去）<br><br></p>\n<h2 id=\"Dependency-Injection\"><a href=\"#Dependency-Injection\" class=\"headerlink\" title=\"Dependency Injection\"></a>Dependency Injection</h2><p>讨论的对象是Spring容器和应用程序：A依赖B，就将B注入A<br><br></p>\n<span id=\"more\"></span>\n<hr>\n<br>\n\n<h1 id=\"案例1：使用Spring管理实例-Maven项目\"><a href=\"#案例1：使用Spring管理实例-Maven项目\" class=\"headerlink\" title=\"案例1：使用Spring管理实例(Maven项目)\"></a><em>案例1：使用Spring管理实例(Maven项目)</em></h1><table>\n<thead>\n<tr>\n<th align=\"left\">接口</th>\n<th align=\"left\">接口实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Luck</td>\n<td align=\"left\">LuckImp</td>\n</tr>\n<tr>\n<td align=\"left\">\b\b创造幸运</td>\n<td align=\"left\">实现创造幸运的实例</td>\n</tr>\n</tbody></table>\n<h2 id=\"step-1-创建类\"><a href=\"#step-1-创建类\" class=\"headerlink\" title=\"step.1 创建类\"></a>step.1 创建类</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;接口</span><br><span class=\"line\">public interface Luck</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpublic void CreateLuck();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;实现类</span><br><span class=\"line\">public class LuckImp implements Luck</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void CreateLuck()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Show your the Luck!&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step-2-引入依赖\"><a href=\"#step-2-引入依赖\" class=\"headerlink\" title=\"step.2 引入依赖\"></a>step.2 引入依赖</h2><p>在pom.xml中引入Spring依赖<br>具体的配置可以在<a href=\"https://mvnrepository.com/\">mvnrepository.com</a>搜索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;5.2.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class=\"line\">    &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step-3-写配置文件\"><a href=\"#step-3-写配置文件\" class=\"headerlink\" title=\"step.3 写配置文件\"></a>step.3 写配置文件</h2><p>因为xml文档都有格式，为了spring的配置文件增加的节点能满足要求、合法，所以引入校验该xml的格式文件。<br>xmlns是xml命名空间的意思，而xmlns:xsi是指xml所遵守的标签规范。<br><strong>1.xmlns：关于初始化bean的格式文件地址</strong><br><strong>2.xmlns:xsi：辅助初始化bean</strong><br><strong>3.xsi:context：关于spring上下文，包括加载资源文件</strong><br><strong>4.xsi:schemaLocation：用于声明了目标名称空间的模式文档</strong></p>\n<p>在resources下创建xxx.xml文件，并添加<code>&lt;bean id = &quot;xxx&quot; class=&quot;xxx&quot;/&gt;</code><br><strong>id是组件名，class就是对应的接口实现类</strong><br>配置文件的约束可以在<a href=\"https://spring.io/\">Spring官网</a>-SpringFrame-Learn-Reference Doc-Appendix内获得</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/aop</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--id组件在容器中的标识--&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--class组件的全类名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;Luck&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;Practice.SpringCaseOne.Product.LuckImp&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step-4-使用组件\"><a href=\"#step-4-使用组件\" class=\"headerlink\" title=\"step.4 使用组件\"></a>step.4 使用组件</h2><table>\n<thead>\n<tr>\n<th>接口</th>\n<th>向上继承</th>\n<th>向下实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>ApplicationContext</strong></td>\n<td><strong>BeanFactory</strong></td>\n<td><strong>ClassPathXmlApplicationContext</strong>/<strong>FileSystemXmlApplicationContext</strong></td>\n</tr>\n</tbody></table>\n<p>使用<strong>ClassPathXmlApplicationContext</strong>/<strong>FileSystemXmlApplicationContext</strong>获取对应的xml配置文件</p>\n<ul>\n<li><em>ClassPath:使用类的相对路径，只要xml配置文件路径存放正确，写“xxx.xml”即可</em></li>\n<li><em>FileSystem:使用全路径</em></li>\n</ul>\n<p>利用<strong>ApplicationContext</strong>获得对应的配置对象，再用对应的getBean获取对应的<strong>接口实现类</strong></p>\n<p>三种从容器中取出方式:</p>\n<table>\n<thead>\n<tr>\n<th>按组件名取出</th>\n<th>按实现接口类取出</th>\n<th>按照组件名+实现接口类取出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>applicationContext.getBean(“xxx”)</td>\n<td>applicationContext.getBean(xxxImp.class)</td>\n<td>applicationContext.getBean(“xxx”, xxxImp.class)</td>\n</tr>\n<tr>\n<td>如果只有唯一的组件名</td>\n<td>如果只有一个实现类</td>\n<td>多个实现类的前提</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void run()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;加载Spring配置文件（ClassPath模式）</span><br><span class=\"line\">\tApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;SpringCaseOne.xml&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;根据Id取出来</span><br><span class=\"line\">\t&#x2F;&#x2F;LuckImp luckImp &#x3D; (LuckImp) applicationContext.getBean(&quot;LuckImp&quot;);</span><br><span class=\"line\">\t&#x2F;&#x2F;根据类的class类型取出来（类型的组件容器只能有一个）</span><br><span class=\"line\">\t&#x2F;&#x2F;LuckImp luckImp &#x3D; applicationContext.getBean(LuckImp.class);</span><br><span class=\"line\">\t&#x2F;&#x2F;通过Id和类型共同获得（获得的就直接是个接口实例）</span><br><span class=\"line\">\tLuck luck &#x3D; applicationContext.getBean(&quot;Luck&quot;, Luck.class);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;使用实例</span><br><span class=\"line\">\tluck.CreateLuck();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n<br>\n\n<hr>\n<br>\n\n<h1 id=\"案例2-Spring管理实例时并初始化字段\"><a href=\"#案例2-Spring管理实例时并初始化字段\" class=\"headerlink\" title=\"案例2. Spring管理实例时并初始化字段*\"></a>案例2. Spring管理实例时并初始化字段*</h1><br>\n该案例的前提是，一个类的成员变量是另一个类的实例，实际上就是一种依赖。\n因此Spring管理可以在A实例化的同时，附带实例化B\n\n<table>\n<thead>\n<tr>\n<th>接口1</th>\n<th>接口2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LuckDao</td>\n<td>LuckService</td>\n</tr>\n<tr>\n<td>实现类1</td>\n<td>实现类2</td>\n</tr>\n<tr>\n<td>LuckDaoImp</td>\n<td>LuckServiceImp</td>\n</tr>\n</tbody></table>\n<h2 id=\"step-1-创建对应类\"><a href=\"#step-1-创建对应类\" class=\"headerlink\" title=\"step.1 创建对应类\"></a>step.1 创建对应类</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Dao的实现类</span><br><span class=\"line\">import Practice.SpringCaseTwo.Dependency.Interface.LuckDao;</span><br><span class=\"line\"></span><br><span class=\"line\">public class LuckDaoImp implements LuckDao</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void doLuckDao()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Do Luck Dao&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;service的实现类</span><br><span class=\"line\">import Practice.SpringCaseTwo.Dependency.Interface.LuckDao;</span><br><span class=\"line\">import Practice.SpringCaseTwo.Dependency.Interface.LuckService;</span><br><span class=\"line\"></span><br><span class=\"line\">public class LuckServiceImp implements LuckService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;不用实例化，Spring会进行实例化管理</span><br><span class=\"line\">\tLuckDao luckDao;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;一定要设置set依赖类的方法</span><br><span class=\"line\">\tpublic void setLuckDao(LuckDaoImp luckDao)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis.luckDao &#x3D; luckDao;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void doLuckService()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tluckDao.doLuckDao();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step-2-导入依赖\"><a href=\"#step-2-导入依赖\" class=\"headerlink\" title=\"step.2 \b导入依赖\"></a>step.2 \b导入依赖</h2><p>…<br><br></p>\n<h2 id=\"step-3-写配置文件实现类依赖\"><a href=\"#step-3-写配置文件实现类依赖\" class=\"headerlink\" title=\"step.3 写配置文件实现类依赖\"></a>step.3 写配置文件实现类依赖</h2><p>在配置文件下，要表明A、B依赖。先注册B实现类，再注册A实现类，然后在子标签下定义属性：A依赖B</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id&#x3D;&quot;LuckDao&quot; class&#x3D;&quot;Practice.SpringCaseTwo.Dependency.Imp.LuckDaoImp&quot;&#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id&#x3D;&quot;LuckService&quot; class&#x3D;&quot;Practice.SpringCaseTwo.Dependency.Imp.LuckServiceImp&quot;&gt;</span><br><span class=\"line\">        &lt;property name&#x3D;&quot;LuckDao&quot; ref&#x3D;&quot;LuckDao&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step-4-使用组件-1\"><a href=\"#step-4-使用组件-1\" class=\"headerlink\" title=\"step.4 使用组件\"></a>step.4 使用组件</h2><p>…<br><br></p>\n<hr>\n<br>\n\n<h1 id=\"Bean的实例化\"><a href=\"#Bean的实例化\" class=\"headerlink\" title=\"Bean的实例化\"></a>Bean的实例化</h1><p>工具类：<strong>lombok</strong>，可以使用注解来自动添加get、set、toString等方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;pom.xml依赖</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.18.12&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<br>\n<br>\n\n<h2 id=\"利用构造方法\"><a href=\"#利用构造方法\" class=\"headerlink\" title=\"利用构造方法\"></a>利用构造方法</h2><p><strong>1. 无参构造: bean标签使用property</strong></p>\n<p>本质是使用set方法构造</p>\n<p>Java类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">@Data</span><br><span class=\"line\">public class NoParam</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tString userName;</span><br><span class=\"line\"></span><br><span class=\"line\">\tString password;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>xml配置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean class&#x3D;&quot;Practice.BeanConstructor.NoParam&quot;&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;userName&quot; value&#x3D;&quot;zhangsan&quot;&#x2F;&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<p><strong>2. 有参构造: bean标签使用constructor-arg</strong></p>\n<p>Java类:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import lombok.AllArgsConstructor;</span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">@Data</span><br><span class=\"line\">@AllArgsConstructor</span><br><span class=\"line\">public class HasParam</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tString userName;</span><br><span class=\"line\">\tString password;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>xml配置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean class&#x3D;&quot;Practice.BeanConstructor.HasParam&quot;&gt;</span><br><span class=\"line\">    &lt;constructor-arg name&#x3D;&quot;userName&quot; value&#x3D;&quot;tian&quot;&#x2F;&gt;</span><br><span class=\"line\">    &lt;constructor-arg name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h2><h3 id=\"静态工厂\"><a href=\"#静态工厂\" class=\"headerlink\" title=\"静态工厂\"></a><strong>静态工厂</strong></h3><p>静态工厂，直接在xml配置文件中注册并且使用 factory-method=“方法名”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id&#x3D;&quot;moneyFromStaticFactory&quot; class&#x3D;&quot;Practice.Factory.StaticMoneyFactory&quot; factory-method&#x3D;&quot;createMoney&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"非静态工厂\"><a href=\"#非静态工厂\" class=\"headerlink\" title=\"非静态工厂\"></a><strong>非静态工厂</strong></h3><p>非静态工厂，需要先注册工厂实例，再注册工厂创建实例，依赖工厂实例（factory-bean=“工厂实例id“），并指明工厂方法（factory-method=“方法名”）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id&#x3D;&quot;instanceFactory&quot; class&#x3D;&quot;Practice.Factory.InstanceMoneyFactory&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;bean id&#x3D;&quot;moneyFromInstanceFactory&quot; factory-bean&#x3D;&quot;instanceFactory&quot; factory-method&#x3D;&quot;createMoney&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"XXXFactoryBean\"><a href=\"#XXXFactoryBean\" class=\"headerlink\" title=\"XXXFactoryBean\"></a>XXXFactoryBean</h2><p>顾名思义：就是一个封装的Bean，但是专门生成对应的XXX实例；Spring就提供了许多xxxFactoryBean，例如ProxyFactoryBean<br>BeanFactory:可以生成任何实例<br>XXXFactoryBean:生成对应的XXX实例<br>需要在XXXFactoryBean中 implements FactoryBean<T><br>并重写对应的getObject和getObjectType方法<br>对应的Object类要有成员字段和对应的set方法</T></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Money类</span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;注释定义set方法</span><br><span class=\"line\">@Data</span><br><span class=\"line\">public class Money</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tString price;</span><br><span class=\"line\">\tString currency;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;MoneyFactory类</span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\">import org.springframework.beans.factory.FactoryBean;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;注释定义set方法，因为成员字段的值Spring会从xml获取，然后初始化set到该实例</span><br><span class=\"line\">@Data</span><br><span class=\"line\">public class MoneyFactoryBean implements FactoryBean&lt;Money&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;对应的成员字段</span><br><span class=\"line\">\tString price;</span><br><span class=\"line\">\tString currency;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Money getObject() throws Exception</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tMoney money &#x3D; new Money();</span><br><span class=\"line\">\t\t&#x2F;&#x2F;此处的set是依赖于money的set，而xml的属性依赖于该工厂的set</span><br><span class=\"line\">\t\tmoney.setPrice(price);</span><br><span class=\"line\">\t\tmoney.setCurrency(currency);</span><br><span class=\"line\">\t\treturn money;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Class&lt;?&gt; getObjectType()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn Money.class;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;xml配置文件，只用注册XXXFactoryBean即可，然后给对应成员字段赋值</span><br><span class=\"line\">&lt;bean class&#x3D;&quot;Practice.FactoryBean.MoneyFactoryBean&quot;&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;price&quot; value&#x3D;&quot;1000&quot;&#x2F;&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;currency&quot; value&#x3D;&quot;RMB&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h1 id=\"Spring容器的Bean的作用域\"><a href=\"#Spring容器的Bean的作用域\" class=\"headerlink\" title=\"Spring容器的Bean的作用域\"></a>Spring容器的Bean的作用域</h1><ul>\n<li><p>singleton（默认）<br>单例，即任何时候取出的时候，都是同一个实例。默认不配置时即为单例</p>\n</li>\n<li><p>prototype<br>每次取出的时候都会新建一个实例</p>\n</li>\n</ul>\n<p>可以定义Spring容器Bean的作用域范围, bean标签中，scope=”….”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--singleton的作用范围，始终是个单例，默认的也是singleton--&gt;</span><br><span class=\"line\">&lt;bean class&#x3D;&quot;Practice.BeanScope.SingletonBean&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;!--prototype的作用范围，是每次都会生成一个新的实例--&gt;</span><br><span class=\"line\">&lt;bean class&#x3D;&quot;Practice.BeanScope.PrototypeBean&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h1 id=\"Bean的生命周期（重要）\"><a href=\"#Bean的生命周期（重要）\" class=\"headerlink\" title=\"Bean的生命周期（重要）\"></a><strong>Bean的生命周期（重要）</strong></h1><h1 id=\"CollectionBean\"><a href=\"#CollectionBean\" class=\"headerlink\" title=\"CollectionBean\"></a>CollectionBean</h1>","categories":["框架"],"tags":["Spring"]},{"title":"Spring-MVC","url":"/2020/08/20/Spring-MVC/","content":"<p>SpringMVC是Spring框架里的一员，负责web表示层的解决方案</p>\n<h1 id=\"SpringMVC的优点\"><a href=\"#SpringMVC的优点\" class=\"headerlink\" title=\"SpringMVC的优点\"></a>SpringMVC的优点</h1><ol>\n<li>Spring MVC中提供一个DispatcherServlet, 无需额外开发。(即运行一个Servlet就行)</li>\n<li>springMVC中使用基于xml的配置文件，可以编辑，无需重新编译应用程序。</li>\n<li>SpringMVC可以实例化控制器（Controller），并根据用户的输入来构造bean。</li>\n<li>SpringMVC可以自动绑定用户输入，并正确的转换数据类型。</li>\n<li>SpringMVC内置了校验器，可以检验用户输入，不通过则重定向输入表单。</li>\n<li>SpringMVC支持多种试图技术</li>\n<li>…等<span id=\"more\"></span></li>\n</ol>\n<h2 id=\"说人话，Controller是一个类，Handler是类中的处理方法\"><a href=\"#说人话，Controller是一个类，Handler是类中的处理方法\" class=\"headerlink\" title=\"说人话，Controller是一个类，Handler是类中的处理方法\"></a><strong><em>说人话，Controller是一个类，Handler是类中的处理方法</em></strong></h2><h1 id=\"SpringMVC结构\"><a href=\"#SpringMVC结构\" class=\"headerlink\" title=\"SpringMVC结构\"></a>SpringMVC结构</h1><ol>\n<li>DispatcherServlet</li>\n<li>Controller: 负责注册Handler</li>\n<li>HandlerMapping</li>\n<li>HandlerAdapter</li>\n<li>ViewResolver</li>\n<li>Validator</li>\n<li>Command</li>\n<li>FormObject</li>\n<li>自己实现的Handler</li>\n</ol>\n<hr>\n<h1 id=\"Spring框架流程\"><a href=\"#Spring框架流程\" class=\"headerlink\" title=\"Spring框架流程\"></a>Spring框架流程</h1><p>待添加</p>\n<hr>\n<h1 id=\"案例1\"><a href=\"#案例1\" class=\"headerlink\" title=\"案例1\"></a>案例1</h1><h2 id=\"step1-导包-pom-xml\"><a href=\"#step1-导包-pom-xml\" class=\"headerlink\" title=\"step1. 导包(pom.xml)\"></a>step1. 导包(pom.xml)</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;5.2.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br><span class=\"line\">&#x2F;&#x2F;该依赖负责Servlet</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.0.1&lt;&#x2F;version&gt;</span><br><span class=\"line\">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step2-配置DispatcherServlet-web-xml-tip-该方法不常用，常用SpringConfig\"><a href=\"#step2-配置DispatcherServlet-web-xml-tip-该方法不常用，常用SpringConfig\" class=\"headerlink\" title=\"step2. 配置DispatcherServlet(web.xml) [tip:该方法不常用，常用SpringConfig]\"></a>step2. 配置DispatcherServlet(web.xml) [tip:该方法不常用，常用SpringConfig]</h2><p>先配置Servlet；<br>再配置子标签init-param，把Spring配置文件引入进来，使得Servlet可以应用Spring；<br>最后添加Servlet-Mapping配置映射范围。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;servlet&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class=\"line\">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class=\"line\">    &lt;init-param&gt;</span><br><span class=\"line\">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class=\"line\">        &lt;param-value&gt;classpath:application.xml&lt;&#x2F;param-value&gt;</span><br><span class=\"line\">    &lt;&#x2F;init-param&gt;</span><br><span class=\"line\">&lt;&#x2F;servlet&gt;</span><br><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class=\"line\">    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class=\"line\">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step3-Spring的application-xml中配置HandlerMapping和HandlerAdapter\"><a href=\"#step3-Spring的application-xml中配置HandlerMapping和HandlerAdapter\" class=\"headerlink\" title=\"step3. Spring的application.xml中配置HandlerMapping和HandlerAdapter\"></a>step3. Spring的application.xml中配置HandlerMapping和HandlerAdapter</h2><p>在resources下创建application.xml，并添加对应的SpringMVC组件<br>HandlerMapping: BeanNameUrlHandlerMapping, 组件和url建立映射关系<br>HanderAdapter: SimpleControllerHandlerAdapter, 简单控制器的适配器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--扫包--&gt;</span><br><span class=\"line\">&lt;context:component-scan base-package&#x3D;&quot;practice&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;!--组件id和Url建立映射--&gt;</span><br><span class=\"line\">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;!--简单控制器的适配器--&gt;</span><br><span class=\"line\">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step4-handler注册\"><a href=\"#step4-handler注册\" class=\"headerlink\" title=\"step4. handler注册\"></a>step4. handler注册</h2><p>写一个Handler类，实现Controller接口(注意要和IOC的Controller做区分，IOC的Controller是用作注解的），并且注册为Spring组件；<br>重写handleRequest方法（实际上是依靠Request和Response来实现）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;注册组件，组件id作为url</span><br><span class=\"line\">@Component(&quot;&#x2F;first&quot;)</span><br><span class=\"line\">public class FirstHandler implements Controller</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;创建一个ModelAndView实例</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\t&#x2F;&#x2F;设置View组件</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\t&#x2F;&#x2F;传递Model,attributeName是jsp对应的参数名，attributeValue是值</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;, &quot;EternalEva&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"运行并在浏览器访问对应url即可\"><a href=\"#运行并在浏览器访问对应url即可\" class=\"headerlink\" title=\"运行并在浏览器访问对应url即可\"></a>运行并在浏览器访问对应url即可</h2><h2 id=\"案例1分析\"><a href=\"#案例1分析\" class=\"headerlink\" title=\"案例1分析\"></a>案例1分析</h2><p>手写Handler类，然后继承Controller<br>并且在web.xml中每一个url配置映射一个handler组件（handler以组件方式存在），跟每一个url写一个servlet没有区别</p>\n<hr>\n<h1 id=\"案例2\"><a href=\"#案例2\" class=\"headerlink\" title=\"案例2\"></a>案例2</h1><h2 id=\"step1-导包\"><a href=\"#step1-导包\" class=\"headerlink\" title=\"step1. 导包\"></a>step1. 导包</h2><p>同上，略… <br><br></p>\n<h2 id=\"step2-web-xml配置\"><a href=\"#step2-web-xml配置\" class=\"headerlink\" title=\"step2. web.xml配置\"></a>step2. web.xml配置</h2><p>同上，略…<br><br></p>\n<h2 id=\"step3-Spring的application-xml配置\"><a href=\"#step3-Spring的application-xml配置\" class=\"headerlink\" title=\"step3. Spring的application.xml配置\"></a>step3. Spring的application.xml配置</h2><p>添加MVC的xml配置，以及mvc注解驱动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class=\"line\">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--组件扫包--&gt;</span><br><span class=\"line\">&lt;context:component-scan base-package&#x3D;&quot;practice&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;!--mvc注解驱动--&gt;</span><br><span class=\"line\">&lt;mvc:annotation-driven&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step4-注册Controller组件\"><a href=\"#step4-注册Controller组件\" class=\"headerlink\" title=\"step4. 注册Controller组件\"></a>step4. 注册Controller组件</h2><p>写一个自定义Controller类，使用Controller注册该类，然后在方法中使用@RequestMapping注解注册Handler</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;注册为Controller</span><br><span class=\"line\">@Controller</span><br><span class=\"line\">public class SecondController</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;RequestMapping的id作为url</span><br><span class=\"line\">\t@RequestMapping(&quot;&#x2F;second&quot;)</span><br><span class=\"line\">\tpublic ModelAndView hi()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;, &quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"step5-运行Servlet\"><a href=\"#step5-运行Servlet\" class=\"headerlink\" title=\"step5. 运行Servlet\"></a>step5. 运行Servlet</h2><h2 id=\"案例2分析\"><a href=\"#案例2分析\" class=\"headerlink\" title=\"案例2分析\"></a>案例2分析</h2><hr>\n<h1 id=\"Handler进阶使用\"><a href=\"#Handler进阶使用\" class=\"headerlink\" title=\"Handler进阶使用\"></a>Handler进阶使用</h1><h2 id=\"注解-RequestMapping\"><a href=\"#注解-RequestMapping\" class=\"headerlink\" title=\"注解@RequestMapping\"></a>注解@RequestMapping</h2><h3 id=\"URL路径映射\"><a href=\"#URL路径映射\" class=\"headerlink\" title=\"URL路径映射\"></a>URL路径映射</h3><p>使用@RequestMapping注解的value属性(数组数据类型)，将请求url和handler建立映射。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;只写一个String，默认就为value属性</span><br><span class=\"line\">@RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class=\"line\">public ModelAndView hello()&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"多个URL路径映射到同一个Handler上\"><a href=\"#多个URL路径映射到同一个Handler上\" class=\"headerlink\" title=\"多个URL路径映射到同一个Handler上\"></a>多个URL路径映射到同一个Handler上</h3><p>因为value是个数组数据类型，因此可以传递多个值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(value &#x3D; &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span><br><span class=\"line\">public ModelAndView hello()&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"url可以使用-来通配\"><a href=\"#url可以使用-来通配\" class=\"headerlink\" title=\"url可以使用*来通配\"></a>url可以使用*来通配</h3><p>可以使用*做通配，如hello*通配hello字符串开头的任何字符串,如hello1, hello2, hello1234</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&#123;&quot;hello*&quot;&#125;)</span><br><span class=\"line\">public ModelAndView hello()&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>通配hello\\xxxx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&#123;&quot;hello\\*&quot;&#125;)</span><br><span class=\"line\">public ModelAndView hello()&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"窄化请求url\"><a href=\"#窄化请求url\" class=\"headerlink\" title=\"窄化请求url\"></a>窄化请求url</h3><p>welcome/first    handler方法上 → “first”<br>welcome/second   handler方法上 → “second”<br>welcome/third    handler方法上 → “third”<br>即将具有相同路径部分的内容提取出来<br>先用@RequestMapping把user放在Controller组件上，然后@RequestMapping到对应方法上添加url映射</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">@RequestMapping(&quot;&#x2F;welcome&quot;)</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t@RequestMapping(&quot;&#x2F;hunter&quot;)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>tip: 不要把url添加到@Controller上！</strong><br><br></p>\n<h3 id=\"请求方法限定\"><a href=\"#请求方法限定\" class=\"headerlink\" title=\"请求方法限定\"></a>请求方法限定</h3><p>在@RequestMapping上添加method = “请求方式”，来限定请求方式<br>可以限定GET、POST、PUT等请求类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class MethodLimited</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;限定GET方式（注意要写value）</span><br><span class=\"line\">\t@RequestMapping(value &#x3D; &quot;&#x2F;methodlimited&quot;, method &#x3D; RequestMethod.GET)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果是多个请求方式限定，逻辑是OR（满足一个即可）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;多个方式限定，逻辑关系是OR</span><br><span class=\"line\">@RequestMapping(value &#x3D; &quot;&#x2F;methodslimited&quot;, method &#x3D; &#123;RequestMethod.GET, RequestMethod.POST&#125;)</span><br><span class=\"line\">public ModelAndView hi()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\tmodelAndView.setViewName(&quot;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter, May you found your worth in the waking world.&quot;);</span><br><span class=\"line\">\treturn modelAndView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"引申注解\"><a href=\"#引申注解\" class=\"headerlink\" title=\"引申注解\"></a>引申注解</h3><p>上面的请求方式限定可以直接使用引申注解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;&#x2F;methodlimited&quot;) &#x3D; @RequestMapping(value &#x3D; &quot;&#x2F;methodlimited&quot;,</span><br><span class=\"line\">\t\t\t\t\t\t\t\tmethod &#x3D; RequestMethod.GET)</span><br><span class=\"line\">@PostMapping(&quot;&#x2F;methodlimited&quot;) &#x3D; @RequestMapping(value &#x3D; &quot;&#x2F;methodlimited&quot;, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t method &#x3D; RequestMethod.POST)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class MethodLimited</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;限定GET方式（注意要写value）</span><br><span class=\"line\">\t@GetMapping(&quot;methodlimited&quot;)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"请求参数限定\"><a href=\"#请求参数限定\" class=\"headerlink\" title=\"请求参数限定\"></a>请求参数限定</h3><p>在@RequestMapping添加 param = “指定参数名”，来限定参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;限定参数名必须是hunter</span><br><span class=\"line\">\t@RequestMapping(value &#x3D; &quot;&#x2F;hunter&quot;, param &#x3D; &quot;hunter&quot;)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果是多个请求参数限定，param添加参数数组，多个参数的逻辑关系是AND（即要多个参数要同时存在）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;多个参数逻辑关系是AND</span><br><span class=\"line\">\t@RequestMapping(value &#x3D; &quot;&#x2F;hunter&quot;, param &#x3D; &#123;&quot;good&quot;, &quot;hunter&quot;&#125;)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"请求参数值的简单逻辑判定\"><a href=\"#请求参数值的简单逻辑判定\" class=\"headerlink\" title=\"请求参数值的简单逻辑判定\"></a>请求参数值的简单逻辑判定</h3><p>在@RequestMapping的param值中，可以使用 != 某个值 来对值进行判断(参数值不等于该值)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;hunter的值不能是german</span><br><span class=\"line\">\t@RequestMapping(value &#x3D; &quot;&#x2F;hunter&quot;, param &#x3D; &#123;&quot;good&quot;, &quot;hunter !&#x3D; german&quot;&#125;)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"请求头限定\"><a href=\"#请求头限定\" class=\"headerlink\" title=\"请求头限定\"></a>请求头限定</h3><p>在@RequestMapping中添加headers属性，限定了请求头的key值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;headers</span><br><span class=\"line\">\t@RequestMapping(value &#x3D; &quot;&#x2F;hunter&quot;, headers &#x3D; &quot;hunter&quot;)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多个请求头之间的值，逻辑是AND，即多个请求头都要发送</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;headers</span><br><span class=\"line\">\t@RequestMapping(value &#x3D; &quot;&#x2F;hunter&quot;, headers &#x3D; &#123;&quot;good&quot;, &quot;hunter&quot;&#125;)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"特定的请求头限定（针对Accpect和Content—Type）\"><a href=\"#特定的请求头限定（针对Accpect和Content—Type）\" class=\"headerlink\" title=\"特定的请求头限定（针对Accpect和Content—Type）\"></a>特定的请求头限定（针对Accpect和Content—Type）</h3><p>produces属性限定accept请求头（accept一般属于GET请求头）<br>在@RequestMapping中添加produces属性，指定特定值类型（注：MIME标准中，格式必须为application/xxx）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;指定请求头的值为application&#x2F;json，用作accept</span><br><span class=\"line\">\t@RequestMapping(value &#x3D; &quot;accept&quot;, produces &#x3D; &quot;application&#x2F;json&quot;)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>consumes属性限定content-type请求头（content-type属于POST的请求头，指明post实体体的格式）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;指定实体体的值为application&#x2F;json，用作content-type</span><br><span class=\"line\">\t@RequestMapping(value &#x3D; &quot;accept&quot;, cousumes &#x3D; &quot;application&#x2F;json&quot;)</span><br><span class=\"line\">\tpublic ModelAndView hello()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tModelAndView modelAndView &#x3D; new ModelAndView();</span><br><span class=\"line\">\t\tmodelAndView.setViewName(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;);</span><br><span class=\"line\">\t\tmodelAndView.addObject(&quot;world&quot;,&quot;Good Hunter&quot;);</span><br><span class=\"line\">\t\treturn modelAndView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"Handler的返回值\"><a href=\"#Handler的返回值\" class=\"headerlink\" title=\"Handler的返回值\"></a>Handler的返回值</h2><h3 id=\"需要View试图的情况\"><a href=\"#需要View试图的情况\" class=\"headerlink\" title=\"需要View试图的情况\"></a>需要View试图的情况</h3><h3 id=\"返回void\"><a href=\"#返回void\" class=\"headerlink\" title=\"返回void\"></a>返回void</h3><p>handler返回void值，处理方式即采用servlet的request和response，并由视图转发出去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class=\"line\">\tpublic void do(HttpServletRequest request, HttpServletResponse response) throws ServletException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        request.setAttribute(&quot;content&quot;, &quot;void&quot;);</span><br><span class=\"line\">        request.getRequestDispather(&quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;).forward(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"返回ModelAndView\"><a href=\"#返回ModelAndView\" class=\"headerlink\" title=\"返回ModelAndView\"></a>返回ModelAndView</h3><p>先setViewName, 再addObject，见@RequestMapping注解<br><br></p>\n<h3 id=\"返回视图名String\"><a href=\"#返回视图名String\" class=\"headerlink\" title=\"返回视图名String\"></a>返回视图名String</h3><p>String返回视图名(viewName)</p>\n<ul>\n<li><p>物理视图<br>直接返回字符串作为视图名，形参为Model，Spring会自动帮我们封装，所以直接使用即可。<br>使用model.addAttribute传递model值，然后直接返回String</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class RequestMappingTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class=\"line\">\tpublic String doString(Model model)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        model.addAttribute(&quot;content&quot;, &quot;Good Hunter&quot;);</span><br><span class=\"line\">        &#x2F;&#x2F;返回String作为视图名</span><br><span class=\"line\">        return &quot;&#x2F;WEB-INF&#x2F;first.jsp&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>逻辑视图<br>viewName = prefix + 返回值 + suffix<br>在Spring的application.xml中配置InternalResourceViewResolver<br>配置了之后，返回值为字符串和返回值为ModelAndView的setViewName都会受到影响</p>\n<br>\n\n</li>\n</ul>\n<h3 id=\"返回String，进行转发和重定向\"><a href=\"#返回String，进行转发和重定向\" class=\"headerlink\" title=\"返回String，进行转发和重定向\"></a>返回String，进行转发和重定向</h3><p>这个并不是jsp的视图的处理,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class ForwardAndRedirectController</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    @RequestMapping(&quot;forward&quot;)</span><br><span class=\"line\">    public String forward()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;转发到receive</span><br><span class=\"line\">        return &quot;forward:&#x2F;receive&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;redirect&quot;)</span><br><span class=\"line\">    public String redirect()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;重定向到receive</span><br><span class=\"line\">        return &quot;redirect:&#x2F;receive&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;receive，返回值为String视图名</span><br><span class=\"line\">    @RequestMapping(&quot;receive&quot;)</span><br><span class=\"line\">    public String receive()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return &quot;WEB-INF&#x2F;first.jsp&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>forward转发不会改变url，redirect重定向会改变url</p>\n<p>提示：视图名、转发、重定向，一定要加/<br>因为不加/是作为相对路径，相对路径的处理方式为：去掉url的最后一级的值，并添加上新值<br><br></p>\n<h3 id=\"直接返回Json（目前主流：2020年）\"><a href=\"#直接返回Json（目前主流：2020年）\" class=\"headerlink\" title=\"直接返回Json（目前主流：2020年）\"></a>直接返回Json（目前主流：2020年）</h3><p>返回值为Json类型，可以直接写成javaBean、数据、List等</p>\n<ol>\n<li><p>pom.xml添加依赖jackson-databind</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.11.1&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>web.xml常规配置（DispatcherServlet和Spring配置文件)</p>\n</li>\n<li><p>Spring的application.xml的常规配置（组件扫包和MVC注解驱动）</p>\n</li>\n<li><p>写一个JavaBean</p>\n</li>\n<li><p>在Handler的方法体上添加注解@ResponseBody，可以直接在response中返回Json对象</p>\n</li>\n</ol>\n<p><em>tip: @ResponseBody可以用在类上，表示该类所有方法的response都用json封装</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class JsonHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t@RequestMapping(&quot;json&quot;)</span><br><span class=\"line\">\t&#x2F;&#x2F;添加ResponseBody注解后，返回的即为json对象</span><br><span class=\"line\">\t@ResponseBody</span><br><span class=\"line\">\tpublic My myJson()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tMy my &#x3D; new My();</span><br><span class=\"line\">\t\tmy.setMyName(&quot;Eternal&quot;);</span><br><span class=\"line\">\t\tmy.setMyKey(&quot;Eva&quot;);</span><br><span class=\"line\">\t\treturn my;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>tip:</em></p>\n<ul>\n<li><em>可以在@ResponseBody注解的方法中，直接返回String值，返回的就是字符串，而不是Json对象（但是不能使用中文字符串）</em></li>\n<li><em>可以返回<code>List&lt;bean&gt;</code>，得到Json数组</em></li>\n<li><em>可以返回其他类型数据</em><br>\n\n</li>\n</ul>\n<h2 id=\"Handler方法的主要形参\"><a href=\"#Handler方法的主要形参\" class=\"headerlink\" title=\"Handler方法的主要形参\"></a>Handler方法的主要形参</h2><h3 id=\"请求参数接收\"><a href=\"#请求参数接收\" class=\"headerlink\" title=\"请求参数接收\"></a>请求参数接收</h3><p>参数接收前提：使用form表单的input标签来构造请求参数名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;form action&#x3D;&quot;&#x2F;welcome&quot;&gt;</span><br><span class=\"line\">    用户名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;</span><br><span class=\"line\">    密码:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;submit&quot;&gt;</span><br><span class=\"line\">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h3 id=\"接收并封装非Json数据\"><a href=\"#接收并封装非Json数据\" class=\"headerlink\" title=\"接收并封装非Json数据\"></a>接收并封装非Json数据</h3><h4 id=\"使用request获取（不建议使用）\"><a href=\"#使用request获取（不建议使用）\" class=\"headerlink\" title=\"使用request获取（不建议使用）\"></a>使用request获取（不建议使用）</h4><p>网页url附带参数 a=xxx&amp;b=xxx<br>使用request.getParameter(“a”) …拿到参数<br><br></p>\n<h4 id=\"使用Handler直接获取并封装\"><a href=\"#使用Handler直接获取并封装\" class=\"headerlink\" title=\"使用Handler直接获取并封装\"></a>使用Handler直接获取并封装</h4><ul>\n<li><p>常规接收<br>方法使用@ResponseBody注解，直接在方法形参上写 <em>包装类数据类型 参数名</em> 即可，SpringMVC会自动封装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;param&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public ValueBean myParam(String username, String password)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;ValueBean的使用见Encapsulation</span><br><span class=\"line\">\treturn ValueBean.ok(username, password);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接收并封装日期格式数据<br>SpringMVC没有提供直接转换Date格式的转换器，需要在参数中使用注解 <em>@DateTimeFormat(pattern=”yyyy-mm-dd”)</em> 来制定指定格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;param&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public ValueBean myParam(@DateTimeFormat(pattern&#x3D;&quot;yyyy-mm-dd&quot;) Date birthDay)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;ValueBean的使用见Encapsulation</span><br><span class=\"line\">\treturn ValueBean.ok(birthday);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接收文件<br>文件上传需要使用组件CommonMultipartResolver</p>\n<ul>\n<li><p>step1. 导包(commons-fileupload)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.4&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>step2. Spring注册CommonMultipartResolver<br>id必须为multipartResolver，因为Spring定义好了multipartResolver，按照该id来获取组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class=\"line\">    &#x2F;&#x2F;设置最大上传文件大小</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;51200&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>step3. 接收方法的形参为MultipartFile</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;upload&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public ValueBean myParam(MultipartFile uploadFile)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;获取上传文件的原名字</span><br><span class=\"line\">    String fileName &#x3D; uploadFile.getOriginalFileName()</span><br><span class=\"line\">    File file &#x3D; new File(“~&#x2F;Documents&quot;, fileName);</span><br><span class=\"line\">    &#x2F;&#x2F;把接收的文件保存起来</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        uploadFile.transferTo(file);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch(IOException e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;ValueBean的使用见Encapsulation</span><br><span class=\"line\">\treturn ValueBean.ok();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>tip：多文件上传，form表单input使用multiple，接收使用数组MultipartFile[]来接收</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;form action&#x3D;&quot;...&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;file&quot; multiple name&#x3D;&quot;...&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;submit&quot;&gt;</span><br><span class=\"line\">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;upload&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public ValueBean myParam(MultipartFile[] uploadFile)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(File file : uploadFile)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;处理上传文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\treturn ValueBean.ok();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>converter组件：用来转换接收类型；Converter接口，将泛型S转换为T</p>\n<ul>\n<li>step1. 创建一个自定义类，实现Converter接口<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>step2. 配置Spring的xml配置<br> 添加FormattingConversionServiceFactoryBean<br> 添加属性 converters（set集合）<br> 属性添加子标签引用 ref bean=“自定义类”<br> mvc注解驱动添加 conversion-service=“配置的Formatting…id”<br> 另外：SpringMVC提供了很多conversionService<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><em>什么时候会使用到Converter转换器：Handler接收的参数名和Post请求的参数名一致，并且数据类型不为String。</em><br>(此处要用图片)</p>\n</li>\n<li><p>接收数组<br>如果请求参数名一致，可以使用数组来接收</p>\n <br>\n\n</li>\n</ul>\n<h4 id=\"使用JavaBean来接收\"><a href=\"#使用JavaBean来接收\" class=\"headerlink\" title=\"使用JavaBean来接收\"></a>使用JavaBean来接收</h4><p>把Handler接收的形参 <strong><em>定义为JavaBean的成员变量和对应的set方法</em></strong>，其实就是把Handler的形参用Bean封装了一下。<br>请求参数名和JavaBean成员变量名一致，如果类型不一致，会调用Spring的Converter</p>\n<p> <strong><em>特殊JavaBean：</em></strong></p>\n<ul>\n<li><p><strong><em>嵌套JavaBean</em></strong><br>在Post请求参数名 = 嵌套的JavaBean.参数名，Spring的@ResponseBody会负责封装</p>\n</li>\n<li><p><strong><em>JavaBean包含List<T></T></em></strong><br>在Post请求参数名 = List名[对应下标].参数名，封装进List中。下标用作分组</p>\n</li>\n</ul>\n<h4 id=\"Post请求中文乱码问题\"><a href=\"#Post请求中文乱码问题\" class=\"headerlink\" title=\"Post请求中文乱码问题\"></a>Post请求中文乱码问题</h4><p>使用filter来解决，因为URL编码格式导致<br> <strong><em>在web.xml里配置CharacterEncodingFilter</em></strong><br>CharacterEncodingFilter里定义了方法: </p>\n<ul>\n<li><em>forceEncoding\b</em>可以强制对request和response使用Encoding编码</li>\n<li><em>encoding</em>参数定义使用utf-8编码<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;filter&gt;</span><br><span class=\"line\">    &lt;filter-name&gt;characterEncoding&lt;&#x2F;filter-name&gt;</span><br><span class=\"line\">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class=\"line\">    &lt;init-param&gt;</span><br><span class=\"line\">        &lt;param-name&gt;forceEncoding&lt;&#x2F;param-name&gt;</span><br><span class=\"line\">        &lt;param-value&gt;true&lt;&#x2F;param-value&gt;</span><br><span class=\"line\">    &lt;&#x2F;init-param&gt;</span><br><span class=\"line\">    &lt;init-param&gt;</span><br><span class=\"line\">        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class=\"line\">        &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;</span><br><span class=\"line\">    &lt;&#x2F;init-param&gt;</span><br><span class=\"line\">&lt;&#x2F;filter&gt;</span><br><span class=\"line\">&lt;filter-mapping&gt;</span><br><span class=\"line\">    &lt;filter-name&gt;characterEncoding&lt;&#x2F;filter-name&gt;</span><br><span class=\"line\">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class=\"line\">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>\ntip：要判断参数接收到中文是否乱码，可以在代码中打印查看（因为各种控制台输出显示可能不是utf-8）<br>\n\n</li>\n</ul>\n<h3 id=\"接收并封装Json数据\"><a href=\"#接收并封装Json数据\" class=\"headerlink\" title=\"接收并封装Json数据\"></a>接收并封装Json数据</h3><p>如何利用postman构建发送json数据：</p>\n<ul>\n<li>Post方法</li>\n<li>Headers有Content-Type: application/json</li>\n<li>Body选择raw为json<br>（判断json内元素是否是数值，看是否带双引号）</li>\n</ul>\n<p>如何接收：<br> <strong><em>定义一个json的JavaBean</em></strong><br> <strong><em>pom.xml要导入javkson-bind依赖</em></strong><br> <strong><em>接收时候要对形参使用注解：@RequestBody</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public ValueBean json(@RequestBody User user)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn ValueBean.ok(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果Json内嵌套了一个Json对象：把里面的Json对象封装成一个对象来接收<br><br></p>\n<h3 id=\"接收Map\"><a href=\"#接收Map\" class=\"headerlink\" title=\"接收Map\"></a>接收Map</h3><p>对形参使用注解：@RequestBody，也可以接收Map类型<br>使用map.get中按照key来接收</p>\n<h2 id=\"Handler的其他参数\"><a href=\"#Handler的其他参数\" class=\"headerlink\" title=\"Handler的其他参数\"></a>Handler的其他参数</h2><h3 id=\"直接放入request和response\"><a href=\"#直接放入request和response\" class=\"headerlink\" title=\"直接放入request和response\"></a>直接放入request和response</h3><p>见返回void</p>\n<h3 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h3><p>返回值为String，使用Model作为形参</p>\n<h3 id=\"cookie和session\"><a href=\"#cookie和session\" class=\"headerlink\" title=\"cookie和session\"></a>cookie和session</h3><p>利用postman构建cookie</p>\n<ul>\n<li>headers里添加cookie<br>cookie在Handler中通过request获得<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>session在Handler中也是通过request获得<br>可以对session进行set和get<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>session也可以直接在形参中使用HttpSession获取<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"locale\"><a href=\"#locale\" class=\"headerlink\" title=\"locale\"></a>locale</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Restful风格请求\"><a href=\"#Restful风格请求\" class=\"headerlink\" title=\"Restful风格请求\"></a>Restful风格请求</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2\">Restful参考</a><br>响应使用Json数据，使用@RestController注解（其实就是@Controller加@ResponseBody）</p>\n<ul>\n<li><p>@PathVariable<br>使用请求url的一部分提供请求参数：param1/hello/param2/world…<br>如何获取请求参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;&#123;param1&#125;&#x2F;hello&#x2F;&#123;param2&#125;&#x2F;world&quot;)</span><br><span class=\"line\">public ValueBean get(@PathVariable(&quot;param1) String param1,</span><br><span class=\"line\">\t\t\t\t\t @PathVariable(&quot;param2&quot;) String param2)</span><br><span class=\"line\">&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>要求请求参数名和@PathVariable里的参数名一直</p>\n</li>\n<li><p>@RequestParam</p>\n</li>\n<li><p>@RequestHeader<br>通过该注解可以获得Header的key值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestHeader(&quot;Accept&quot;) String accept</span><br><span class=\"line\">@RequestHeader(&quot;Host&quot;) String host</span><br><span class=\"line\">&#x2F;&#x2F;也可以用数组形式接收，accept值以 , 分隔</span><br><span class=\"line\">@RequestHeader(&quot;Accept&quot;) String[] accept</span><br></pre></td></tr></table></figure></li>\n<li><p>@CookieValue<br>通过该注解可以取出cookie的某个key的cookieValue值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>@SessionAttribute<br>通过该注解可以取出session的某个key的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<br>\n\n</li>\n</ul>\n<h1 id=\"静态资源访问\"><a href=\"#静态资源访问\" class=\"headerlink\" title=\"静态资源访问\"></a>静态资源访问</h1><h2 id=\"默认的Servlet\"><a href=\"#默认的Servlet\" class=\"headerlink\" title=\"默认的Servlet\"></a>默认的Servlet</h2><p>在web.xml配置默认的Servlet</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;default&lt;&#x2F;servlet-name&gt;</span><br><span class=\"line\">    &lt;url-pattern&gt;*.html&lt;&#x2F;url-pattern&gt;</span><br><span class=\"line\">&lt;&#x2F;servlet-mapping&gt;</span><br><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;default&lt;&#x2F;servlet-name&gt;</span><br><span class=\"line\">    &lt;url-pattern&gt;*.png&lt;&#x2F;url-pattern&gt;</span><br><span class=\"line\">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"默认Servlet的Handler\"><a href=\"#默认Servlet的Handler\" class=\"headerlink\" title=\"默认Servlet的Handler\"></a>默认Servlet的Handler</h2><p>通过DispatcherServlet分发到对应Handler，handler处理：<br>如果查询到有对应静态资源，就返回静态资源；没有就交给调用绑定的Servlet来处理<br> <strong><em>在Spring的xml配置中添加 <code>&lt;mvc:default-servlet-handler&gt;</code>配置</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;context:component-scan base-package&#x3D;&quot;HomeWork&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;!--mvc注解驱动--&gt;</span><br><span class=\"line\">&lt;mvc:annotation-driven&#x2F;&gt;</span><br><span class=\"line\">&lt;mvc:default-servlet-handler&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"静态资源映射（推荐）\"><a href=\"#静态资源映射（推荐）\" class=\"headerlink\" title=\"静态资源映射（推荐）\"></a>静态资源映射（推荐）</h2><p>将请求url和文件建立联系<br> <strong><em>在Spring的xml配置中添加 <code>&lt;mvc:resources mapping=&quot;/123/**&quot; location=&quot;...&quot;&gt;</code></em></strong><br> 其中两个，表示通配该级和之后的多级目录</p>\n<ul>\n<li>mapping：请求url，mapping的值相对于location的值，mapping的<code>/</code>表示相对路径</li>\n<li>location：对应的静态资源路径</li>\n<li>classpath路径</li>\n<li>web根路径</li>\n<li>文件路径（重要）</li>\n</ul>\n<h1 id=\"SpringMVC异常处理\"><a href=\"#SpringMVC异常处理\" class=\"headerlink\" title=\"SpringMVC异常处理\"></a>SpringMVC异常处理</h1><h2 id=\"自己创建HandlerExceptionResolver来处理\"><a href=\"#自己创建HandlerExceptionResolver来处理\" class=\"headerlink\" title=\"自己创建HandlerExceptionResolver来处理\"></a>自己创建HandlerExceptionResolver来处理</h2><p>处理结果 <strong><em>返回ModelAndView</em></strong>，所以有Handler、service、dao的异常都会被捕获<br> <strong><em>一个处理类，继承HandlerExceptionResolver，并重写方法</em></strong><br> <strong><em>可以自己写不同的异常类，注册到组件中做个性化处理</em></strong><br> <strong><em>直接注册到组件即可使用</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自己创建ExceptionHandler来处理\"><a href=\"#自己创建ExceptionHandler来处理\" class=\"headerlink\" title=\"自己创建ExceptionHandler来处理\"></a>自己创建ExceptionHandler来处理</h2><p>该方式处理比较灵活，可以返回ModelAndView，也可以返回Json（要使用注解@ResponseBody）<br>按照异常映射到handler方法上处理<br> <strong><em>自己创建处理类使用注解@ControllerAdvice</em></strong><br> <strong><em>方法上使用注解@ExceptionHandler({异常.class,…})</em></strong></p>\n<p>@RestControllerAdvice</p>\n<h1 id=\"HandlerInterception\"><a href=\"#HandlerInterception\" class=\"headerlink\" title=\"HandlerInterception\"></a>HandlerInterception</h1><p>handler拦截器<br>（待补齐）</p>\n<h2 id=\"preHandle\"><a href=\"#preHandle\" class=\"headerlink\" title=\"preHandle\"></a>preHandle</h2><h2 id=\"postHandle\"><a href=\"#postHandle\" class=\"headerlink\" title=\"postHandle\"></a>postHandle</h2><h2 id=\"afterCompletion\"><a href=\"#afterCompletion\" class=\"headerlink\" title=\"afterCompletion\"></a>afterCompletion</h2><p>如果preHandler为true，必定执行到这步</p>\n<h2 id=\"HandlerInterception的作用范围\"><a href=\"#HandlerInterception的作用范围\" class=\"headerlink\" title=\"HandlerInterception的作用范围\"></a>HandlerInterception的作用范围</h2><ul>\n<li>全局</li>\n<li>部分<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;mvc:interceptors&gt;</span><br><span class=\"line\">\t&lt;!-- 部分--&gt;</span><br><span class=\"line\">\t&lt;mvc:interceptor&gt;</span><br><span class=\"line\">\t\t&lt;mvc:mapping path&#x3D;&quot;拦截url“&#x2F;&gt;</span><br><span class=\"line\">\t\t&lt;ref bean&#x3D;&quot;自己实现HandlerInterception的类&quot;&#x2F;&gt;</span><br><span class=\"line\">\t&lt;&#x2F;mvc:interceptor&gt;</span><br><span class=\"line\">&lt;&#x2F;mvc:interceptors&gt;\t</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"多个HandlerInterception的执行顺序\"><a href=\"#多个HandlerInterception的执行顺序\" class=\"headerlink\" title=\"多个HandlerInterception的执行顺序\"></a>多个HandlerInterception的执行顺序</h2><p>按照<code>&lt;mvc:interceptos&gt;</code>的配置顺序执行<br>但是因为程序迭代逻辑是栈<br>prehandle先进后出<br>post、after后进先出</p>\n<ul>\n<li>所有prehandler均为true，按照该逻辑依次执行</li>\n<li>prehandler有false</li>\n<li>1为false，执行到prehandle1，跳出</li>\n<li>2为false，执行到prehandler2，跳出，无法继续执行到posthandler1，但是必定执行afterHandler1</li>\n<li>3为false，执行到prehandler3，跳出，…，必定执行到afterHandler1、afterHandler2</li>\n</ul>\n<h2 id=\"案例1-1\"><a href=\"#案例1-1\" class=\"headerlink\" title=\"案例1\"></a>案例1</h2><ol>\n<li><p>写实现HandlerInterception的类<br>重写pre、post、after方法</p>\n</li>\n<li><p>注册组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;mvc:interceptors&gt;</span><br><span class=\"line\">\t&lt;!-- 全局作用范围:进入到Dispatcher处理，即可进入到该interceptor--&gt;</span><br><span class=\"line\">\t&lt;ref bean&#x3D;“（1）中写的类”&#x2F;&gt;</span><br><span class=\"line\">\t&lt;!-- 或者 bean class&#x3D;“（1）中写的类“&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;mvc:interceptors&gt;\t</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>案例分析</p>\n</li>\n</ol>\n<ul>\n<li>如果preHandle返回false</li>\n<li>postHandle可以做后处理</li>\n<li>如果Handle的返回值为true</li>\n<li>如果handle的返回值为false</li>\n</ul>\n<h1 id=\"locale-1\"><a href=\"#locale-1\" class=\"headerlink\" title=\"locale\"></a>locale</h1><p>SpringMVC管理locale，放到handler的形参中，再放入cookie或者session中</p>\n<h2 id=\"localeResolver\"><a href=\"#localeResolver\" class=\"headerlink\" title=\"localeResolver\"></a>localeResolver</h2><ul>\n<li>CookieLocaleResolver</li>\n<li>SessionLocaleResolver<br>\n\n</li>\n</ul>\n<h2 id=\"获取本地locale\"><a href=\"#获取本地locale\" class=\"headerlink\" title=\"获取本地locale\"></a>获取本地locale</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<br>\n\n<h2 id=\"管理locale\"><a href=\"#管理locale\" class=\"headerlink\" title=\"管理locale\"></a>管理locale</h2><p> <strong><em>注册localeResolver：id名固定为localResolver</em></strong></p>\n<ul>\n<li><strong><em>name的值：header的可以决定locale的字段</em></strong></li>\n<li><strong><em>默认locale：没有配置locale的默认编码</em></strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id&#x3D;&quot;localResovler&quot; class&#x3D;&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- header字段langue-123的值决定了locale信息--&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;cookieName&quot; value&#x3D;&quot;langue-123&quot;&#x2F;&gt;</span><br><span class=\"line\">\t&lt;!-- 默认locale值--&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;defaultLocale&quot; value&#x3D;&quot;en_US&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h1 id=\"MessgaeSource\"><a href=\"#MessgaeSource\" class=\"headerlink\" title=\"MessgaeSource\"></a>MessgaeSource</h1><p>获取配置文件的值</p>\n<ol>\n<li>注册MessageSource组件 <strong><em>ReloadableResourceBundleMessageSource</em></strong></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id&#x3D;&quot;messageSource&quot; class&#x3D;&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 加载配置的文件名, value中要加classpath--&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;basename&quot; value&#x3D;&quot;classpath:message&quot;&#x2F;&gt;</span><br><span class=\"line\">    &lt;!-- 配置文件的编码格式--&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;utf-8&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2.取出MessageSource的信息<br>MessageSource类的注册不只一个，因此要按照id来取出</p>\n<ul>\n<li>参数:</li>\n</ul>\n<ol>\n<li>MessageSource的key值</li>\n<li>数组：为信息做占位符，参考国际化案例2</li>\n<li>Locale的编码格式</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Message</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t@Autowired</span><br><span class=\"line\">\t@Qualifier(&quot;messageSource&quot;)</span><br><span class=\"line\">\tMessageSource messageSource;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@RequestMapping(&quot;&#123;key&#125;&quot;)</span><br><span class=\"line\">\tpublic String getMessageSource(@PathVariable(&quot;key&quot;) String key)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn messageSource.getMessage(key, null, Locale.getDefault());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<h1 id=\"MessageSource-Locale实现国际化\"><a href=\"#MessageSource-Locale实现国际化\" class=\"headerlink\" title=\"MessageSource + Locale实现国际化\"></a>MessageSource + Locale实现国际化</h1><h2 id=\"配置信息组\"><a href=\"#配置信息组\" class=\"headerlink\" title=\"配置信息组\"></a>配置信息组</h2><p>同一个key在不同的locale下，value值不同，然后前缀相同时：这几个配置文件的basename都是相同的前缀名：<br> <em>如果没有自动创建，可以手动进行捆绑</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">message_language1.properties</span><br><span class=\"line\">message_language2.properties</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>message的配置文件的选择会根据locale来决定</p>\n<h2 id=\"注册MessageSource和localeResolver组件\"><a href=\"#注册MessageSource和localeResolver组件\" class=\"headerlink\" title=\"注册MessageSource和localeResolver组件\"></a>注册MessageSource和localeResolver组件</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--注册messageSource--&gt;</span><br><span class=\"line\">&lt;bean id&#x3D;&quot;messageSource&quot; class&#x3D;&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;basename&quot; value&#x3D;&quot;classpath:message&quot;&#x2F;&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;utf-8&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br><span class=\"line\">&lt;!--注册localeResolver--&gt;</span><br><span class=\"line\">&lt;bean id&#x3D;&quot;localeResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;cookieName&quot; value&#x3D;&quot;locale&quot;&#x2F;&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;defaultLocale&quot; value&#x3D;&quot;en_us&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用参数\"><a href=\"#使用参数\" class=\"headerlink\" title=\"使用参数\"></a>使用参数</h2><p><strong><em>MessageSource参数</em></strong></p>\n<ul>\n<li>key</li>\n<li>Object[]</li>\n<li>locale</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;i18n&#x2F;&#123;key&#125;)</span><br><span class=\"line\">public View i18n(@PathVariable(&quot;key&quot;) String key, Locale locale)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tString message &#x3D; messageSource.getMessage(key, null, locale);</span><br><span class=\"line\">\treturn View.ok(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;使用Object[]参数</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"validator（hibernate-validator\"><a href=\"#validator（hibernate-validator\" class=\"headerlink\" title=\"validator（hibernate validator)\"></a>validator（hibernate validator)</h1><p>负责做请求参数校验</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ol>\n<li>导包</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;hibernate-validator&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;6.0.17.Final&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>Spring的xml配置<br>在mvc注解驱动上添加validator，然后注册localValidatorFactoryBean</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;mvc:annotation-driven validator&#x3D;&quot;localValidatorFactoryBean&quot;&#x2F;&gt;</span><br><span class=\"line\">    &lt;bean name&#x3D;&quot;localValidatorFactoryBean&quot; class&#x3D;&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;</span><br><span class=\"line\">    &lt;property name&#x3D;&quot;providerClass&quot; value&#x3D;&quot;org.hibernate.validator.HibernateValidator&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>注解配置<br>现在就可以在类的方法上使用注解</li>\n<li>对Bean的 <strong><em>成员变量</em></strong> 使用的注解：<br>常见的注解 （Bean Validation 中内置的 constraint）     </li>\n</ol>\n<ul>\n<li>@Null   被注释的元素必须为 null     </li>\n<li>@NotNull    被注释的元素必须不为 null     </li>\n<li>@Size(max=, min=)   被注释的元素的大小必须在指定的范围内     </li>\n<li>@AssertTrue     被注释的元素必须为 true     </li>\n<li>@AssertFalse    被注释的元素必须为 false     </li>\n<li>@Min(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值     </li>\n<li>@Max(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值     </li>\n<li>@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值     </li>\n<li>@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值     </li>\n<li>@Digits (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内     </li>\n<li>@Past   被注释的元素必须是一个过去的日期 Date    </li>\n<li>@Future     被注释的元素必须是一个将来的日期     </li>\n<li>@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式<br>Hibernate Validator 附加的 constraint     </li>\n<li>@NotBlank(message =)   验证字符串非null，且长度必须大于0     </li>\n<li>@Email  被注释的元素必须是电子邮箱地址     </li>\n<li>@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内     </li>\n<li>@NotEmpty   被注释的字符串的必须非空     </li>\n<li>@Range(min=,max=,message=)  被注释的元素必须在合适的范围内</li>\n</ul>\n<ol start=\"2\">\n<li>对handler <strong><em>参数</em></strong> 使用的注解</li>\n</ol>\n<ul>\n<li>@Valid</li>\n<li>@Validated</li>\n</ul>\n<ol start=\"4\">\n<li><p>Handler的BindingResult参数<br>用作参数校验</p>\n</li>\n<li><p>@size注解的messgae参数</p>\n</li>\n</ol>\n<h2 id=\"validator和messageSource搭配\"><a href=\"#validator和messageSource搭配\" class=\"headerlink\" title=\"validator和messageSource搭配\"></a>validator和messageSource搭配</h2><br>\n\n\n<h1 id=\"Spring和SpringMVC的整合\"><a href=\"#Spring和SpringMVC的整合\" class=\"headerlink\" title=\"Spring和SpringMVC的整合\"></a>Spring和SpringMVC的整合</h1><h2 id=\"Spring容器和SpringMVC容器的分家\"><a href=\"#Spring容器和SpringMVC容器的分家\" class=\"headerlink\" title=\"Spring容器和SpringMVC容器的分家\"></a>Spring容器和SpringMVC容器的分家</h2><p>ContextLoaderListener：在DispatcherServlet初始化之前</p>\n<h2 id=\"SpringMVC-javaConfig\"><a href=\"#SpringMVC-javaConfig\" class=\"headerlink\" title=\"SpringMVC javaConfig\"></a>SpringMVC javaConfig</h2><h2 id=\"其他组件配置\"><a href=\"#其他组件配置\" class=\"headerlink\" title=\"其他组件配置\"></a>其他组件配置</h2><ol>\n<li><p>charactrerEncodingFilter<br>在AACDSI中配置，重写getServletFilters方法</p>\n</li>\n<li><p>静态资源映射<br>WebMvc中配置，重写addResourceLocations方法</p>\n</li>\n<li><p>interceptors<br>先写实现了handlerInterceptor的类<br>再到 WebMvc中配置，重写addInterceptors方法</p>\n</li>\n</ol>\n<ul>\n<li><p>全局</p>\n</li>\n<li><p>部分</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><p>multipartResolver<br>先导包<br>再到WebMvc中配置，@Bean一个multipartResolver </p>\n</li>\n<li><p>localeResolver<br>WebMvc中配置，@Bean一个localeResolver</p>\n</li>\n<li><p>viewResolver<br>WebMvc中配置，@Bean一个internalResourceViewResovler</p>\n</li>\n<li><p>validator<br>WebMvc中配置，@Bean一个localValidatorFactoryBean<br>然后通知MVC使用validator</p>\n</li>\n<li><p>converter</p>\n</li>\n<li><p>handlerExceptionResolver</p>\n</li>\n<li><p>messageResource<br>没有用到mvc配置，所以只用一个@Bean就行</p>\n</li>\n</ol>\n<br>\n\n<h2 id=\"Spring组件配置\"><a href=\"#Spring组件配置\" class=\"headerlink\" title=\"Spring组件配置\"></a>Spring组件配置</h2><ol>\n<li><p>JDBCtemplate<br>先导包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>再@Bean</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>TransactionManager<br>@Bean</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>aspectJ<br>导包</p>\n</li>\n</ol>\n<p>再类中增加注解@EnableAspectJAutoProxy</p>\n","categories":["框架"],"tags":["Spring"]},{"title":"Spring-TX","url":"/2022/07/08/Spring-TX/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>数据库事务具有很多</p>\n<span id=\"more\"></span>\n<h1 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h1><h2 id=\"Jdbc\"><a href=\"#Jdbc\" class=\"headerlink\" title=\"Jdbc\"></a>Jdbc</h2><h2 id=\"对应的数据库依赖（比如Mysql）\"><a href=\"#对应的数据库依赖（比如Mysql）\" class=\"headerlink\" title=\"对应的数据库依赖（比如Mysql）\"></a>对应的数据库依赖（比如Mysql）</h2><h2 id=\"AOP（针对声明式事务）\"><a href=\"#AOP（针对声明式事务）\" class=\"headerlink\" title=\"AOP（针对声明式事务）\"></a>AOP（针对声明式事务）</h2><h1 id=\"核心架构\"><a href=\"#核心架构\" class=\"headerlink\" title=\"核心架构\"></a>核心架构</h1><h2 id=\"PlatformTransactionManager\"><a href=\"#PlatformTransactionManager\" class=\"headerlink\" title=\"PlatformTransactionManager\"></a>PlatformTransactionManager</h2><p>事务管理者，定义事务的操作接口</p>\n<h2 id=\"TransactionDefinition\"><a href=\"#TransactionDefinition\" class=\"headerlink\" title=\"TransactionDefinition\"></a>TransactionDefinition</h2><p>定义事务的规则</p>\n<h2 id=\"TransactionStatus\"><a href=\"#TransactionStatus\" class=\"headerlink\" title=\"TransactionStatus\"></a>TransactionStatus</h2><p>事务执行器，包含事务执行时候的各种状态信息</p>\n<h1 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h1><p>核心配置有两个：</p>\n<ol>\n<li>配置数据源(DataSource)<br>yml或者xml里面配置。</li>\n<li>配置事务管理器(TransactionManager)</li>\n</ol>\n<h1 id=\"两种事务方式\"><a href=\"#两种事务方式\" class=\"headerlink\" title=\"两种事务方式\"></a>两种事务方式</h1><h2 id=\"编程式事务\"><a href=\"#编程式事务\" class=\"headerlink\" title=\"编程式事务\"></a>编程式事务</h2><p>颗粒度更细，但是对代码侵入更多，使用较少。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>配置根据自己的需要或者习惯，使用XML或者JavaConfig都行。以下使用JavaConfig配置编程式事务。</p>\n<p>配置方式：</p>\n<ol>\n<li>XML配置</li>\n<li>JavaConfig配置</li>\n<li>混合配置<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableTransactionManagement</span><br><span class=\"line\">public class TransactionConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;获取yml里的数据源</span><br><span class=\"line\">\t@Autowired</span><br><span class=\"line\">\tprivate DataSource dataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;定义事务管理器</span><br><span class=\"line\">\t@Bean(&quot;transactionManager&quot;)</span><br><span class=\"line\">\tpublic DataSourceTransactionManager dataSourceTransactionManager() &#123;</span><br><span class=\"line\">\t\treturn new DataSourceTransactionManager(dataSource);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Bean</span><br><span class=\"line\">\tpublic PlatformTransactionManager platformTransactionManager() &#123;</span><br><span class=\"line\">\t\treturn dataSourceTransactionManager();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Bean(&quot;jdbcTemplate&quot;)</span><br><span class=\"line\">\tpublic JdbcTemplate jdbcTemplate() &#123;</span><br><span class=\"line\">\t\treturn new JdbcTemplate(dataSource);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>定义事务属性</li>\n<li>根据事务属性生成事务执行器</li>\n<li>操作事务</li>\n</ol>\n<ol>\n<li>TransactionManager操作</li>\n<li>TransactionTemplate操作</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void test1() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;获取默认的事务定义</span><br><span class=\"line\">    DefaultTransactionDefinition defaultTransactionDefinition &#x3D; new DefaultTransactionDefinition();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;根据定义生成一个事务执行者</span><br><span class=\"line\">    TransactionStatus transactionStatus &#x3D; transactionManager.getTransaction(defaultTransactionDefinition);</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        jdbcTemplate.update(&quot;update transaction_test set money &#x3D; ? where name &#x3D; ?&quot;, 9899, &quot;tian&quot;);</span><br><span class=\"line\">        &#x2F;&#x2F;int i &#x3D; 10  &#x2F; 0;</span><br><span class=\"line\">        jdbcTemplate.update(&quot;update transaction_test set money &#x3D; ? where name &#x3D; ?&quot;, 20099, &quot;ma&quot;);</span><br><span class=\"line\">        transactionManager.commit(transactionStatus);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        transactionManager.rollback(transactionStatus);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"声明式事务\"><a href=\"#声明式事务\" class=\"headerlink\" title=\"声明式事务\"></a>声明式事务</h2><p>本质是利用AOP执行，使用注解即可，对代码侵入少，但是最低只能应用在方法级别</p>\n<h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>核心需要配两个内容：</p>\n<ol>\n<li>配置事务管理器</li>\n<li>配置AOP切面</li>\n</ol>\n<p>配置方式：</p>\n<ol>\n<li>XML</li>\n<li>JavaConfig</li>\n<li>混合配置</li>\n</ol>\n<h1 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h1><p>五种隔离级别：</p>\n<ol>\n<li>ISOLATION_DEFAULT: 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别，另外四个与JDBC的隔离级别相对应。</li>\n<li>ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</li>\n<li>ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</li>\n<li>ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</li>\n<li>ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</li>\n</ol>\n<h2 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h3><h3 id=\"JavaConfig\"><a href=\"#JavaConfig\" class=\"headerlink\" title=\"JavaConfig\"></a>JavaConfig</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Transactional(isolation &#x3D; xxx)</span><br></pre></td></tr></table></figure>\n<h3 id=\"编程式事务在Template里面配置\"><a href=\"#编程式事务在Template里面配置\" class=\"headerlink\" title=\"编程式事务在Template里面配置\"></a>编程式事务在Template里面配置</h3><h1 id=\"事务传播性\"><a href=\"#事务传播性\" class=\"headerlink\" title=\"事务传播性\"></a>事务传播性</h1><p>主要有7种传播性：</p>\n<ol>\n<li><p>PROPAGATION_REQUIRED<br>如果当前有事务，就加入该事务；<br>如果没有事务，那么就起一个新的事务。</p>\n</li>\n<li><p>PROPAGATION_SUPPORTS<br>如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行</p>\n</li>\n<li><p>PROPAGATION_MANDATORY<br>必须在一个事务中运行。也就是说，他只能被一个父事务调用（就是必须要一个事务）。否则，他就要抛出异常</p>\n</li>\n<li><p>PROPAGATION_REQUIRES_NEW<br>新起一个事务。<br>这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，<br>那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。如果ServiceB.methodB已经提交，那 么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。</p>\n</li>\n<li><p>PROPAGATION_NOT_SUPPORTED<br>有事务，挂起事务，然后执行自己的行为（非事务执行），再恢复事务。<br>当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，<br>那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。</p>\n</li>\n<li><p>PROPAGATION_NEVER<br>不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，<br>那么ServiceB.methodB就要抛出异常了。</p>\n</li>\n<li><p>PROPAGATION_NESTED<br>子事务可以单独存在，如果子事务的异常处理好了，父事务不用回滚。但是父事务回滚，子事务需要一起回滚。<br>理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。而Nested事务的好处是他有一个savepoint。</p>\n</li>\n</ol>\n<h1 id=\"回滚规则\"><a href=\"#回滚规则\" class=\"headerlink\" title=\"回滚规则\"></a>回滚规则</h1><h2 id=\"默认规则\"><a href=\"#默认规则\" class=\"headerlink\" title=\"默认规则\"></a>默认规则</h2><p>运行时异常回滚：Error或者RuntimeException；检查型异常不回滚</p>\n<h2 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h2><ol>\n<li>RollbackFor = xxx.class</li>\n<li>noRollbackFor = xxx.class</li>\n</ol>\n<h1 id=\"事务只读\"><a href=\"#事务只读\" class=\"headerlink\" title=\"事务只读\"></a>事务只读</h1><p>就是对于某个查询来讲，如果该事务里有多个查询方式，确保各个查询保持强一致的优化选项。<br>“只读事务”仅仅是一个性能优化的推荐配置而已<br>readonly = true</p>\n<h1 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h1><p>时间内没有运行结束，则回滚</p>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><h2 id=\"只能用于public\"><a href=\"#只能用于public\" class=\"headerlink\" title=\"只能用于public\"></a>只能用于public</h2><p>protecte 会不生效</p>\n<h2 id=\"内部类调用事务方法，事务会失效\"><a href=\"#内部类调用事务方法，事务会失效\" class=\"headerlink\" title=\"内部类调用事务方法，事务会失效\"></a>内部类调用事务方法，事务会失效</h2><p>原理应该是AOP代理类的底层，如果直接内部调用，就不使用AOP代理了。</p>\n<h1 id=\"结合Mybatis-Plus使用事务\"><a href=\"#结合Mybatis-Plus使用事务\" class=\"headerlink\" title=\"结合Mybatis-Plus使用事务\"></a>结合Mybatis-Plus使用事务</h1>","categories":["框架"],"tags":["Spring","事务"]},{"title":"Spring","url":"/2021/04/15/Spring/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Spring是JavaSE/JavaEE分层应用的轻量级开源框架。核心以IOC和AOP。<br>提供了展示层SpringMVC和持久层Spring JDBC等以及业务层事务管理等众多企业级应用技术。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"发展历史\"><a href=\"#发展历史\" class=\"headerlink\" title=\"发展历史\"></a>发展历史</h1><h1 id=\"Spring优势\"><a href=\"#Spring优势\" class=\"headerlink\" title=\"Spring优势\"></a>Spring优势</h1><h2 id=\"方便解耦，简化开发\"><a href=\"#方便解耦，简化开发\" class=\"headerlink\" title=\"方便解耦，简化开发\"></a>方便解耦，简化开发</h2><p>Spring提供IOC容器，对象间的依赖关系交由Spring控制，避免硬编码导致的过度耦合。</p>\n<h2 id=\"AOP编程支持\"><a href=\"#AOP编程支持\" class=\"headerlink\" title=\"AOP编程支持\"></a>AOP编程支持</h2><p>方便进行切面编程。使用不容易用传统OOP的实现可以用AOP来实现。</p>\n<h2 id=\"声明式事务的支持\"><a href=\"#声明式事务的支持\" class=\"headerlink\" title=\"声明式事务的支持\"></a>声明式事务的支持</h2><p>从繁琐的事务管理代码中隔离出来，提高开发效率和质量。</p>\n<h2 id=\"方便程序测试\"><a href=\"#方便程序测试\" class=\"headerlink\" title=\"方便程序测试\"></a>方便程序测试</h2><p>…</p>\n<h2 id=\"集成了各种优秀框架\"><a href=\"#集成了各种优秀框架\" class=\"headerlink\" title=\"集成了各种优秀框架\"></a>集成了各种优秀框架</h2><p>…</p>\n<h2 id=\"降低JavaEE的API使用难度\"><a href=\"#降低JavaEE的API使用难度\" class=\"headerlink\" title=\"降低JavaEE的API使用难度\"></a>降低JavaEE的API使用难度</h2><p>Spring对JavaEE的API再度进行了封装，方便使用API。</p>\n<h2 id=\"Java源码的学习典范\"><a href=\"#Java源码的学习典范\" class=\"headerlink\" title=\"Java源码的学习典范\"></a>Java源码的学习典范</h2><h1 id=\"Spring的体系结构\"><a href=\"#Spring的体系结构\" class=\"headerlink\" title=\"Spring的体系结构\"></a>Spring的体系结构</h1><p><img src=\"/2021/04/15/Spring/Spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\"></p>\n<h1 id=\"Spring程序开发步骤\"><a href=\"#Spring程序开发步骤\" class=\"headerlink\" title=\"Spring程序开发步骤\"></a>Spring程序开发步骤</h1><ol>\n<li>定义好所需要的Bean。</li>\n<li>使用XML配置文件（或注解）配置好。</li>\n<li>Spring读取配置文件，根据配置需求，在IOC容器中管理Bean的实例。</li>\n<li>有需要的时候，从IOC容器中获取。</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/Spring%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4.png\"></p>\n<h1 id=\"Spring-Core（核心功能）\"><a href=\"#Spring-Core（核心功能）\" class=\"headerlink\" title=\"Spring Core（核心功能）\"></a>Spring Core（核心功能）</h1><p>官方文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction\">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction</a></p>\n<h2 id=\"IoC容器\"><a href=\"#IoC容器\" class=\"headerlink\" title=\"IoC容器\"></a>IoC容器</h2><p>Inversion of Control (IoC)</p>\n<h3 id=\"Ioc和Bean\"><a href=\"#Ioc和Bean\" class=\"headerlink\" title=\"Ioc和Bean\"></a>Ioc和Bean</h3><p>IoC：<strong>IoC</strong> is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.</p>\n<p>Bean：In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called <strong>beans</strong>. A bean is an object that is instantiated, assembled, and managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.</p>\n<h2 id=\"容器简介\"><a href=\"#容器简介\" class=\"headerlink\" title=\"容器简介\"></a>容器简介</h2><p><strong>org.springframework.context.ApplicationContext</strong>接口代表了IoC容器，通过读取配置源数据（MetaData）获取信息，然后进行Bean的初始化、配置和组装。</p>\n<h3 id=\"配置元数据\"><a href=\"#配置元数据\" class=\"headerlink\" title=\"配置元数据\"></a>配置元数据</h3><p>元数据是你根据开发需求，告诉IoC容器如何在应用中实例化、配置、组装对象。元数据可以使用用XML文件、Java注解或者Java代码进行配置。<br>通常管理多个Bean时，在XML文件中配置顶层的Bean，然后依次在里面配置Bean。而使用Java配置，则在类上使用@Configuration，里面的类使用@Bean来进行。</p>\n<div class=\"note info\">\n            <p>Spring2.5支持Annotation-based configuration<br>Spring3.0支持Java-based configuration<br>现在更多使用Java-based configuration来配置，XML使用少了。</p>\n          </div>\n\n<p>These bean definitions correspond to the actual objects that make up your application. Typically, you define service layer objects, data access objects (DAOs), presentation objects such as Struts Action instances, infrastructure objects such as Hibernate SessionFactories, JMS Queues, and so forth. Typically, one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See Using AspectJ to dependency-inject domain objects with Spring.（?）</p>\n<p><img src=\"/2021/04/15/Spring/XML%E9%85%8D%E7%BD%AE.png\"></p>\n<h3 id=\"链接多个XML文件（分模块开发）\"><a href=\"#链接多个XML文件（分模块开发）\" class=\"headerlink\" title=\"链接多个XML文件（分模块开发）\"></a>链接多个XML文件（分模块开发）</h3><p><img src=\"/2021/04/15/Spring/%E5%A4%9A%E4%B8%AAXML%E9%85%8D%E7%BD%AE.png\"><br>执行链接<br><img src=\"/2021/04/15/Spring/%E9%93%BE%E6%8E%A5.png\"></p>\n<div class=\"note info\">\n            <p>resource默认省略了初始的 / </p>\n          </div>\n\n<h3 id=\"实例化元数据\"><a href=\"#实例化元数据\" class=\"headerlink\" title=\"实例化元数据\"></a>实例化元数据</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;services.xml&quot;</span>, <span class=\"string\">&quot;daos.xml&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用容器\"><a href=\"#使用容器\" class=\"headerlink\" title=\"使用容器\"></a>使用容器</h3><p><strong>ApplicationContext</strong>是一个接口，为了实现维护不同Bean注册和依赖的高级工厂功能。通过getBean方法，获取Bean的实例。<br><img src=\"/2021/04/15/Spring/ApplicationContext.png\"><br>如果需要使用Groovy configuration：参考官方文档。</p>\n<div class=\"note info\">\n            <p>在Web应用中，每次从容器中取Bean都要创建ApplicationContext上下文。因此可以使用ServletContextListener监听器，Web启动时，就将ApplicationContext放到servletContext中。从而servlet的各个位置可以共享这个ApplicationContext对象。</p>\n          </div>\n\n<h2 id=\"Bean简介\"><a href=\"#Bean简介\" class=\"headerlink\" title=\"Bean简介\"></a>Bean简介</h2><h3 id=\"Bean的命名\"><a href=\"#Bean的命名\" class=\"headerlink\" title=\"Bean的命名\"></a>Bean的命名</h3><p>任何Bean都有一个或多个标识。XML里面：使用id或name或同时使用来标识。</p>\n<p>You are not required to supply a name or an id for a bean. If you do not supply a name or id explicitly, the container generates a unique name for that bean. However, if you want to refer to that bean by name, through the use of the ref element or a Service Locator style lookup, you must provide a name. Motivations for not supplying a name are related to using inner beans and autowiring collaborators.</p>\n<h3 id=\"Bean的别名\"><a href=\"#Bean的别名\" class=\"headerlink\" title=\"Bean的别名\"></a>Bean的别名</h3><ol>\n<li>在name标签里使用comma (,), semicolon (;), or white space来分离。</li>\n<li>使用alias标签</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/alias.png\"></p>\n<h3 id=\"初始化Bean\"><a href=\"#初始化Bean\" class=\"headerlink\" title=\"初始化Bean\"></a>初始化Bean</h3><ol>\n<li>使用具体的Class实现来初始化<br><img src=\"/2021/04/15/Spring/%E6%9E%84%E9%80%A0%E5%88%9D%E5%A7%8B%E5%8C%96.png\"></li>\n<li>使用静态工厂来初始化<br><img src=\"/2021/04/15/Spring/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E5%88%9D%E5%A7%8B%E5%8C%96.png\"></li>\n<li>使用实例工厂来初始化<br><img src=\"/2021/04/15/Spring/%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E5%88%9D%E5%A7%8B%E5%8C%96.png\"><div class=\"note info\">\n            <p>静态工厂和实例工厂的区别？<br>另外factory-method的名字，就是对应创建的方法名。</p>\n          </div></li>\n<li>自己创建FactoryBean来创建实例<br><img src=\"/2021/04/15/Spring/FactoryBean.png\"></li>\n</ol>\n<h3 id=\"Bean的Collection封装\"><a href=\"#Bean的Collection封装\" class=\"headerlink\" title=\"Bean的Collection封装\"></a>Bean的Collection封装</h3><ol>\n<li>在Bean中使用Object[] 来定义成员变量名</li>\n<li>Array、List、Set<br>1）Array使用array标签<br>2）List使用List标签<br>3）Set使用set标签<br>4）标签内部：1⃣️基本数据类型、包装类、字符串；2⃣️POJO（使用ref，或者内部使用bean标签）</li>\n<li>Map<br>1）使用map标签<br>2）标签内部：使用entry标签。1⃣️基本数据类型、包装类、字符串，key=“xxx” value=“xxx”；2⃣️POJO，key=“xxx” value-ref=“xxx”，或者内部bean标签、ref bean标签。</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/Bean-Array.png\"><br><img src=\"/2021/04/15/Spring/Bean-ListSet.png\"><br><img src=\"/2021/04/15/Spring/Bean-Map.png\"><br><img src=\"/2021/04/15/Spring/Bean-Property.png\"></p>\n<h3 id=\"确定Bean的运行时类型\"><a href=\"#确定Bean的运行时类型\" class=\"headerlink\" title=\"确定Bean的运行时类型\"></a>确定Bean的运行时类型</h3><p>The recommended way to find out about the actual runtime type of a particular bean is a BeanFactory.getType call for the specified bean name. This takes all of the above cases into account and returns the type of object that a BeanFactory.getBean call is going to return for the same bean name.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class&lt;T&gt; BeanFactory.getType(String name)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>完整的企业代码肯定不会是单一对象存在，一个对象一定会依赖其他对象。</p>\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><p>Dependency injection (DI) is a process whereby objects define their dependencies (that is, the other objects with which they work) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies on its own by using direct construction of classes or the Service Locator pattern.</p>\n<p>使用依赖注入（DI），可以使代码更加清晰，当对象提供了他们的依赖时，进一步让代码解耦。对象不再需要查找对应的依赖或依赖路径（因为通过Spring注入进来，或者说从Spring容器里取）。也使得程序更容易测试。</p>\n<p>依赖注入主要通过两种方式：</p>\n<ol>\n<li><p>有参构造器方式注入（Constructor-based Dependency Injection）<br><img src=\"/2021/04/15/Spring/%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A51.png\"><br>构造语法1：<br><img src=\"/2021/04/15/Spring/%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A52.png\"><br>构造语法2:<br><img src=\"/2021/04/15/Spring/%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A53.png\"></p>\n</li>\n<li><p>无参Setter方式注入（Setter-based dependency injection）<br><img src=\"/2021/04/15/Spring/Setter%E6%B3%A8%E5%85%A5.png\"></p>\n</li>\n</ol>\n<div class=\"note info\">\n            <p>Setter还可以使用p-namespace方式。</p>\n          </div>\n\n<h3 id=\"使用构造器还是Setter？\"><a href=\"#使用构造器还是Setter？\" class=\"headerlink\" title=\"使用构造器还是Setter？\"></a>使用构造器还是Setter？</h3><p>一般使用Setter，但是要根据具体情况来具体分析。各有千秋</p>\n<h3 id=\"依赖解析过程\"><a href=\"#依赖解析过程\" class=\"headerlink\" title=\"依赖解析过程\"></a>依赖解析过程</h3><h3 id=\"依赖和注入的细节\"><a href=\"#依赖和注入的细节\" class=\"headerlink\" title=\"依赖和注入的细节\"></a>依赖和注入的细节</h3><ol>\n<li>直接赋值<br><img src=\"/2021/04/15/Spring/%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC.png\"></li>\n<li>引用其他Bean<br><img src=\"/2021/04/15/Spring/%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96Bean.png\"><br><img src=\"/2021/04/15/Spring/%E5%BC%95%E7%94%A8%E7%88%B6%E7%B1%BB.png\"></li>\n<li>内部Bean<br><img src=\"/2021/04/15/Spring/%E5%86%85%E9%83%A8Bean.png\"></li>\n<li>集合（需要有Set方法）<br>1）基础集合<br><img src=\"/2021/04/15/Spring/%E5%9F%BA%E7%A1%80%E9%9B%86%E5%90%88.png\"><br>2）合并集合<br><img src=\"/2021/04/15/Spring/%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88.png\"></li>\n</ol>\n<div class=\"note info\">\n            <p>合并集合的限制：不能将不同集合类型合并。</p>\n          </div>\n<p>3）强类型集合<br>5. Null和空String<br><img src=\"/2021/04/15/Spring/Null.png\"><br><img src=\"/2021/04/15/Spring/%E7%A9%BAString.png\"><br>6. Property</p>\n<h2 id=\"Bean的作用域-Bean-Scopes\"><a href=\"#Bean的作用域-Bean-Scopes\" class=\"headerlink\" title=\"Bean的作用域(Bean Scopes)\"></a>Bean的作用域(Bean Scopes)</h2><p><img src=\"/2021/04/15/Spring/Bean-Scopes.png\"></p>\n<h3 id=\"The-Singleton-Scope\"><a href=\"#The-Singleton-Scope\" class=\"headerlink\" title=\"The Singleton Scope\"></a>The Singleton Scope</h3><p>Singleton的生命周期持续围绕着IoC容器，随IoC容器创建而创建，销毁而销毁。</p>\n<h3 id=\"The-Prototype-Scope\"><a href=\"#The-Prototype-Scope\" class=\"headerlink\" title=\"The Prototype Scope\"></a>The Prototype Scope</h3><p>Prototype的只有在getBean时，会创建，长时间不用的时候，则会被Java回收。</p>\n<h3 id=\"Singleton-Beans-with-Prototype-bean-Dependencies（-）\"><a href=\"#Singleton-Beans-with-Prototype-bean-Dependencies（-）\" class=\"headerlink\" title=\"Singleton Beans with Prototype-bean Dependencies（!）\"></a>Singleton Beans with Prototype-bean Dependencies（!）</h3><div class=\"note info\">\n            <p>singleton的Bean在IoC容器生成时，就会创建Bean。而prototype，则在什么时候使用Bean的时候(获取的时候），才会生成。</p>\n          </div>\n\n<h2 id=\"自定义Bean的性质\"><a href=\"#自定义Bean的性质\" class=\"headerlink\" title=\"自定义Bean的性质\"></a>自定义Bean的性质</h2><h3 id=\"生命周期调用\"><a href=\"#生命周期调用\" class=\"headerlink\" title=\"生命周期调用\"></a>生命周期调用</h3><ol>\n<li>初始化调用<br><img src=\"/2021/04/15/Spring/Init-method.png\"></li>\n<li>摧毁调用<br><img src=\"/2021/04/15/Spring/Destroy-method.png\"></li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/getBean%E4%B9%8B%E5%89%8D%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\"></p>\n<div class=\"note info\">\n            <p>除了自定义的BeanPostProcessor本身，其他的Bean都会经过before和after的加强。</p>\n          </div>\n\n<h3 id=\"scope和生命周期的关系\"><a href=\"#scope和生命周期的关系\" class=\"headerlink\" title=\"scope和生命周期的关系\"></a>scope和生命周期的关系</h3><ol>\n<li>singleton<br>获取到applicationContext时，就实例化Bean。<br><img src=\"/2021/04/15/Spring/singleton.png\"></li>\n<li>protoType<br>使用的时候，才实例化Bean，并且没有destory的过程。<br><img src=\"/2021/04/15/Spring/prototype.png\"></li>\n</ol>\n<h1 id=\"使用Spring\"><a href=\"#使用Spring\" class=\"headerlink\" title=\"使用Spring\"></a>使用Spring</h1><h2 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h2><ol>\n<li>pom导包(Spring-Context)</li>\n<li>resources里添加springConfig的xml：命名一般为applicationContext</li>\n<li>在xml里配置Bean标签</li>\n<li>使用ApplicationContext读取applicationContext.xml（注意xml后缀不能忘记）</li>\n<li>获取Bean，并使用Bean的方法</li>\n</ol>\n<div class=\"note info\">\n            <p>ApplicationContext使用ClassPathXmlApplicationContext来读取XML文件，它是通过Class类的配置文件路径来读取文件的。<br>也可以使用File文件路径来读取，但是不建议。</p>\n          </div>\n\n<h2 id=\"Spring配置文件\"><a href=\"#Spring配置文件\" class=\"headerlink\" title=\"Spring配置文件\"></a>Spring配置文件</h2><h3 id=\"Spring标签\"><a href=\"#Spring标签\" class=\"headerlink\" title=\"Spring标签\"></a>Spring标签</h3><p><img src=\"/2021/04/15/Spring/Spring%E6%A0%87%E7%AD%BE.png\"></p>\n<h2 id=\"SpringAPI\"><a href=\"#SpringAPI\" class=\"headerlink\" title=\"SpringAPI\"></a>SpringAPI</h2><h3 id=\"ApplicationContext的实现类\"><a href=\"#ApplicationContext的实现类\" class=\"headerlink\" title=\"ApplicationContext的实现类\"></a>ApplicationContext的实现类</h3><p><img src=\"/2021/04/15/Spring/ApplicationContext%E7%9A%84API.png\"></p>\n<ol>\n<li>ClassPathXmlApplicationContext<br>从类的根目录下读取</li>\n<li>FileSystemXmlApplicationContext<br>从磁盘文件系统中读取</li>\n<li>AnnotationConfigApplicationContext<br>使用注解配置时，Spring需要从此类中读取配置。</li>\n</ol>\n<h3 id=\"getBean\"><a href=\"#getBean\" class=\"headerlink\" title=\"getBean()\"></a>getBean()</h3><ol>\n<li>String name（根据ID）<br>可以配置多个</li>\n<li>Class requiredType（根据类型）<br>只能配置一个</li>\n</ol>\n<h2 id=\"Spring配置数据库\"><a href=\"#Spring配置数据库\" class=\"headerlink\" title=\"Spring配置数据库\"></a>Spring配置数据库</h2><h3 id=\"数据库连接池（DataSource）\"><a href=\"#数据库连接池（DataSource）\" class=\"headerlink\" title=\"数据库连接池（DataSource）\"></a>数据库连接池（DataSource）</h3><p>数据库连接池是为了提高程序访问数据库效率的。<br>事先实例化数据库连接池，初始化部分连接。<br>需要使用时候，从连接池中获取数据源。<br>使用结束时，则归还给连接池，减少反复实例化和销毁所带来的计算和IO消耗。</p>\n<h3 id=\"DataSource开发步骤\"><a href=\"#DataSource开发步骤\" class=\"headerlink\" title=\"DataSource开发步骤\"></a>DataSource开发步骤</h3><ol>\n<li>导入数据库连接池坐标和数据库驱动坐标</li>\n<li>创建数据库连接池对象</li>\n<li>设置数据库连接池基本连接配置</li>\n<li>使用数据库连接池</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BE%9D%E8%B5%96.png\"><br><img src=\"/2021/04/15/Spring/%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.png\"></p>\n<h3 id=\"使用配置文件连接DataSource\"><a href=\"#使用配置文件连接DataSource\" class=\"headerlink\" title=\"使用配置文件连接DataSource\"></a>使用配置文件连接DataSource</h3><p>[待整理]</p>\n<ol>\n<li>创建配置文件（xxx.properties）</li>\n<li>里面配置好（驱动、url、用户名、密码等）配置</li>\n<li>使用数据库连接池</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/properties%E9%85%8D%E7%BD%AE.png\"></p>\n<h3 id=\"将DataSource对象的创建交给Spring来处理\"><a href=\"#将DataSource对象的创建交给Spring来处理\" class=\"headerlink\" title=\"将DataSource对象的创建交给Spring来处理\"></a>将DataSource对象的创建交给Spring来处理</h3><ol>\n<li>导入spring-context依赖</li>\n<li>创建applicationContext.xml，并写入配置</li>\n<li>使用Spring来创建</li>\n</ol>\n<h3 id=\"使用配置文件，并由Spring来管理DataSource\"><a href=\"#使用配置文件，并由Spring来管理DataSource\" class=\"headerlink\" title=\"使用配置文件，并由Spring来管理DataSource\"></a>使用配置文件，并由Spring来管理DataSource</h3><ol>\n<li>applicationContext.xml里增加context Schema（详细见官方文档附录）</li>\n<li>配置context的property</li>\n<li>使用SpringContext加载property</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/%E6%B7%BB%E5%8A%A0context-schema.png\"><br><img src=\"/2021/04/15/Spring/property-placeholder.png\"></p>\n<h2 id=\"Spring注解开发（重要）\"><a href=\"#Spring注解开发（重要）\" class=\"headerlink\" title=\"Spring注解开发（重要）\"></a>Spring注解开发（重要）</h2><h3 id=\"原始注解\"><a href=\"#原始注解\" class=\"headerlink\" title=\"原始注解\"></a>原始注解</h3><p>因为Spring注重的是轻代码，而配置又比较繁琐。因此使用注解开发可以简化配置，提高开发效率。</p>\n<p><img src=\"/2021/04/15/Spring/Spring%E6%B3%A8%E8%A7%A3.png\"></p>\n<ol>\n<li>导Spring-context包</li>\n<li>使用@Component(“aaa”)配置在Bean上</li>\n<li>使用@Component(“bbb”)配置在另个Bean上，内部属性使用@AutoWired, @Qualifier(“aaa”)，把aaa实例依赖注入到bbb上。</li>\n<li>在applicationContext.xml里面配置context扫描组件包名</li>\n<li>使用applicationContext运行，管理各个Bean</li>\n</ol>\n<h3 id=\"更精细的注解\"><a href=\"#更精细的注解\" class=\"headerlink\" title=\"更精细的注解\"></a>更精细的注解</h3><p>@Service<br>@Controller<br>@Repository<br>@Resource：等于Autowired + Qualifier</p>\n<div class=\"note info\">\n            <p>使用注解可以不用给Bean写set方法（XML必须要）（为什么？）。<br>另外Qualifier也可以省略（在一个类型只对应一个Bean的时候，因为是Spring按照类型来匹配注入），一个类型多个Bean的时候，就要注明id。<br>使用@Autowired时候，不用进行组件扫描，因为是spring会自动进行寻找注入。</p>\n          </div>\n\n<div class=\"note info\">\n            <p>@Value的更精细操作：@Value(“${jdbc.driver}”)<br>可以直接从Spring的properties里读取。</p>\n          </div>\n\n<div class=\"note info\">\n            <p>@PostConstruct和@PreDestory替代了先前XML里的init和destory。</p>\n          </div>\n\n<h3 id=\"新注解\"><a href=\"#新注解\" class=\"headerlink\" title=\"新注解\"></a>新注解</h3><p><img src=\"/2021/04/15/Spring/%E6%96%B0%E6%B3%A8%E8%A7%A3.png\"></p>\n<div class=\"note info\">\n            <p>@PropertySource(“classpath:xxx.properties”)：要使用classpath</p>\n          </div>\n\n<p>ApplicationContext的获取也有所不同：<br><img src=\"/2021/04/15/Spring/AnnotationConfigApplicationContext.png\"></p>\n<h2 id=\"在Spring里Junit集成进行测试（已过时）\"><a href=\"#在Spring里Junit集成进行测试（已过时）\" class=\"headerlink\" title=\"在Spring里Junit集成进行测试（已过时）\"></a>在Spring里Junit集成进行测试（已过时）</h2><ol>\n<li>导入Spring-text包（集成了Junit）</li>\n<li>使用@Runwith(SpringJUnit4ClassRunner)代替原来运行</li>\n<li>使用@ContextConfiguration指定配置文件和配置类</li>\n<li>使用@Autowired注入要测试的对象</li>\n<li>创建测试方法进行测试</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/Spring-test.png\"><br><img src=\"/2021/04/15/Spring/Spring%E6%B5%8B%E8%AF%95%E7%B1%BB.png\"></p>\n<h2 id=\"在Spring里使用Jupiter\"><a href=\"#在Spring里使用Jupiter\" class=\"headerlink\" title=\"在Spring里使用Jupiter\"></a>在Spring里使用Jupiter</h2><ol>\n<li>导入Jupiter</li>\n<li>使用@ExtendWith(SpringExtension.class)</li>\n<li>使用@ContextConfiguration(“classpath:applicationContext.xml”)指定配置文件和配置类</li>\n<li>使用@Autowired注入要测试的对象</li>\n<li>创建测试方法进行测试</li>\n</ol>\n<h2 id=\"在Spring搭建Web环境（Tomcat）\"><a href=\"#在Spring搭建Web环境（Tomcat）\" class=\"headerlink\" title=\"在Spring搭建Web环境（Tomcat）\"></a>在Spring搭建Web环境（Tomcat）</h2><ol>\n<li>导入Servlet包</li>\n<li>配置Tomcat的部署环境（bin位置、端口以及Deployment和Application context）</li>\n<li>运行</li>\n</ol>\n<h3 id=\"使用监听器（Listener）管理ApplicationContext（了解原理）\"><a href=\"#使用监听器（Listener）管理ApplicationContext（了解原理）\" class=\"headerlink\" title=\"使用监听器（Listener）管理ApplicationContext（了解原理）\"></a>使用监听器（Listener）管理ApplicationContext（了解原理）</h3><ol>\n<li>写一个监听器，初始化函数把ApplicationContext放入ServletContext里</li>\n<li>Web.xml里配置监听器</li>\n<li>从ServletContext获取ApplicationContext</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/Web%E7%9B%91%E5%90%AC%E5%99%A8.png\"><br><img src=\"/2021/04/15/Spring/%E9%85%8D%E7%BD%AE%E7%9B%91%E5%90%AC%E5%99%A8.png\"></p>\n<h3 id=\"Web全局初始化参数（了解原理）\"><a href=\"#Web全局初始化参数（了解原理）\" class=\"headerlink\" title=\"Web全局初始化参数（了解原理）\"></a>Web全局初始化参数（了解原理）</h3><p>将上述监听器代码再进行解耦优化。<br><img src=\"/2021/04/15/Spring/context-param.png\"><br><img src=\"/2021/04/15/Spring/%E7%9B%91%E5%90%AC%E5%99%A8%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2021/04/15/Spring/%E8%8E%B7%E5%8F%96applicatonContext%E5%B7%A5%E5%85%B7%E7%B1%BB.png\"></p>\n<div class=\"note info\">\n            <p>此时代码还有一个问题，就是要使用具体的字符串来指明applicationContext，再进一步优化，可以把获得applicationContext抽成一个方法（或工具类）。【改进为上面第三张图】</p>\n          </div>\n\n<h3 id=\"Spring提供的监听器（实际应用）\"><a href=\"#Spring提供的监听器（实际应用）\" class=\"headerlink\" title=\"Spring提供的监听器（实际应用）\"></a>Spring提供的监听器（实际应用）</h3><p>Spring提供了ContextLoaderListener，就是上述监听器的封装。</p>\n<ol>\n<li>导入Spring-web包（新版为Spring-webmvc）</li>\n<li>Web.xml里配置ContextLoaderListener和context-param</li>\n<li>使用WebApplicationContextUtils获取ApplicationContext</li>\n</ol>\n<div class=\"note info\">\n            <p>实际使用中，在这里配置Spring的xml配置，实现项目分离。<br>使用Spring的监听器，context-param里参数名必须是contextConfigLocation（因为Listener读取的就是指定这个参数名），路径要用classpath: </p>\n          </div>\n\n<div class=\"note info\">\n            <p>建议用spring-mvc管理controller，然后spring管理其他组件。</p>\n          </div>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">//application.xml配置排除Controller</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.example.SSM&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context:exclude-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;annotation&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//application-mvc.xml配置Controller(方式1)</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.example.SSM&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;annotation&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">//application-mvc.xml配置Controller(方式2)</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.example.SSM.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/04/15/Spring/ContextLoaderListener.png\"><br><img src=\"/2021/04/15/Spring/WebApplicationContextUtils.png\"></p>\n<h1 id=\"Spring-WebMVC\"><a href=\"#Spring-WebMVC\" class=\"headerlink\" title=\"Spring-WebMVC\"></a>Spring-WebMVC</h1><p>基于Java实现MVC设计模型的轻量级Web框架，已经融合Spring Web Flow中，同时支持RESTful接口。</p>\n<ol>\n<li>导入spring-webmvc包</li>\n<li>配置Servlet（DispatcherServlet）</li>\n<li>编写Controller和视图页面（POJO）</li>\n<li>将Controller配置到String容器中</li>\n<li>写一个springmvc.xml配置组件扫描</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/spring-webmvc.png\"><br><img src=\"/2021/04/15/Spring/DispatcherServlet.png\"><br><img src=\"/2021/04/15/Spring/springwebmvc.png\"><br><img src=\"/2021/04/15/Spring/Controller.png\"></p>\n<div class=\"note info\">\n            <p>静态页面要和WEB-INF同一级</p>\n          </div>\n<p>流程图解：<br><img src=\"/2021/04/15/Spring/SpringWebMVC%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3.png\"></p>\n<h2 id=\"Spring-WebMVC组件解析\"><a href=\"#Spring-WebMVC组件解析\" class=\"headerlink\" title=\"Spring-WebMVC组件解析\"></a>Spring-WebMVC组件解析</h2><ol>\n<li>发生请求到DispatcherServlet</li>\n<li>DispatcherServlet收到请求，调用HandlerMapping处理器映射器</li>\n<li>HandlerMapping处理器映射器找到对应的处理器，生成处理器对象和处理器拦截器，返回给DispatcherServlet</li>\n<li>DispatcherServlet调用HandlerAdaptor处理器适配器</li>\n<li>HandlerAdaptor处理器适配器调用具体的Controller处理器</li>\n<li>Controller执行完成返回ModelAndView给DispatcherServlet</li>\n<li>DispatcherServlet把ModelAndView传给ViewReslover</li>\n<li>ViewReslover处理后返回View</li>\n<li>DispatcherServlet根据View进行渲染，返回视图响应<br><img src=\"/2021/04/15/Spring/Spring-WebMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png\"></li>\n</ol>\n<h2 id=\"Spring-WebMVC注解解析\"><a href=\"#Spring-WebMVC注解解析\" class=\"headerlink\" title=\"Spring-WebMVC注解解析\"></a>Spring-WebMVC注解解析</h2><h3 id=\"RequestMapping\"><a href=\"#RequestMapping\" class=\"headerlink\" title=\"RequestMapping\"></a>RequestMapping</h3><p>在类上配为一级访问地址，在类的方法内再配就是二级访问地址。<br>方法的return 找的是当前对应的路径位置。<br><img src=\"/2021/04/15/Spring/RequestMapping.png\"></p>\n<div class=\"note info\">\n            <ol><li>多个url路径可以映射同一个handler</li><li>可以用星号通配<br>@RequestMapping(value=”hello*”)<br>@RequestMapping(value=”hello/*)”</li><li>窄化url映射<br>类上面使用@RequestMapping，内部方法上再使用@RequestMapping</li></ol>\n          </div>\n\n<h3 id=\"GetMapping\"><a href=\"#GetMapping\" class=\"headerlink\" title=\"GetMapping\"></a>GetMapping</h3><p>@GetMapping = @RequestMapping(method=RequestMethod.GET)</p>\n<h3 id=\"PostMapping\"><a href=\"#PostMapping\" class=\"headerlink\" title=\"PostMapping\"></a>PostMapping</h3><p>@PostMapping = @RequestMapping(method=RequestMethod.POST)</p>\n<h3 id=\"请求参数限定（了解，因为有专门的检验框架）\"><a href=\"#请求参数限定（了解，因为有专门的检验框架）\" class=\"headerlink\" title=\"请求参数限定（了解，因为有专门的检验框架）\"></a>请求参数限定（了解，因为有专门的检验框架）</h3><h4 id=\"限定参数名\"><a href=\"#限定参数名\" class=\"headerlink\" title=\"限定参数名\"></a>限定参数名</h4><p><img src=\"/2021/04/15/Spring/%E9%99%90%E5%AE%9A%E5%8F%82%E6%95%B01.png\"><br>多个参数的关系，必须是都缺一不可，否则报错<br><img src=\"/2021/04/15/Spring/%E9%99%90%E5%AE%9A%E5%8F%82%E6%95%B01.png\"></p>\n<h4 id=\"限定参数值\"><a href=\"#限定参数值\" class=\"headerlink\" title=\"限定参数值\"></a>限定参数值</h4><p><img src=\"/2021/04/15/Spring/%E9%99%90%E5%AE%9A%E5%8F%82%E6%95%B0%E5%80%BC.png\"></p>\n<h4 id=\"请求头限定\"><a href=\"#请求头限定\" class=\"headerlink\" title=\"请求头限定\"></a>请求头限定</h4><ol>\n<li>通用请求头<br><img src=\"/2021/04/15/Spring/%E9%80%9A%E7%94%A8%E8%AF%B7%E6%B1%82%E5%A4%B4.png\"></li>\n<li>produces<br><img src=\"/2021/04/15/Spring/produces.png\"></li>\n<li>consumes<br><img src=\"/2021/04/15/Spring/consumes.png\"></li>\n</ol>\n<div class=\"note info\">\n            <p>在Request中：</p><ol><li>ContentType 用来告诉服务器当前发送的数据是什么格式，consumes 用来限制ContentType。</li><li>Accept 用来告诉服务器，客户端能认识哪些格式,最好返回这些格式中的其中一种，produces 用来限制Accept。</li></ol>\n          </div>\n\n<h2 id=\"Spring-WebMVC的组件扫描\"><a href=\"#Spring-WebMVC的组件扫描\" class=\"headerlink\" title=\"Spring-WebMVC的组件扫描\"></a>Spring-WebMVC的组件扫描</h2><p>开发的时候一般，各司其职。Spring扫描Spring的组件，Spring-webMVC扫描它的组件。</p>\n<ol>\n<li>MVC命名空间</li>\n<li>include和exclud内部标签</li>\n</ol>\n<h2 id=\"Spring-WebMVC的XML配置\"><a href=\"#Spring-WebMVC的XML配置\" class=\"headerlink\" title=\"Spring-WebMVC的XML配置\"></a>Spring-WebMVC的XML配置</h2><p>配置内部解析器（用源码的setPrefix和setSuffix 来做）<br><img src=\"/2021/04/15/Spring/ViewResolver.png\"></p>\n<h2 id=\"Spring-WebMVC基础总结\"><a href=\"#Spring-WebMVC基础总结\" class=\"headerlink\" title=\"Spring-WebMVC基础总结\"></a>Spring-WebMVC基础总结</h2><p><img src=\"/2021/04/15/Spring/Spring-WebMVC%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93.png\"></p>\n<h2 id=\"Spring-WebMVC数据响应\"><a href=\"#Spring-WebMVC数据响应\" class=\"headerlink\" title=\"Spring-WebMVC数据响应\"></a>Spring-WebMVC数据响应</h2><ol>\n<li><p>Void<br>利用request和response来做 → 就是在servlet中的用法<br><img src=\"/2021/04/15/Spring/void.png\"></p>\n</li>\n<li><p>ModelAndView<br>1）通过页面直接返回字符串<br>2）返回ModelAndView<br><img src=\"/2021/04/15/Spring/ModelAndView.png\"></p>\n</li>\n</ol>\n<div class=\"note info\">\n            <p>配置好了模型数据，要在视图中使用${key}来获取。<br>ModelAndView也可以作为参数，Spring会从内部注入对象。<br>Model和View可以单独拆开，分别也可以作为参数。<br>Request 也可以作为参数使用，把内容放到RequestContext里。（但是不常用）<br>上述代码的ViewName是配置过Prefix和Suffix</p>\n          </div>\n\n<ol start=\"3\">\n<li>重定向和转发<br><img src=\"/2021/04/15/Spring/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91.png\"></li>\n</ol>\n<div class=\"note info\">\n            <p>视图名和重定向转发，最前方需要加 /</p>\n          </div>\n\n<ol start=\"4\">\n<li><p>回写数据<br>1）直接返回字符串<br>使用Spring-WebMVC注入Response对象，使用getWriter().print方法返回。<br>使用@ResponseBody返回，不会进行页面跳转，直接进行字符串输出。（主要）<br><img src=\"/2021/04/15/Spring/ResponseBody.png\"><br>返回Json字符串，使用工具类Gson返回<br><img src=\"/2021/04/15/Spring/ReturnJson.png\"><br>2）返回对象或者集合<br>返回对象，使用适配器把对象转化为Json字符串。<br><img src=\"/2021/04/15/Spring/%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BAJson.png\"></p>\n<div class=\"note info\">\n            <p>如果出现报错，查看是否导入fastjson包。<br>如果要返回集合，则把对象包装在集合里即可。</p>\n          </div>\n</li>\n<li><p>使用Spring-WebMVC注解驱动来改进代码<br><img src=\"/2021/04/15/Spring/Spring-WebMVC%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8.png\"><br><img src=\"/2021/04/15/Spring/mvc-annotation.png\"></p>\n</li>\n</ol>\n<h2 id=\"Spring-WebMVC接收数据\"><a href=\"#Spring-WebMVC接收数据\" class=\"headerlink\" title=\"Spring-WebMVC接收数据\"></a>Spring-WebMVC接收数据</h2><h3 id=\"接收的数据分类\"><a href=\"#接收的数据分类\" class=\"headerlink\" title=\"接收的数据分类\"></a>接收的数据分类</h3><ol>\n<li>基本数据类型<br>Controller的业务方法参数和请求参数一致，会自动对应。</li>\n<li>POJO<br>Controller的业务方法参数和POJO的属性名一致，即可直接使用。（写一个Bean，包含setter和getter）</li>\n<li>日期<br><img src=\"/2021/04/15/Spring/%E6%8E%A5%E6%94%B6%E6%97%A5%E6%9C%9F.png\"></li>\n<li>数组数据类型<br>Arrays.asList()</li>\n<li>集合数据类型<br>方法1: 封装到VO中<br>方法2: 如果是ajax提交，可以指定contentType为json，方法参数用@RequestBody来接收集合元素，而不需要POJO。<br><img src=\"/2021/04/15/Spring/ajax.png\"><br><img src=\"/2021/04/15/Spring/ajax-2.png\"></li>\n</ol>\n<h3 id=\"接收数据参数绑定\"><a href=\"#接收数据参数绑定\" class=\"headerlink\" title=\"接收数据参数绑定\"></a>接收数据参数绑定</h3><p>请求参数名和Controller的业务方法参数名不一致时，可以用@RequestParam来绑定参数。<br><img src=\"/2021/04/15/Spring/RequestParam.png\"></p>\n<div class=\"note info\">\n            <p>参数包括：value、required、defaultValue。</p>\n          </div>\n\n<h3 id=\"Restful风格（架构风格）\"><a href=\"#Restful风格（架构风格）\" class=\"headerlink\" title=\"Restful风格（架构风格）\"></a>Restful风格（架构风格）</h3><p>url + 请求方式<br>地址上的请求路径就是参数名。用{xxx}来标识占位，用@pathVariable(value=”xxx”来读取<br><img src=\"/2021/04/15/Spring/Restful.png\"></p>\n<h3 id=\"接收数据乱码问题\"><a href=\"#接收数据乱码问题\" class=\"headerlink\" title=\"接收数据乱码问题\"></a>接收数据乱码问题</h3><p>Spring提供了字符编码过滤器，在Web.xml里配置全局filter。<br><img src=\"/2021/04/15/Spring/CharacterEncodingFilter.png\"></p>\n<h3 id=\"静态资源访问\"><a href=\"#静态资源访问\" class=\"headerlink\" title=\"静态资源访问\"></a>静态资源访问</h3><p>因为Spring-WebMVC配了dispatchServlet，所以找一些静态资源的时候，会把静态资源的路径当作RequestMapping的映射，因此会找不到资源，要使用mvc:resources配置来开放资源。<br><img src=\"/2021/04/15/Spring/%E5%BC%80%E6%94%BE%E8%B5%84%E6%BA%90.png\"></p>\n<h3 id=\"自定义类型转换器（将接收的数据类型转换为其他数据类型）\"><a href=\"#自定义类型转换器（将接收的数据类型转换为其他数据类型）\" class=\"headerlink\" title=\"自定义类型转换器（将接收的数据类型转换为其他数据类型）\"></a>自定义类型转换器（将接收的数据类型转换为其他数据类型）</h3><ol>\n<li>定义转换器类实现converter接口</li>\n<li>SpringMVC里配置转换器<br><img src=\"/2021/04/15/Spring/ConversionService.png\"></li>\n</ol>\n<h3 id=\"获取Servlet相关的API\"><a href=\"#获取Servlet相关的API\" class=\"headerlink\" title=\"获取Servlet相关的API\"></a>获取Servlet相关的API</h3><p>Spring-WebMVC支持原生ServletAPI作为控制器方法参数进行注入。<br><img src=\"/2021/04/15/Spring/ServletAPI.png\"></p>\n<h3 id=\"获取请求头\"><a href=\"#获取请求头\" class=\"headerlink\" title=\"获取请求头\"></a>获取请求头</h3><ol>\n<li>@RequestHeader(value=”xxx”, required=true/false)</li>\n<li>@CookieValue(value=”xxx”, required=true/false)</li>\n</ol>\n<h3 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h3><ol>\n<li>导入commons-fileupload和commons-io包</li>\n<li>配置文件到SpringMVC.xml</li>\n<li>写上传文件处理方法，保存文件。</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/CommonsMultipartResolver.png\"><br><img src=\"/2021/04/15/Spring/upload.png\"></p>\n<div class=\"note info\">\n            <p>方法MultipartFile的参数名要和上传表单的file参数名一致。<br>多文件上传时，不同file名，就新增MultipartFile参数。<br>大量文件的时候，使用同一个file名，使用MultipartFile[]数组，for each来处理。</p>\n          </div>\n\n<h2 id=\"Spring-WebMVC拦截器\"><a href=\"#Spring-WebMVC拦截器\" class=\"headerlink\" title=\"Spring-WebMVC拦截器\"></a>Spring-WebMVC拦截器</h2><p>类似于Servlet的Filter，对处理器进行预处理和后处理。拦截器按照一定顺序组成一条链，成为拦截器链。拦截器是Spring的AOP思想和核心体现。</p>\n<div class=\"note info\">\n            <p>和过滤器（Filter）的区别：<br><img src=\"/2021/04/15/Spring/%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.png\"></p>\n          </div>\n<ol>\n<li>写拦截器类实现HandlerInterceptor</li>\n<li>在spring-mvc.xml里配置拦截器</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/HandlerInterceptor.png\"><br><img src=\"/2021/04/15/Spring/mvc-interceptors.png\"><br>全局拦截则这样配置：<br><img src=\"/2021/04/15/Spring/%E5%85%A8%E5%B1%80%E6%8B%A6%E6%88%AA.png\"></p>\n<div class=\"note info\">\n            <p>多个拦截器是由栈的顺序来执行。先pre的后post</p>\n          </div>\n<p><img src=\"/2021/04/15/Spring/%E6%8B%A6%E6%88%AA%E5%99%A8%E6%96%B9%E6%B3%95.png\"></p>\n<h2 id=\"Spring-WebMVC异常处理（待完成）\"><a href=\"#Spring-WebMVC异常处理（待完成）\" class=\"headerlink\" title=\"Spring-WebMVC异常处理（待完成）\"></a>Spring-WebMVC异常处理（待完成）</h2><ol>\n<li>简单</li>\n<li>自定义</li>\n</ol>\n<h2 id=\"Spring和Spring-WebMVC的分离\"><a href=\"#Spring和Spring-WebMVC的分离\" class=\"headerlink\" title=\"Spring和Spring-WebMVC的分离\"></a>Spring和Spring-WebMVC的分离</h2><p><img src=\"/2021/04/15/Spring/DispatcherServlet%E6%8F%8F%E8%BF%B0.png\"></p>\n<h2 id=\"Locale\"><a href=\"#Locale\" class=\"headerlink\" title=\"Locale\"></a>Locale</h2><p>handler方法的形参中 → 可以放到cookie或session中</p>\n<h3 id=\"在Handler里直接拿到默认Locale\"><a href=\"#在Handler里直接拿到默认Locale\" class=\"headerlink\" title=\"在Handler里直接拿到默认Locale\"></a>在Handler里直接拿到默认Locale</h3><p><img src=\"/2021/04/15/Spring/Locale.png\"></p>\n<h3 id=\"管理Locale\"><a href=\"#管理Locale\" class=\"headerlink\" title=\"管理Locale\"></a>管理Locale</h3><p>Cookie或者Session<br><img src=\"/2021/04/15/Spring/LocaleResolver.png\"></p>\n<div class=\"note info\">\n            <p>如果cookies里的对应值，则默认的Locale会被代替</p>\n          </div>\n\n<h2 id=\"MessageSource\"><a href=\"#MessageSource\" class=\"headerlink\" title=\"MessageSource\"></a>MessageSource</h2><h3 id=\"单独Message文件\"><a href=\"#单独Message文件\" class=\"headerlink\" title=\"单独Message文件\"></a>单独Message文件</h3><ol>\n<li>Message.properties<br><img src=\"/2021/04/15/Spring/MessageProperties.png\"></li>\n<li>配置Bean<br><img src=\"/2021/04/15/Spring/MessageSource.png\"></li>\n<li>使用MessageSource<br><img src=\"/2021/04/15/Spring/MessageSource2.png\"></li>\n</ol>\n<h3 id=\"Locale和MessageSource搭配\"><a href=\"#Locale和MessageSource搭配\" class=\"headerlink\" title=\"Locale和MessageSource搭配\"></a>Locale和MessageSource搭配</h3><ol>\n<li>配置Bundle和组件<br><img src=\"/2021/04/15/Spring/Bundle.png\"></li>\n<li>使用<br><img src=\"/2021/04/15/Spring/MessageSource3.png\"><br><img src=\"/2021/04/15/Spring/%E4%B8%8D%E5%90%8CLocale.png\"></li>\n</ol>\n<div class=\"note info\">\n            <p>关于第二个参数object[]：是从配置文件中取出的值 做占位符的赋值<br><img src=\"/2021/04/15/Spring/MessageSource%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0.png\"></p>\n          </div>\n\n<h3 id=\"请求参数验证\"><a href=\"#请求参数验证\" class=\"headerlink\" title=\"请求参数验证\"></a>请求参数验证</h3><p>Spring-WebMVC完善了MVC的许多操作，但是参数的合法性还是需要自己判断。<br>从而需要一个参数验证的实现，而验证代码繁琐冗余，并且重复劳动。<br>因而随着完善慢慢衍生出一个框架，Hibernate validator。<br>详细见Hibernate validator文章。</p>\n<h2 id=\"使用JavaConfig来配置Spring-WebMVC\"><a href=\"#使用JavaConfig来配置Spring-WebMVC\" class=\"headerlink\" title=\"使用JavaConfig来配置Spring-WebMVC\"></a>使用JavaConfig来配置Spring-WebMVC</h2><p>使用配置类来替代掉各种xml</p>\n<h3 id=\"AACDSI\"><a href=\"#AACDSI\" class=\"headerlink\" title=\"AACDSI\"></a>AACDSI</h3><p>AbstractAnnotationConfigDispatcherServletInitializer -&gt; 替代掉web.xml<br>读取Spring和Spring-WebMVC的配置<br><img src=\"/2021/04/15/Spring/AACDSI.png\"></p>\n<h3 id=\"Spring配置类\"><a href=\"#Spring配置类\" class=\"headerlink\" title=\"Spring配置类\"></a>Spring配置类</h3><p><img src=\"/2021/04/15/Spring/Spring%E9%85%8D%E7%BD%AE%E7%B1%BB.png\"></p>\n<h3 id=\"Spring-WebMVC配置类\"><a href=\"#Spring-WebMVC配置类\" class=\"headerlink\" title=\"Spring-WebMVC配置类\"></a>Spring-WebMVC配置类</h3><p><img src=\"/2021/04/15/Spring/Spring-WebMVC%E9%85%8D%E7%BD%AE%E7%B1%BB.png\"></p>\n<h3 id=\"其他组件注册（Spring-WebMVC）\"><a href=\"#其他组件注册（Spring-WebMVC）\" class=\"headerlink\" title=\"其他组件注册（Spring-WebMVC）\"></a>其他组件注册（Spring-WebMVC）</h3><h4 id=\"编解码过滤器CharactrerEncodingFilter\"><a href=\"#编解码过滤器CharactrerEncodingFilter\" class=\"headerlink\" title=\"编解码过滤器CharactrerEncodingFilter\"></a>编解码过滤器CharactrerEncodingFilter</h4><p><img src=\"/2021/04/15/Spring/getServletFilters.png\"></p>\n<h4 id=\"静态资源映射\"><a href=\"#静态资源映射\" class=\"headerlink\" title=\"静态资源映射\"></a>静态资源映射</h4><p><img src=\"/2021/04/15/Spring/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%98%A0%E5%B0%84.png\"></p>\n<h4 id=\"拦截器Interceptor\"><a href=\"#拦截器Interceptor\" class=\"headerlink\" title=\"拦截器Interceptor\"></a>拦截器Interceptor</h4><p><img src=\"/2021/04/15/Spring/Interceptor.png\"></p>\n<h4 id=\"文件上传multipartResolver\"><a href=\"#文件上传multipartResolver\" class=\"headerlink\" title=\"文件上传multipartResolver\"></a>文件上传multipartResolver</h4><p><img src=\"/2021/04/15/Spring/multipartResolver.png\"></p>\n<h4 id=\"localeResolver\"><a href=\"#localeResolver\" class=\"headerlink\" title=\"localeResolver\"></a>localeResolver</h4><p><img src=\"/2021/04/15/Spring/localeResolver-JavaConfig.png\"></p>\n<h4 id=\"viewResolver\"><a href=\"#viewResolver\" class=\"headerlink\" title=\"viewResolver\"></a>viewResolver</h4><p><img src=\"/2021/04/15/Spring/internalResourceViewResolver-JavaConfig.png\"></p>\n<h4 id=\"validator\"><a href=\"#validator\" class=\"headerlink\" title=\"validator\"></a>validator</h4><p><img src=\"/2021/04/15/Spring/validator-JavaConfig.png\"></p>\n<h4 id=\"converter\"><a href=\"#converter\" class=\"headerlink\" title=\"converter\"></a>converter</h4><p><img src=\"/2021/04/15/Spring/converter.png\"></p>\n<h4 id=\"handlerExceptionResolver\"><a href=\"#handlerExceptionResolver\" class=\"headerlink\" title=\"handlerExceptionResolver\"></a>handlerExceptionResolver</h4><p><img src=\"/2021/04/15/Spring/handlerExceptionResolver.png\"></p>\n<h4 id=\"messageSource\"><a href=\"#messageSource\" class=\"headerlink\" title=\"messageSource\"></a>messageSource</h4><div class=\"note info\">\n            <p>什么时候用@Component，什么时候用@Bean</p>\n          </div>\n\n<h2 id=\"其他相关组件（Spring）\"><a href=\"#其他相关组件（Spring）\" class=\"headerlink\" title=\"其他相关组件（Spring）\"></a>其他相关组件（Spring）</h2><h3 id=\"JdbcTemplate\"><a href=\"#JdbcTemplate\" class=\"headerlink\" title=\"JdbcTemplate\"></a>JdbcTemplate</h3><p><img src=\"/2021/04/15/Spring/JdbcTemplate-JavaConfig.png\"></p>\n<h3 id=\"TransactionManager\"><a href=\"#TransactionManager\" class=\"headerlink\" title=\"TransactionManager\"></a>TransactionManager</h3><p><img src=\"/2021/04/15/Spring/TransactionManager-JavaConfig.png\"></p>\n<h3 id=\"AspectJ\"><a href=\"#AspectJ\" class=\"headerlink\" title=\"AspectJ\"></a>AspectJ</h3><p>在Spring的Config上使用@EnableAspectJAutoProxy<br><img src=\"/2021/04/15/Spring/AspectJ-JavaConfig.png\"></p>\n<h1 id=\"JdbcTemplate-1\"><a href=\"#JdbcTemplate-1\" class=\"headerlink\" title=\"JdbcTemplate\"></a>JdbcTemplate</h1><p>Spring对原始繁琐的JDBC API进行了封装。提供了很多模板类</p>\n<h2 id=\"JdbcTemplate开发\"><a href=\"#JdbcTemplate开发\" class=\"headerlink\" title=\"JdbcTemplate开发\"></a>JdbcTemplate开发</h2><ol>\n<li>导入spring-jdbc和spring-tx坐标</li>\n<li>创建数据库表和实体</li>\n<li>创建JDBCTemplate对象</li>\n<li>执行数据库操作<br><img src=\"/2021/04/15/Spring/JdbcTemplate.png\"></li>\n</ol>\n<div class=\"note info\">\n            <p>Bean实体的属性名要和数据库属性名一致</p>\n          </div>\n<h2 id=\"Spring创建模板对象\"><a href=\"#Spring创建模板对象\" class=\"headerlink\" title=\"Spring创建模板对象\"></a>Spring创建模板对象</h2><p><img src=\"/2021/04/15/Spring/%E5%88%9B%E5%BB%BAJdbcTemplate.png\"><br>使用的时候，从applicationContext里面直接getBean(JdbcTemplate)即可。</p>\n<h2 id=\"JdbcTemplate常用操作\"><a href=\"#JdbcTemplate常用操作\" class=\"headerlink\" title=\"JdbcTemplate常用操作\"></a>JdbcTemplate常用操作</h2><h3 id=\"增删改\"><a href=\"#增删改\" class=\"headerlink\" title=\"增删改\"></a>增删改</h3><h3 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h3><p>查使用的RowMapper里，实现了从数据库类型往实体转换的方法。<br><img src=\"/2021/04/15/Spring/JdbcTemplateQuery.png\"></p>\n<ol>\n<li>查询所有</li>\n<li>查询一个</li>\n<li>查询函数</li>\n</ol>\n<h1 id=\"AOP思想\"><a href=\"#AOP思想\" class=\"headerlink\" title=\"AOP思想\"></a>AOP思想</h1><h2 id=\"AOP概念\"><a href=\"#AOP概念\" class=\"headerlink\" title=\"AOP概念\"></a>AOP概念</h2><h3 id=\"Target（目标对象）\"><a href=\"#Target（目标对象）\" class=\"headerlink\" title=\"Target（目标对象）\"></a>Target（目标对象）</h3><p>代理的目标对象</p>\n<h3 id=\"Proxy（代理）\"><a href=\"#Proxy（代理）\" class=\"headerlink\" title=\"Proxy（代理）\"></a>Proxy（代理）</h3><p>一个类被AOP植入增强后，产生的一个结果代理类</p>\n<h3 id=\"JoinPoint（连接点）\"><a href=\"#JoinPoint（连接点）\" class=\"headerlink\" title=\"JoinPoint（连接点）\"></a>JoinPoint（连接点）</h3><p>可以被拦截到的点，即指可以被增强的方法（因为Spring只支持方法类型的连接点）</p>\n<h3 id=\"PointCut（切点）\"><a href=\"#PointCut（切点）\" class=\"headerlink\" title=\"PointCut（切点）\"></a>PointCut（切点）</h3><p>就是指要对哪些JointPoint进行拦截</p>\n<h3 id=\"Advice（通知-增强）\"><a href=\"#Advice（通知-增强）\" class=\"headerlink\" title=\"Advice（通知/增强）\"></a>Advice（通知/增强）</h3><p>指对PointCut要做的事情就是通知</p>\n<h3 id=\"Aspect（切面）\"><a href=\"#Aspect（切面）\" class=\"headerlink\" title=\"Aspect（切面）\"></a>Aspect（切面）</h3><p>PointCut+Advice</p>\n<h3 id=\"Weaving（织入）\"><a href=\"#Weaving（织入）\" class=\"headerlink\" title=\"Weaving（织入）\"></a>Weaving（织入）</h3><p>把增强应用到目标对象来创建新的代理对象的过程。<br>Spring采用动态代理织入，AspectJ采用编译期织入和类装载期织入。</p>\n<h2 id=\"AOP底层实现\"><a href=\"#AOP底层实现\" class=\"headerlink\" title=\"AOP底层实现\"></a>AOP底层实现</h2><h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>基于接口的动态代理（见设计模式，代理）</p>\n<h3 id=\"cglib动态代理\"><a href=\"#cglib动态代理\" class=\"headerlink\" title=\"cglib动态代理\"></a>cglib动态代理</h3><p>基于父类的动态代理技术（见设计模式，代理）</p>\n<h2 id=\"AOP开发明确的事项\"><a href=\"#AOP开发明确的事项\" class=\"headerlink\" title=\"AOP开发明确的事项\"></a>AOP开发明确的事项</h2><h3 id=\"需要编写的内容\"><a href=\"#需要编写的内容\" class=\"headerlink\" title=\"需要编写的内容\"></a>需要编写的内容</h3><ol>\n<li>编写核心业务代码（目标类）</li>\n<li>编写切面类，和切面类的通知（增强方法）</li>\n<li>配置文件中，配置织入关系，通知和哪些连接点结合。</li>\n</ol>\n<h3 id=\"AOP实现过程\"><a href=\"#AOP实现过程\" class=\"headerlink\" title=\"AOP实现过程\"></a>AOP实现过程</h3><p>Spring框架监控切点方法的执行，检测到切点方法被运行，就使用代理机制，动态创造目标对象的代理对象，根据通知类型，在代理对象的对应位置，把通知对应的功能织入。</p>\n<h3 id=\"AOP底层使用哪种代理\"><a href=\"#AOP底层使用哪种代理\" class=\"headerlink\" title=\"AOP底层使用哪种代理\"></a>AOP底层使用哪种代理</h3><p>有接口，使用JDK，没有接口，使用cglib</p>\n<h2 id=\"查看AOP的\"><a href=\"#查看AOP的\" class=\"headerlink\" title=\"查看AOP的\"></a>查看AOP的</h2><h2 id=\"AOP开发（使用AspectJ）\"><a href=\"#AOP开发（使用AspectJ）\" class=\"headerlink\" title=\"AOP开发（使用AspectJ）\"></a>AOP开发（使用AspectJ）</h2><h3 id=\"基于XML\"><a href=\"#基于XML\" class=\"headerlink\" title=\"基于XML\"></a>基于XML</h3><ol>\n<li>导入spring-aop和aspectj包（context包含AOP）</li>\n<li>创建目标接口和目标类</li>\n<li>创建切面类</li>\n<li>将目标类和通知类的对象创建权交给Spring</li>\n<li>applicationContext配置织入关系</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/%E9%85%8D%E7%BD%AEAOP%E7%BB%87%E5%85%A5.png\"></p>\n<div class=\"note info\">\n            <p>Spring主张使用aspectJ，因为aspectJ更轻量，所以导入aspectJ</p>\n          </div>\n\n<p><img src=\"/2021/04/15/Spring/%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%99%E6%B3%95.png\"></p>\n<h4 id=\"通知种类\"><a href=\"#通知种类\" class=\"headerlink\" title=\"通知种类\"></a>通知种类</h4><p><img src=\"/2021/04/15/Spring/%E9%80%9A%E7%9F%A5%E7%A7%8D%E7%B1%BB.png\"><br>特别注意around，需要使用ProcessingJointCut参数。</p>\n<h4 id=\"方法抽取\"><a href=\"#方法抽取\" class=\"headerlink\" title=\"方法抽取\"></a>方法抽取</h4><p><img src=\"/2021/04/15/Spring/%E5%88%87%E9%9D%A2%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%8A%BD%E5%8F%96.png\"></p>\n<h3 id=\"基于注解\"><a href=\"#基于注解\" class=\"headerlink\" title=\"基于注解\"></a>基于注解</h3><p>1-5 步骤同xml<br>6. 给目标类和切面类写注解<br>7. 配置文件开启组件扫描和AOP自动代理</p>\n<p><img src=\"/2021/04/15/Spring/%E9%85%8D%E7%BD%AE%E5%88%87%E9%9D%A2%E7%BB%84%E4%BB%B6.png\"><br><img src=\"/2021/04/15/Spring/%E9%85%8D%E7%BD%AEaspectJ%E7%BB%87%E5%85%A5.png\"></p>\n<div class=\"note info\">\n            <p>@ENableAspectJAutoProxy，这个用来代替xml中的自动代理</p>\n          </div>\n<h4 id=\"通知种类-1\"><a href=\"#通知种类-1\" class=\"headerlink\" title=\"通知种类\"></a>通知种类</h4><p><img src=\"/2021/04/15/Spring/%E6%B3%A8%E8%A7%A3%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B.png\"></p>\n<h4 id=\"方法抽取-1\"><a href=\"#方法抽取-1\" class=\"headerlink\" title=\"方法抽取\"></a>方法抽取</h4><p><img src=\"/2021/04/15/Spring/%E5%88%87%E9%9D%A2%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%8A%BD%E5%8F%96-%E6%B3%A8%E8%A7%A3.png\"></p>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><p>即可以在类或方法上，使用自定义注解来加强功能<br><img src=\"/2021/04/15/Spring/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.png\"><br>切点使用自定义注解<br><img src=\"/2021/04/15/Spring/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A31.png\"><br><img src=\"/2021/04/15/Spring/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A32.png\"></p>\n<h1 id=\"Spring-Tx（Spring事务）\"><a href=\"#Spring-Tx（Spring事务）\" class=\"headerlink\" title=\"Spring-Tx（Spring事务）\"></a>Spring-Tx（Spring事务）</h1><p>事务是一个不可拆分的整体，操作的最小单位。<br>脏读：线程A读了线程B修改的内容（但是未提交），然后B再回撤。<br>不可重复读：必须提交了事务后才能被读取，线程A（执行多次查询）先读了内容，线程B再修改，线程A再读取发现内容变了。<br>幻读：线程A读取内容，只有2条记录，线程B插入内容，线程A再读，发现了4条内容。</p>\n<ol>\n<li>编程式事务<br>自己写代码，使用底层api自己完成事务。</li>\n<li>声明式事务<br>通过配置，让Spring辅助完成事务，可以解耦合，简化开发等。（底层还是编程式）</li>\n</ol>\n<h2 id=\"编程式事务\"><a href=\"#编程式事务\" class=\"headerlink\" title=\"编程式事务\"></a>编程式事务</h2><ol>\n<li>PlatformTransactionManager接口<br>定义实现<br><img src=\"/2021/04/15/Spring/PlatformTransactionManager.png\"></li>\n<li>TransactionDefinition<br>封装事务参数<br>事务隔离级别：<br>1）ISOLATION_DEFAULT<br>2）ISOLATION_READ_UNCOMMITED<br>3）ISOLATION_READ_COMMITED<br>4）ISOLATION_REPEATABLE_READ<br>5）ISOLATION_SERIALIZABLE<br>事务传播行为：<br><img src=\"/2021/04/15/Spring/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA.png\"></li>\n</ol>\n<div class=\"note info\">\n            <ol><li>Required：如果没有事务，新建一个事务；如果有事务，就加入进来；<br>看为同一个事务 → 一荣俱荣，一损俱损 → 要么一起提交了，要么一起回滚</li><li>Requires_new:如果没有，新建一个事务；如果有，就当做是一个新的事务。<br>methodB调用了methodA，<br>1）methodB发生异常：B回滚，A不回滚<br>2）methodA发生异常：A回滚，B也回滚</li><li>nested：嵌套事务 → 集体和个人关系 → 个人如果不在了，没有影响；集体不在了，人也没了<br>methodB调用methodA<br>1）methodB发生异常：AB都回滚<br>2）methodA发生异常：A回滚，外围B不回滚</li></ol>\n          </div>\n<ol start=\"3\">\n<li>TransactionStatus<br><img src=\"/2021/04/15/Spring/TransactionStatus.png\"></li>\n</ol>\n<h2 id=\"声明式事务\"><a href=\"#声明式事务\" class=\"headerlink\" title=\"声明式事务\"></a>声明式事务</h2><p>采用声明式事务来处理事务。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>不侵入代码组件，业务逻辑不会意识正在事务之中。因为事务管理属于系统层面的服务。</li>\n<li>不需要事务的时候，只用在配置文件中去掉即可，简便开发。</li>\n</ol>\n<div class=\"note info\">\n            <p>Spring声明式事务底层就是AOP实现</p>\n          </div>\n\n<h4 id=\"tx-advice-详解\"><a href=\"#tx-advice-详解\" class=\"headerlink\" title=\"tx:advice 详解\"></a>tx:advice 详解</h4><p>isolation<br>propagation<br>timeout<br>read-only</p>\n<h3 id=\"基于XML-1\"><a href=\"#基于XML-1\" class=\"headerlink\" title=\"基于XML\"></a>基于XML</h3><ol>\n<li>导入spring-tx已经aspectJ包</li>\n<li>applicationContext中配置事务属性（需要tx的命名空间）</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/spring-tx%E9%85%8D%E7%BD%AE.png\"></p>\n<h3 id=\"基于注解-1\"><a href=\"#基于注解-1\" class=\"headerlink\" title=\"基于注解\"></a>基于注解</h3><ol>\n<li>导入spring-tx已经aspectJ包</li>\n<li>xml中配置平台管理器TransactionManager，以及配置事件注解驱动。</li>\n<li>配置组件注解</li>\n</ol>\n<p><img src=\"/2021/04/15/Spring/%E4%BA%8B%E4%BB%B6%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8.png\"><br><img src=\"/2021/04/15/Spring/Transactional%E6%B3%A8%E8%A7%A3.png\"></p>\n<h4 id=\"一些细节\"><a href=\"#一些细节\" class=\"headerlink\" title=\"一些细节\"></a>一些细节</h4><p><img src=\"/2021/04/15/Spring/%E6%B3%A8%E8%A7%A3%E4%BA%8B%E5%8A%A1%E7%BB%86%E8%8A%82.png\"></p>\n<h1 id=\"JavaConfig\"><a href=\"#JavaConfig\" class=\"headerlink\" title=\"JavaConfig\"></a>JavaConfig</h1><p>使用java类来替代Spring类</p>\n<h2 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h2><p><img src=\"/2021/04/15/Spring/%E9%85%8D%E7%BD%AE%E7%B1%BB.png\"></p>\n<h2 id=\"注册组件\"><a href=\"#注册组件\" class=\"headerlink\" title=\"注册组件\"></a>注册组件</h2><ol>\n<li>@Bean注解<br><img src=\"/2021/04/15/Spring/@Bean.png\"></li>\n<li>扫描包<br><img src=\"/2021/04/15/Spring/%E6%89%AB%E6%8F%8F%E5%8C%85.png\"></li>\n</ol>\n<h2 id=\"引入Property\"><a href=\"#引入Property\" class=\"headerlink\" title=\"引入Property\"></a>引入Property</h2><p><img src=\"/2021/04/15/Spring/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png\"></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"aspectj\"><a href=\"#aspectj\" class=\"headerlink\" title=\"aspectj\"></a>aspectj</h3><p><img src=\"/2021/04/15/Spring/EnableAspectJAutoProxy.png\"></p>\n<h3 id=\"事务驱动\"><a href=\"#事务驱动\" class=\"headerlink\" title=\"事务驱动\"></a>事务驱动</h3><p><img src=\"/2021/04/15/Spring/EnableTransactionManagement.png\"></p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p><img src=\"/2021/04/15/Spring/ContextConfiuration.png\"></p>\n<h1 id=\"Spring项目环境搭建\"><a href=\"#Spring项目环境搭建\" class=\"headerlink\" title=\"Spring项目环境搭建\"></a>Spring项目环境搭建</h1>","categories":["框架"],"tags":["Spring","Java"]},{"title":"SpringBoot","url":"/2020/08/31/SpringBoot/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"搭建一个SpringBoot应用\"><a href=\"#搭建一个SpringBoot应用\" class=\"headerlink\" title=\"搭建一个SpringBoot应用\"></a>搭建一个SpringBoot应用</h1><h2 id=\"基础配置创建\"><a href=\"#基础配置创建\" class=\"headerlink\" title=\"基础配置创建\"></a>基础配置创建</h2><p>使用网页<a href=\"https://start.spring.io/\">https://start.spring.io/</a> 或者集成开发环境下提供的条件，进行创建。</p>\n<div class=\"note info\">\n            <p>约定大于配置：引入依赖时候，会自动导入默认配置</p>\n          </div>\n\n<h2 id=\"启动类\"><a href=\"#启动类\" class=\"headerlink\" title=\"启动类\"></a>启动类</h2><p>需要配置@SpringBootApplication<br>springboot应用的扫描包（@ComponentScan）范围 → 启动类所在的包目录）<br><img src=\"/2020/08/31/SpringBoot/%E5%90%AF%E5%8A%A8%E7%B1%BB.png\"><br><img src=\"/2020/08/31/SpringBoot/%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8C%85%E5%92%8C%E5%90%8D%E9%85%8D%E7%BD%AE.png\"></p>\n<div class=\"note info\">\n            <p>关于SpringBoot的打包，默认为Jar包，虽然多数云平台可以运行WAR包，但是所有的Java云平台都可以运行Jar包。并且SpringBoot内置了tomcat依赖。</p>\n          </div>\n\n<h2 id=\"SpringBoot中引入Web\"><a href=\"#SpringBoot中引入Web\" class=\"headerlink\" title=\"SpringBoot中引入Web\"></a>SpringBoot中引入Web</h2><p>导包即可<br><img src=\"/2020/08/31/SpringBoot/Web%E6%94%AF%E6%8C%81.png\"></p>\n<h2 id=\"父POM\"><a href=\"#父POM\" class=\"headerlink\" title=\"父POM\"></a>父POM</h2><p>以spring-boot-starter-parent作为其父POM，指定SpringBoot的版本和一些父类配置<br><img src=\"/2020/08/31/SpringBoot/Starter.png\"></p>\n<h2 id=\"starter依赖\"><a href=\"#starter依赖\" class=\"headerlink\" title=\"starter依赖\"></a>starter依赖</h2><p>SpringBoot中官方集成的xxx：spring-boot-starter-xxx<br>第三方适配的SpringBoot集成：xxx-spring-boot-starter</p>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>Spring Boot使用了一个全局的配置文件application.properties（或者application.yml）</p>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><p>修改启动端口号：使用context-path<br><img src=\"/2020/08/31/SpringBoot/%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3%E5%8F%B7.png\"></p>\n<h3 id=\"yml配置格式\"><a href=\"#yml配置格式\" class=\"headerlink\" title=\"yml配置格式\"></a>yml配置格式</h3><p>1、遇到.要替换为冒号，然后换行缩进，使用空格来缩进（不要使用tab制表符）<br>2、缩进几个空格都行，同一级对齐就行了<br>3、等于号=要替换为冒号：加上一个空格<br><img src=\"/2020/08/31/SpringBoot/yml.png\"></p>\n<h4 id=\"使用yml里的配置\"><a href=\"#使用yml里的配置\" class=\"headerlink\" title=\"使用yml里的配置\"></a>使用yml里的配置</h4><p><img src=\"/2020/08/31/SpringBoot/%E4%BD%BF%E7%94%A8yml%E9%87%8C%E7%9A%84%E9%85%8D%E7%BD%AE.png\"></p>\n<h4 id=\"使用-ConfigurationProperties\"><a href=\"#使用-ConfigurationProperties\" class=\"headerlink\" title=\"使用@ConfigurationProperties\"></a>使用@ConfigurationProperties</h4><p>打通配置文件和组件之间的联系，大小写文字的对应使用-<br><img src=\"/2020/08/31/SpringBoot/ConfigurationProperties1.png\"><br><img src=\"/2020/08/31/SpringBoot/ConfigurationProperties2.png\"></p>\n<h4 id=\"启动自定义配置项的提示\"><a href=\"#启动自定义配置项的提示\" class=\"headerlink\" title=\"启动自定义配置项的提示\"></a>启动自定义配置项的提示</h4><p>就是将自己写的yml配置，在写前缀的时候会开启对应提示。<br><img src=\"/2020/08/31/SpringBoot/configurationProcessor.png\"></p>\n<h3 id=\"其他数据类型的配置\"><a href=\"#其他数据类型的配置\" class=\"headerlink\" title=\"其他数据类型的配置\"></a>其他数据类型的配置</h3><ol>\n<li>List</li>\n<li>Map</li>\n<li>POJO</li>\n</ol>\n<h4 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h4><p><img src=\"/2020/08/31/SpringBoot/properties-other.png\"></p>\n<h4 id=\"yml\"><a href=\"#yml\" class=\"headerlink\" title=\"yml\"></a>yml</h4><p><img src=\"/2020/08/31/SpringBoot/yml-other.png\"></p>\n<h3 id=\"多配置文件\"><a href=\"#多配置文件\" class=\"headerlink\" title=\"多配置文件\"></a>多配置文件</h3><p>用作开发、测试、部署等，区分不同环境，或者功能解耦，分流。<br>使用spring.profiles.active=xxx 来启动对应配置<br><img src=\"/2020/08/31/SpringBoot/%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png\"></p>\n<h4 id=\"使用yml表达多个配置文件\"><a href=\"#使用yml表达多个配置文件\" class=\"headerlink\" title=\"使用yml表达多个配置文件\"></a>使用yml表达多个配置文件</h4><p><img src=\"/2020/08/31/SpringBoot/%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6yml.png\"></p>\n<h3 id=\"引用配置文件已经存在的Key（常用）\"><a href=\"#引用配置文件已经存在的Key（常用）\" class=\"headerlink\" title=\"引用配置文件已经存在的Key（常用）\"></a>引用配置文件已经存在的Key（常用）</h3><p><img src=\"/2020/08/31/SpringBoot/%E5%BC%95%E7%94%A8key.png\"></p>\n<div class=\"note info\">\n            <p>${}作为特定值，在组件初始化的时候就完成赋值。</p>\n          </div>\n<p><img src=\"/2020/08/31/SpringBoot/%E7%89%B9%E5%AE%9A%E5%80%BC%E8%B5%8B%E5%80%BC1.png\"><br><img src=\"/2020/08/31/SpringBoot/%E7%89%B9%E5%AE%9A%E5%80%BC%E8%B5%8B%E5%80%BC2.png\"></p>\n<h3 id=\"引用外部配置文件（不常用）\"><a href=\"#引用外部配置文件（不常用）\" class=\"headerlink\" title=\"引用外部配置文件（不常用）\"></a>引用外部配置文件（不常用）</h3><h4 id=\"引用外部的SpringBoot配置文件\"><a href=\"#引用外部的SpringBoot配置文件\" class=\"headerlink\" title=\"引用外部的SpringBoot配置文件\"></a>引用外部的SpringBoot配置文件</h4><p>使用@PropertySource(value=”xxx”)<br><img src=\"/2020/08/31/SpringBoot/%E5%BC%95%E7%94%A8SpringBoot%E9%85%8D%E7%BD%AE.png\"></p>\n<h4 id=\"引用外部的Spring配置文件\"><a href=\"#引用外部的Spring配置文件\" class=\"headerlink\" title=\"引用外部的Spring配置文件\"></a>引用外部的Spring配置文件</h4><p><img src=\"/2020/08/31/SpringBoot/%E5%BC%95%E7%94%A8Spring%E9%85%8D%E7%BD%AE.png\"></p>\n<div class=\"note info\">\n            <p>SpringBoot建议还是使用JavaConfig作为配置文件</p>\n          </div>\n\n<h3 id=\"配置文件的优先级\"><a href=\"#配置文件的优先级\" class=\"headerlink\" title=\"配置文件的优先级\"></a>配置文件的优先级</h3><h2 id=\"约定大于配置\"><a href=\"#约定大于配置\" class=\"headerlink\" title=\"约定大于配置\"></a>约定大于配置</h2><p>就是添加的默认组件，SpringBoot会提供自动配置类<br><img src=\"/2020/08/31/SpringBoot/%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE.png\"></p>\n<p>底层是 META-INF/spring.factories的文件</p>\n<h3 id=\"自动配置相关注解\"><a href=\"#自动配置相关注解\" class=\"headerlink\" title=\"自动配置相关注解\"></a>自动配置相关注解</h3><h4 id=\"ConditionalOnXXX\"><a href=\"#ConditionalOnXXX\" class=\"headerlink\" title=\"ConditionalOnXXX\"></a>ConditionalOnXXX</h4><p>当有XXX的时候，注册组件</p>\n<h4 id=\"ConditionalOnMissXXX\"><a href=\"#ConditionalOnMissXXX\" class=\"headerlink\" title=\"ConditionalOnMissXXX\"></a>ConditionalOnMissXXX</h4><p>当没有XXX的时候，注册组件</p>\n<p><img src=\"/2020/08/31/SpringBoot/@ConditionalOnProperty.png\"><br><img src=\"/2020/08/31/SpringBoot/@ConditionalOnMissingClass.png\"><br><img src=\"/2020/08/31/SpringBoot/@ConditionalOnClass.png\"><br><img src=\"/2020/08/31/SpringBoot/@ConditionalOnMissingBean.png\"><br>等等等，还有很多对应的，根据需要使用</p>\n<h4 id=\"自动配置的过程\"><a href=\"#自动配置的过程\" class=\"headerlink\" title=\"自动配置的过程\"></a>自动配置的过程</h4><p>@SpringBootApplication → @EnableAutoConfiguration → Selector选择器 → META-INF/spring.factories(jar) → 配置文件List = 自动配置类的list  → 通过自动配置类 → 组件注册 → @ConditionalOn 和@ConditionalOnMissing → 配置类是否生效、组件是否注册 （springboot已经写了组件注册的代码，设定了些条件决定是否生效）</p>\n<h2 id=\"引入WebMVC\"><a href=\"#引入WebMVC\" class=\"headerlink\" title=\"引入WebMVC\"></a>引入WebMVC</h2><p>引入spring-boot-starter-web</p>\n<h3 id=\"静态资源映射\"><a href=\"#静态资源映射\" class=\"headerlink\" title=\"静态资源映射\"></a>静态资源映射</h3><ol>\n<li>默认映射配置<br>在spring-configuration-metadata.json包含了默认配置<br><img src=\"/2020/08/31/SpringBoot/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90-%E9%BB%98%E8%AE%A4.png\"></li>\n<li>自定义配置<br>使用yml自定义映射<br><img src=\"/2020/08/31/SpringBoot/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90-%E8%87%AA%E5%AE%9A%E4%B9%89.png\"></li>\n</ol>\n<div class=\"note info\">\n            <ol><li><p>不要放到static路径下，因为最终要打成jar包或者war包，新环境部署后，对应环境不一定有resources/static</p></li><li><p>transferTo方法中传递的file如果是路径的话，那么它会将最后一层路径当做文件名，没有后缀的那种</p></li><li><p>做location和url的mapping映射</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;** 所有文件夹及其子文件夹</span><br><span class=\"line\">&#x2F;* 是有文件夹</span><br></pre></td></tr></table></figure></li></ol>\n          </div>\n\n<h3 id=\"MVC相关配置\"><a href=\"#MVC相关配置\" class=\"headerlink\" title=\"MVC相关配置\"></a>MVC相关配置</h3><h4 id=\"在yml配置文件中，使用spring-mvc-xxx找对应的\"><a href=\"#在yml配置文件中，使用spring-mvc-xxx找对应的\" class=\"headerlink\" title=\"在yml配置文件中，使用spring.mvc.xxx找对应的\"></a>在yml配置文件中，使用spring.mvc.xxx找对应的</h4><h4 id=\"使用JavaConfig来配置相关MVC配置\"><a href=\"#使用JavaConfig来配置相关MVC配置\" class=\"headerlink\" title=\"使用JavaConfig来配置相关MVC配置\"></a>使用JavaConfig来配置相关MVC配置</h4><p>写一个配置类实现WebMvcConfigurer，然后重写方法，比如下方配置静态资源映射和拦截器<br><img src=\"/2020/08/31/SpringBoot/%E9%85%8D%E7%BD%AEMVC%E9%85%8D%E7%BD%AE-JavaConfig.png\"></p>\n<div class=\"note info\">\n            <p>使用@EnableWebMvc后，会使用JavaConfig全面接管Spring-WebMVC的自动l配置失效。</p>\n          </div>\n\n<h3 id=\"Converter配置\"><a href=\"#Converter配置\" class=\"headerlink\" title=\"Converter配置\"></a>Converter配置</h3><p>在SpringBoot中，只需要注册为组件<br><img src=\"/2020/08/31/SpringBoot/Converter.png\"></p>\n<h2 id=\"注册Servlet、Filter、Listener（了解）\"><a href=\"#注册Servlet、Filter、Listener（了解）\" class=\"headerlink\" title=\"注册Servlet、Filter、Listener（了解）\"></a>注册Servlet、Filter、Listener（了解）</h2><h3 id=\"配置Servlet\"><a href=\"#配置Servlet\" class=\"headerlink\" title=\"配置Servlet\"></a>配置Servlet</h3><h3 id=\"配置Filter\"><a href=\"#配置Filter\" class=\"headerlink\" title=\"配置Filter\"></a>配置Filter</h3><h3 id=\"配置Listener\"><a href=\"#配置Listener\" class=\"headerlink\" title=\"配置Listener\"></a>配置Listener</h3><div class=\"note info\">\n            <p>Spring2.0之后，Filter、Listener不需要配置，只要@Component注册，即可生效。</p>\n          </div>\n<h2 id=\"模板引擎（了解）\"><a href=\"#模板引擎（了解）\" class=\"headerlink\" title=\"模板引擎（了解）\"></a>模板引擎（了解）</h2><h2 id=\"SpringBoot对Mybatis的支持\"><a href=\"#SpringBoot对Mybatis的支持\" class=\"headerlink\" title=\"SpringBoot对Mybatis的支持\"></a>SpringBoot对Mybatis的支持</h2><ol>\n<li>先导包</li>\n<li>然后在yml中进行配置</li>\n<li>启动类中使用@MapperScan(“全包名”)</li>\n</ol>\n<p><img src=\"/2020/08/31/SpringBoot/mybatis.png\"><br><img src=\"/2020/08/31/SpringBoot/mybatis2.png\"></p>\n<div class=\"note info\">\n            <p>因为Hikari的速度非常快，SpringBoot对Mybatis的默认源是Hikari。</p>\n          </div>\n\n<h3 id=\"修改数据源\"><a href=\"#修改数据源\" class=\"headerlink\" title=\"修改数据源\"></a>修改数据源</h3><p>yml中的datasource，配置type<br><img src=\"/2020/08/31/SpringBoot/%E4%BF%AE%E6%94%B9%E6%BA%90.png\"></p>\n<h3 id=\"mybatis配置\"><a href=\"#mybatis配置\" class=\"headerlink\" title=\"mybatis配置\"></a>mybatis配置</h3><p><img src=\"/2020/08/31/SpringBoot/mybatis%E9%85%8D%E7%BD%AE.png\"></p>\n<h2 id=\"Banner（彩蛋）\"><a href=\"#Banner（彩蛋）\" class=\"headerlink\" title=\"Banner（彩蛋）\"></a>Banner（彩蛋）</h2><h2 id=\"开启日志\"><a href=\"#开启日志\" class=\"headerlink\" title=\"开启日志\"></a>开启日志</h2><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">logging:</span></span><br><span class=\"line\">  <span class=\"attr\">level:</span></span><br><span class=\"line\">    <span class=\"attr\">com.cskaoyan.mapper:</span> <span class=\"string\">debug</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h1><p>复制别人项目，Plugin ‘org.springframework.boot:spring-boot-maven-plugin:’ not found<br>需要手动写版本号</p>\n<h1 id=\"Configuration和-Configurable\"><a href=\"#Configuration和-Configurable\" class=\"headerlink\" title=\"@Configuration和@Configurable\"></a>@Configuration和@Configurable</h1><p>@Configuration<br>该注解是可以用来替代XML文件。<br>以前我们配置bean时，都是写在applicationContext.xml文件中的。<br>有了这个注解后，我们就可以编写一个类在其上面加上该注解。即配置类。<br>在配置类中可以在方法上加@Bean注解定义其中的Bean</p>\n<p>@Configurable<br>现在假设，我们想在非Spring管理的类中使用依赖注入；<br>比如：手动new出来的对象，正常情况下，Spring是无法依赖注入的，这个时候可以使用@Configurable注解；</p>\n<h1 id=\"Mybatis支持\"><a href=\"#Mybatis支持\" class=\"headerlink\" title=\"Mybatis支持\"></a>Mybatis支持</h1><h2 id=\"导包\"><a href=\"#导包\" class=\"headerlink\" title=\"导包\"></a>导包</h2><h2 id=\"yml配置datasource\"><a href=\"#yml配置datasource\" class=\"headerlink\" title=\"yml配置datasource\"></a>yml配置datasource</h2><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.datasource.driver-class-name:</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"405-Method-not-allowed\"><a href=\"#405-Method-not-allowed\" class=\"headerlink\" title=\"405 Method not allowed\"></a>405 Method not allowed</h1><p>httppost请求目标网站会出现405 状态码，原因为 Apache、IIS、Nginx等绝大多数web服务器，都不允许静态文件响应POST请求</p>\n<p>所以将post请求改为get请求即可(或者使用重定向)</p>\n<h1 id=\"Spring-Boot-Starter-Web\"><a href=\"#Spring-Boot-Starter-Web\" class=\"headerlink\" title=\"Spring-Boot-Starter-Web\"></a>Spring-Boot-Starter-Web</h1><p>内置了tomcat和一些Web相关内容</p>\n<h2 id=\"HandlerInterceptorAdaptor\"><a href=\"#HandlerInterceptorAdaptor\" class=\"headerlink\" title=\"HandlerInterceptorAdaptor\"></a>HandlerInterceptorAdaptor</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerInterceptorAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">AsyncHandlerInterceptor</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HandlerInterceptorAdapter</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class=\"meta\">@Nullable</span> ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class=\"meta\">@Nullable</span> Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//有异步请求时，在preHandle返回true后，在该处执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterConcurrentHandlingStarted</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>写「实现类」继承HandlerInterceptorAdaptor，并注册为组件到Spring</p>\n</li>\n<li><p>写Spring-Web配置类添加「实现类」的拦截器</p>\n</li>\n</ol>\n<h1 id=\"向静态变量注入Bean\"><a href=\"#向静态变量注入Bean\" class=\"headerlink\" title=\"向静态变量注入Bean\"></a>向静态变量注入Bean</h1><h2 id=\"使用PostConstruct\"><a href=\"#使用PostConstruct\" class=\"headerlink\" title=\"使用PostConstruct\"></a>使用PostConstruct</h2><ol>\n<li>先将该类注册为组件<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br></pre></td></tr></table></figure></li>\n<li>定义静态变量<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Aservice aservice</span><br></pre></td></tr></table></figure></li>\n<li>自动注入一个非静态变量<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">Aservice aserviceObject;</span><br></pre></td></tr></table></figure></li>\n<li>使用PostConstruct，把非静态变量赋值给静态变量<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostConStruct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  aservice = aserviceObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h1 id=\"使用Properties文件的-Value注入静态变量\"><a href=\"#使用Properties文件的-Value注入静态变量\" class=\"headerlink\" title=\"使用Properties文件的@Value注入静态变量\"></a>使用Properties文件的@Value注入静态变量</h1><ol>\n<li>定义静态变量</li>\n<li>使用@Value注解<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value(value = &quot;$&#123;spring.profiles.text&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">  SystemConfig.config = text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h1 id=\"使用Mybatis配置多数据源\"><a href=\"#使用Mybatis配置多数据源\" class=\"headerlink\" title=\"使用Mybatis配置多数据源\"></a>使用Mybatis配置多数据源</h1><p>配置对象，要读取配置信息<br>比如GoodsConfig、ShoppingConfig</p>\n<h2 id=\"创建配置对象创建数据源\"><a href=\"#创建配置对象创建数据源\" class=\"headerlink\" title=\"创建配置对象创建数据源\"></a>创建配置对象创建数据源</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//读取配置信息</span></span><br><span class=\"line\"><span class=\"comment\">//并创建数据源</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.datasource.goods&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">goodsDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DataSourceBuilder.create().build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置数据源（Datasource）\"><a href=\"#配置数据源（Datasource）\" class=\"headerlink\" title=\"配置数据源（Datasource）\"></a>配置数据源（Datasource）</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根据数据源</span></span><br><span class=\"line\"><span class=\"comment\">//创建mybatis的SqlSessionFactory</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">sqlSessionFactory</span><span class=\"params\">(DataSource goodsDataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    SqlSessionFactoryBean sqlSessionFactoryBean = <span class=\"keyword\">new</span> SqlSessionFactoryBean();</span><br><span class=\"line\">    sqlSessionFactoryBean.setDataSource(goodsDataSource);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqlSessionFactoryBean.getObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置Mapper扫描\"><a href=\"#配置Mapper扫描\" class=\"headerlink\" title=\"配置Mapper扫描\"></a>配置Mapper扫描</h2><ol>\n<li><p>使用注解并配置SqlSessionTemplate</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MapperScan(basePackages = &quot;learn.myproject.springbootcore.multidatasource.dao&quot;,    sqlSessionTemplateRef = &quot;goodsSqlSessionTemplate&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">GoodsConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">goodsSqlSessionTemplate</span><span class=\"params\">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用扫描配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MapperScannerConfigurer <span class=\"title\">goodsMapperscannerConfigurer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    MapperScannerConfigurer mapperScannerConfigurer = <span class=\"keyword\">new</span> MapperScannerConfigurer();</span><br><span class=\"line\">    mapperScannerConfigurer.setSqlSessionFactoryBeanName(<span class=\"string\">&quot;sqlSessionTemplate&quot;</span>);</span><br><span class=\"line\">    mapperScannerConfigurer</span><br><span class=\"line\">        .setBasePackage(<span class=\"string\">&quot;learn.myproject.springbootcore.multidatasource.dao&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mapperScannerConfigurer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n","categories":["框架"],"tags":["Spring","SpringBoot"]},{"title":"SpringCache","url":"/2021/08/16/SpringCache/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>许多操作频繁的访问数据库，实际上对数据库压力大同时也会造成不必要的多余访问，因此可以将一些不常改变的值放入缓存中，读取缓存数据。<br>此次，将用户信息放入缓存，用作某些安全校验。</p>\n<h1 id=\"基础框架\"><a href=\"#基础框架\" class=\"headerlink\" title=\"基础框架\"></a>基础框架</h1><p>使用SpringCache + Redis实现</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><h1 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;x.x.x&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"开启缓存\"><a href=\"#开启缓存\" class=\"headerlink\" title=\"开启缓存\"></a>开启缓存</h2><p>使用注解@EnableCaching</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//SpringBoot主配置类开启</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserProviderApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSpringApplication.run(UserProviderApplication.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dao层配置缓存信息\"><a href=\"#Dao层配置缓存信息\" class=\"headerlink\" title=\"Dao层配置缓存信息\"></a>Dao层配置缓存信息</h2><p>在Service方法上使用注解@Cacheable(chachename =  “xxx”)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable(cacheNames = &quot;userInfo&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> QueryMemberResponse <span class=\"title\">queryMemberById</span><span class=\"params\">(QueryMemberRequest request)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["框架"],"tags":["Spring","缓存"]},{"title":"SpringCloud-GateWay","url":"/2022/01/30/SpringCloud-GateWay/","content":"<h1 id=\"Gateway\"><a href=\"#Gateway\" class=\"headerlink\" title=\"Gateway\"></a>Gateway</h1><p>官网：<a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-starter\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-starter</a><br>Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring/metrics, and resiliency.<br>网关是作为分发，安全控制、监测等，访问的第一道防线。</p>\n<p>采用的webflux技术，是非响应式编程</p>\n<h1 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h1><h2 id=\"Route-路由\"><a href=\"#Route-路由\" class=\"headerlink\" title=\"Route 路由\"></a>Route 路由</h2><p>路由：即将按照匹配规则(Predicate)的HTTP请求转发到对应的服务上</p>\n<h2 id=\"Predicate-匹配\"><a href=\"#Predicate-匹配\" class=\"headerlink\" title=\"Predicate 匹配\"></a>Predicate 匹配</h2><p>匹配：制定匹配策略，可以识别任何带有特定规则的HTTP请求。比如匹配某些Header，某些参数等等</p>\n<h2 id=\"Filter-过滤\"><a href=\"#Filter-过滤\" class=\"headerlink\" title=\"Filter 过滤\"></a>Filter 过滤</h2><p>过滤：制定过滤策略，选择哪些请求可以通过网关并被转发</p>\n<h1 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h1><p>Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a route, it is sent to the Gateway Web Handler. This handler runs the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line is that filters can run logic both before and after the proxy request is sent. All “pre” filter logic is executed. Then the proxy request is made. After the proxy request is made, the “post” filter logic is run.</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h1 id=\"SpringBoot整合SpringCloudGateway\"><a href=\"#SpringBoot整合SpringCloudGateway\" class=\"headerlink\" title=\"SpringBoot整合SpringCloudGateway\"></a>SpringBoot整合SpringCloudGateway</h1><h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>spring-cloud-starter-gateway</p>\n<div class=\"note info\">\n            <p>如果要搭配nacos，使用lb://，则还需要引入spring-cloud-starter-loadbalancer依赖</p>\n          </div>\n\n<h1 id=\"练手案例\"><a href=\"#练手案例\" class=\"headerlink\" title=\"练手案例\"></a>练手案例</h1><h2 id=\"整合JWT实现登陆校验\"><a href=\"#整合JWT实现登陆校验\" class=\"headerlink\" title=\"整合JWT实现登陆校验\"></a>整合JWT实现登陆校验</h2><ol>\n<li></li>\n</ol>\n","categories":["框架"],"tags":["Spring","微服务","SpringCloud"]},{"title":"SpringCloud-OpenFeign","url":"/2022/01/30/SpringCloud-OpenFeign/","content":"<h1 id=\"OpenFeign\"><a href=\"#OpenFeign\" class=\"headerlink\" title=\"OpenFeign\"></a>OpenFeign</h1><p>官网：<a href=\"https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#netflix-feign-starter\">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#netflix-feign-starter</a><br>Feign is a declarative web service client. It makes writing web service clients easier.<br>Feign是一个声明式的Web客户端，使用它可以更轻松的编写网页服务请求。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>spring-cloud-starter-openfeign</p>\n<h2 id=\"写接口并配置FeignClient\"><a href=\"#写接口并配置FeignClient\" class=\"headerlink\" title=\"写接口并配置FeignClient\"></a>写接口并配置FeignClient</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FeignClient(&quot;xxxService&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">xxxService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;xxx/xxx/xxx&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置类或启动类上配置启用Feign\"><a href=\"#配置类或启动类上配置启用Feign\" class=\"headerlink\" title=\"配置类或启动类上配置启用Feign\"></a>配置类或启动类上配置启用Feign</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableFeignClients(basePackages = &quot;learn.myproject.xxx.feign&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderProviderApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(OrderProviderApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["框架"],"tags":["Spring","微服务","SpringCloud"]},{"title":"SpringCloud","url":"/2021/11/19/SpringCloud/","content":"<h1 id=\"微服务概念\"><a href=\"#微服务概念\" class=\"headerlink\" title=\"微服务概念\"></a>微服务概念</h1><h2 id=\"微服务架构分类\"><a href=\"#微服务架构分类\" class=\"headerlink\" title=\"微服务架构分类\"></a>微服务架构分类</h2><ol>\n<li>dubbo</li>\n<li>SpringCloud</li>\n<li>SpringCloudAlibaba</li>\n</ol>\n<h2 id=\"服务拆分和远程调用\"><a href=\"#服务拆分和远程调用\" class=\"headerlink\" title=\"服务拆分和远程调用\"></a>服务拆分和远程调用</h2><ol>\n<li>不同微服务，不开发相同业务</li>\n<li>微服务相对独立，不要访问其他微服务数据库</li>\n<li>微服务将自己的业务暴露，供其他服务调用</li>\n</ol>\n<h1 id=\"SpringCloud\"><a href=\"#SpringCloud\" class=\"headerlink\" title=\"SpringCloud\"></a>SpringCloud</h1><h2 id=\"微服务远程调用\"><a href=\"#微服务远程调用\" class=\"headerlink\" title=\"微服务远程调用\"></a>微服务远程调用</h2><h2 id=\"RestTemplate\"><a href=\"#RestTemplate\" class=\"headerlink\" title=\"RestTemplate\"></a>RestTemplate</h2><p>使用RestTemplate对象，发送http请求到对应微服务，然后获取数据。 </p>\n<h2 id=\"提供者\"><a href=\"#提供者\" class=\"headerlink\" title=\"提供者\"></a>提供者</h2><p>暴露接口给其他微服务调用的</p>\n<h2 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h2><p>调用其他接口的微服务<br>两者之间关系是相对的</p>\n<h2 id=\"Eureka\"><a href=\"#Eureka\" class=\"headerlink\" title=\"Eureka\"></a>Eureka</h2><p>向消费者提供服务提供者的具体信息，有负载均衡，感知提供者状态。</p>\n<h2 id=\"Eureka注册中心\"><a href=\"#Eureka注册中心\" class=\"headerlink\" title=\"Eureka注册中心\"></a>Eureka注册中心</h2><h2 id=\"Eureka客户\"><a href=\"#Eureka客户\" class=\"headerlink\" title=\"Eureka客户\"></a>Eureka客户</h2><h2 id=\"SpringBoot配置Eureka\"><a href=\"#SpringBoot配置Eureka\" class=\"headerlink\" title=\"SpringBoot配置Eureka\"></a>SpringBoot配置Eureka</h2><ol>\n<li>导包（服务导server，客户端导client）<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>启动eureka配置<br>在BootStarter上增加注解<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@EnableEurekaServer</span><br></pre></td></tr></table></figure></li>\n<li>配置yml<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8888</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">eureka-server</span> <span class=\"comment\">#eureka服务名称</span></span><br><span class=\"line\"><span class=\"attr\">eureka:</span></span><br><span class=\"line\">  <span class=\"attr\">client:</span></span><br><span class=\"line\">    <span class=\"attr\">service-url:</span> <span class=\"comment\">#eureka地址信息</span></span><br><span class=\"line\">      <span class=\"attr\">defaultZone:</span> <span class=\"string\">http://127.0.0.1:8888/erueka</span> <span class=\"comment\">#默认服务地址</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"Eureka服务注册\"><a href=\"#Eureka服务注册\" class=\"headerlink\" title=\"Eureka服务注册\"></a>Eureka服务注册</h2><ol>\n<li>导包</li>\n<li>配置yml<br>1）成为注册中心<br>2）服务注册到注册中心</li>\n</ol>\n<h2 id=\"Eureka服务拉取\"><a href=\"#Eureka服务拉取\" class=\"headerlink\" title=\"Eureka服务拉取\"></a>Eureka服务拉取</h2><h2 id=\"Eureka负载均衡\"><a href=\"#Eureka负载均衡\" class=\"headerlink\" title=\"Eureka负载均衡\"></a>Eureka负载均衡</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@LoadBanlanced</span><br></pre></td></tr></table></figure>\n<h2 id=\"Eureka集群\"><a href=\"#Eureka集群\" class=\"headerlink\" title=\"Eureka集群\"></a>Eureka集群</h2><ol>\n<li>创建多个Eureka各为注册中心，不同端口，互相注册到其他的注册中心</li>\n<li>其他服务注册到各个Eureka的注册中心</li>\n</ol>\n<h2 id=\"ribbon负载均衡（已过时）\"><a href=\"#ribbon负载均衡（已过时）\" class=\"headerlink\" title=\"ribbon负载均衡（已过时）\"></a>ribbon负载均衡（已过时）</h2><h3 id=\"ribbon自定义负载均衡\"><a href=\"#ribbon自定义负载均衡\" class=\"headerlink\" title=\"ribbon自定义负载均衡\"></a>ribbon自定义负载均衡</h3><ol>\n<li>自定义Rule（全局）</li>\n<li>配置文件，指定微服务策略<h3 id=\"ribbon饥饿加载\"><a href=\"#ribbon饥饿加载\" class=\"headerlink\" title=\"ribbon饥饿加载\"></a>ribbon饥饿加载</h3>刚开始运行eureka不会加载实例，第一次访问时才会加载（懒加载）<br>饥饿加载：刚运行时，将实例一并加载。<br>在yml里面配置。</li>\n</ol>\n<h2 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h2><p>比eureka功能丰富，alibaba下面，国内受欢迎高<br>通用ribbon负载均衡</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装服务，并启用</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ol>\n<li><p>导包<br>项目父工程导入管理依赖（负责管理nacos所有依赖的版本）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring-cloud-alibaba-dependencies</span><br></pre></td></tr></table></figure>\n<p>子工程导客户端依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring-cloud-starter-alibaba-nacos-discovery</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置nacos地址：server-addr</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">xxxService</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">server-addr:</span> <span class=\"string\">localhost:8848</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动服务，则会自动注册导nacos</p>\n</li>\n</ol>\n<h2 id=\"Nacos集群\"><a href=\"#Nacos集群\" class=\"headerlink\" title=\"Nacos集群\"></a>Nacos集群</h2><h3 id=\"分级存储模型\"><a href=\"#分级存储模型\" class=\"headerlink\" title=\"分级存储模型\"></a>分级存储模型</h3><ol>\n<li>服务集群</li>\n<li>服务实例</li>\n</ol>\n<h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>yml文件，xxx就是一个区域的名字，该服务就注册在这个区域内</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.cloud.nacos.discovery.cluster-name:</span> <span class=\"string\">xxx</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"跨集群调用\"><a href=\"#跨集群调用\" class=\"headerlink\" title=\"跨集群调用\"></a>跨集群调用</h3><h2 id=\"NacosRule\"><a href=\"#NacosRule\" class=\"headerlink\" title=\"NacosRule\"></a>NacosRule</h2><p>yml里面配置NacosRule</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">xxx....ribbon.NacosRule</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>优先选择本地服务，本地服务停掉后才会跨集群调用</li>\n<li>可以配置权重访问的（0.1-1之间）按照权重比值分配<br>权重可以配置为0，表示不会访问，可以用来做服务升级（用户不感知）</li>\n</ol>\n<h2 id=\"环境隔离Namespace\"><a href=\"#环境隔离Namespace\" class=\"headerlink\" title=\"环境隔离Namespace\"></a>环境隔离Namespace</h2><p>不同的namespace不能访问。</p>\n<ol>\n<li>新建命名空间</li>\n<li>在服务的yml里配置对应namespace的id</li>\n</ol>\n<h2 id=\"Nacos和Eureka区别\"><a href=\"#Nacos和Eureka区别\" class=\"headerlink\" title=\"Nacos和Eureka区别\"></a>Nacos和Eureka区别</h2><ol>\n<li>Nacos临时实例和永久实例</li>\n<li>Nacos有主动推送（如果有实例挂掉，会进行通知）</li>\n<li>都有定时主动pull</li>\n<li>都有心跳检测</li>\n</ol>\n<h3 id=\"临时实例\"><a href=\"#临时实例\" class=\"headerlink\" title=\"临时实例\"></a>临时实例</h3><p>ephemeral：true为临时，false为永久<br>Nacos默认集群模式AP，存在非临时实例则为CP模式</p>\n<h2 id=\"Nacos配置管理\"><a href=\"#Nacos配置管理\" class=\"headerlink\" title=\"Nacos配置管理\"></a>Nacos配置管理</h2><p>可以实现</p>\n<ol>\n<li>配置更改热更新</li>\n<li>多环境配置共享<h3 id=\"统一配置管理\"><a href=\"#统一配置管理\" class=\"headerlink\" title=\"统一配置管理\"></a>统一配置管理</h3></li>\n<li>在nacos中添加配置文件</li>\n<li>在微服务中引用nacos的Config依赖</li>\n<li>创建bootstrap.yml，配置nacos地址</li>\n<li>启动服务时，服务会先从nacos读取配置文件，然后加载配置，运行该实例</li>\n</ol>\n<h3 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h3><ol>\n<li>在@Value注入的变量所在的类上，配置@RefreshScope</li>\n<li>专门一个配置类上，@ConfigureationProperties</li>\n</ol>\n<h3 id=\"多环境配置共享\"><a href=\"#多环境配置共享\" class=\"headerlink\" title=\"多环境配置共享\"></a>多环境配置共享</h3><p>在nacos里创建 xxxService.yml 里面配置该服务共享的配置<br>相同配置的优先级：xxxService-xxx.yml &gt; xxxService.yml &gt; 本地配置</p>\n<h2 id=\"Feign\"><a href=\"#Feign\" class=\"headerlink\" title=\"Feign\"></a>Feign</h2><p>Feign是使用Http协议的</p>\n<h2 id=\"定义和使用Feign客户端\"><a href=\"#定义和使用Feign客户端\" class=\"headerlink\" title=\"定义和使用Feign客户端\"></a>定义和使用Feign客户端</h2><h3 id=\"导包\"><a href=\"#导包\" class=\"headerlink\" title=\"导包\"></a>导包</h3><h3 id=\"服务类上加-EnableFeignClients\"><a href=\"#服务类上加-EnableFeignClients\" class=\"headerlink\" title=\"服务类上加@EnableFeignClients\"></a>服务类上加@EnableFeignClients</h3><h3 id=\"编写Feign接口\"><a href=\"#编写Feign接口\" class=\"headerlink\" title=\"编写Feign接口\"></a>编写Feign接口</h3><p>使用注解<code>@FeignClient(&quot;xxxService&quot;)</code>，然后编写方法，并用SpringMVC注解标明请求URL。</p>\n<div class=\"note info\">\n            <p>Feign本身自带负载均衡包依赖。</p>\n          </div>\n\n\n<h2 id=\"自定义Feign配置\"><a href=\"#自定义Feign配置\" class=\"headerlink\" title=\"自定义Feign配置\"></a>自定义Feign配置</h2><ol>\n<li>日志</li>\n<li>解码</li>\n<li>编码</li>\n</ol>\n<h3 id=\"基于配置文件\"><a href=\"#基于配置文件\" class=\"headerlink\" title=\"基于配置文件\"></a>基于配置文件</h3><p>日志：</p>\n<ol>\n<li>default：全局</li>\n<li>xxxService：指定服务</li>\n</ol>\n<h3 id=\"基于配置类\"><a href=\"#基于配置类\" class=\"headerlink\" title=\"基于配置类\"></a>基于配置类</h3><ol>\n<li>写一个配置类</li>\n<li>配置一个Logger.level的Bean<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FeignConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Logger.<span class=\"function\">level <span class=\"title\">feignLogLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Logger.level.BASIC;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在对应需要调用服务的类上进行全局/指定配置</li>\n<li><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableFeignClients(defaultConfiguration = FeignConfig.class)</span></span><br></pre></td></tr></table></figure></li>\n<li><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FeignClient(value = &quot;xxxService&quot;, configuration = FeignConfig.class)</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"Feign调优\"><a href=\"#Feign调优\" class=\"headerlink\" title=\"Feign调优\"></a>Feign调优</h2><p>Feign底层：</p>\n<ol>\n<li>URLConnection：不支持连接池</li>\n<li>Apache HttpClient：</li>\n<li>OKHttp</li>\n</ol>\n<p>具体的连接数和路由数要通过压力测试来进行</p>\n<h3 id=\"使用连接池替换URLConnection\"><a href=\"#使用连接池替换URLConnection\" class=\"headerlink\" title=\"使用连接池替换URLConnection\"></a>使用连接池替换URLConnection</h3><ol>\n<li>导包<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">feign-httpclient</span><br></pre></td></tr></table></figure></li>\n<li>配置文件进行配置<br>feign.httpclient.enable<br>feign.httpclient.max-connections<br>feign.httpclient.max-connections-per-route<h3 id=\"日志除了debug时候用full，其他时尽可能用BASIC或者NULL\"><a href=\"#日志除了debug时候用full，其他时尽可能用BASIC或者NULL\" class=\"headerlink\" title=\"日志除了debug时候用full，其他时尽可能用BASIC或者NULL\"></a>日志除了debug时候用full，其他时尽可能用BASIC或者NULL</h3></li>\n</ol>\n<h2 id=\"feign的目前最佳实践\"><a href=\"#feign的目前最佳实践\" class=\"headerlink\" title=\"feign的目前最佳实践\"></a>feign的目前最佳实践</h2><h3 id=\"继承（不推荐，因为紧耦合）\"><a href=\"#继承（不推荐，因为紧耦合）\" class=\"headerlink\" title=\"继承（不推荐，因为紧耦合）\"></a>继承（不推荐，因为紧耦合）</h3><p>给消费者的feign的FeignClient和提供者的Controller定义统一的父接口作为标准。</p>\n<h3 id=\"独立模块\"><a href=\"#独立模块\" class=\"headerlink\" title=\"独立模块\"></a>独立模块</h3><p>将Feign抽取为独立模块，接口相关的POJO、默认的Feign配置放到这个模块，提供给消费者使用（引入该模块依赖）。</p>\n<div class=\"note info\">\n            <p>当FeignClient不在SpringBootApplication的扫描包时，解决办法：</p><ol><li><p>指定FeignClient所在包<br> @EnableFeignClients(basePackages = “xxx.xxx.xxx”</p></li><li><p>指定FeignClient的字节码<br> @EnableFeignClients(clients = {UserClient.class})</p></li></ol>\n          </div>\n\n\n<h2 id=\"SpringCloud-LoadBalancer\"><a href=\"#SpringCloud-LoadBalancer\" class=\"headerlink\" title=\"SpringCloud LoadBalancer\"></a>SpringCloud LoadBalancer</h2><ol>\n<li>RoundRobin（默认）</li>\n<li>Random</li>\n</ol>\n<h3 id=\"自定义负载均衡\"><a href=\"#自定义负载均衡\" class=\"headerlink\" title=\"自定义负载均衡\"></a>自定义负载均衡</h3><p>配置一个Config的Bean，返回特定需要的负载实例即可</p>\n<h3 id=\"LoadBalancer-OpenFeign\"><a href=\"#LoadBalancer-OpenFeign\" class=\"headerlink\" title=\"LoadBalancer + OpenFeign\"></a>LoadBalancer + OpenFeign</h3><h2 id=\"Gateway\"><a href=\"#Gateway\" class=\"headerlink\" title=\"Gateway\"></a>Gateway</h2><ol>\n<li>身份认证和权限校验</li>\n<li>服务路由、负载均衡</li>\n<li>请求限流</li>\n</ol>\n<p>SpringCloud网关的两个实现：</p>\n<ol>\n<li>Zuul：基于Servlet的阻塞式编程。（过时）</li>\n<li>Gateway：基于Spring5的WebFlux，响应式编程实现，具有更好的性能。</li>\n</ol>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>导包<br>spring-cloud的gateway和nacos-discovery<br>做服务发现<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;gateway.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;nacos-discovery.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>配置nacos服务地址和路由选择<br>核心配置：<br>1）路由id<br>2）路由url<br>3）路由断言<br>4）过滤器<br><img src=\"/2021/11/19/SpringCloud/%E9%85%8D%E7%BD%AEnacos.png\"></li>\n</ol>\n<h3 id=\"路由断言和路由断言工厂\"><a href=\"#路由断言和路由断言工厂\" class=\"headerlink\" title=\"路由断言和路由断言工厂\"></a>路由断言和路由断言工厂</h3><p>PathRoutePredicateFactory<br>Sprig提供了11种Predicate工厂</p>\n<h3 id=\"路由过滤器\"><a href=\"#路由过滤器\" class=\"headerlink\" title=\"路由过滤器\"></a>路由过滤器</h3><p>Spring提供了31种过滤工厂，配置按照（key, word）形式</p>\n<h4 id=\"DefaultFilter\"><a href=\"#DefaultFilter\" class=\"headerlink\" title=\"DefaultFilter\"></a>DefaultFilter</h4><p>默认过滤器</p>\n<h4 id=\"GlobalFilter\"><a href=\"#GlobalFilter\" class=\"headerlink\" title=\"GlobalFilter\"></a>GlobalFilter</h4><p>全局过滤器<br>gateway的default-filters是根据配置来进行过滤的，过滤操作是固定的。<br>而如果想自定义根据一定逻辑条件进行过滤，可以用global-filters（需要自己手写类实现GlobalFilter接口，通过代码实现）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Order(int value)</span> </span><br><span class=\"line\"><span class=\"comment\">//执行顺序优先级</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"过滤器执行顺序\"><a href=\"#过滤器执行顺序\" class=\"headerlink\" title=\"过滤器执行顺序\"></a>过滤器执行顺序</h4><p>DefaultFilter -&gt; 当前的路由Filter -&gt; GlobalFilter<br>并且按照order的值进行排序（值越小，优先级越高）<br>配置文件的按照配置顺序，order值从1开始，往后并且递增。</p>\n<p>也可以自定义Order值（过滤器实现Order类），设定过滤器顺序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"跨域处理\"><a href=\"#跨域处理\" class=\"headerlink\" title=\"跨域处理\"></a>跨域处理</h3><p>网关可以配置CORS跨域</p>\n<h2 id=\"SpringCloudConfig\"><a href=\"#SpringCloudConfig\" class=\"headerlink\" title=\"SpringCloudConfig\"></a>SpringCloudConfig</h2><p>使用云端配置服务中心，直接从配置中心调取对应的服务配置</p>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><ol>\n<li><p>依赖</p>\n</li>\n<li><p>开启服务</p>\n</li>\n<li><p>注册到注册中心</p>\n</li>\n<li><p>创建仓库<br>github或者本地仓库<br>里面写配置文件</p>\n</li>\n<li><p>读取配置<br>在配置读取里面有不同</p>\n</li>\n<li><p>github</p>\n</li>\n<li><p>本地</p>\n</li>\n</ol>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><ol>\n<li>依赖</li>\n</ol>\n","categories":["框架"],"tags":["Spring","微服务","SpringCloud"]},{"title":"Spring跨域处理","url":"/2021/08/07/Spring%E8%B7%A8%E5%9F%9F/","content":"<p>转载于： <a href=\"https://zhuanlan.zhihu.com/p/147652844\">https://zhuanlan.zhihu.com/p/147652844</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Springboot跨域问题，是当前主流web开发人员都绕不开的难题。但我们首先要明确以下几点</p>\n<p>跨域只存在于浏览器端，不存在于安卓/ios/Node.js/python/ java等其它环境</p>\n<p>跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</p>\n<p>之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</p>\n<p>浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。换句话说，浏览器安全的基石是同源策略。</p>\n<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><p>一、什么是CORS？</p>\n<p>CORS Header</p>\n<p>二、SpringBoot跨域请求处理方式</p>\n<p>方法一、直接采用SpringBoot的注解@CrossOrigin（也支持SpringMVC）</p>\n<p>方法二、处理跨域请求的Configuration</p>\n<p>方法三、采用过滤器（filter）的方式</p>\n<p>三、总结</p>\n<p>一、什么是CORS？</p>\n<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>\n<p>它通过服务器增加一个特殊的Header[Access-Control-Allow-Origin]来告诉客户端跨域的限制，如果浏览器支持CORS、并且判断Origin通过的话，就会允许XMLHttpRequest发起跨域请求。</p>\n<p>CORS Header</p>\n<p>Access-Control-Allow-Origin: <a href=\"http://www.xxx.com/\">http://www.xxx.com</a></p>\n<p>Access-Control-Max-Age：86400</p>\n<p>Access-Control-Allow-Methods：GET, POST, OPTIONS, PUT, DELETE</p>\n<p>Access-Control-Allow-Headers: content-type</p>\n<p>Access-Control-Allow-Credentials: true</p>\n<p>含义解释：<br><img src=\"/2021/08/07/Spring%E8%B7%A8%E5%9F%9F/%E5%90%AB%E4%B9%89%E8%A7%A3%E9%87%8A.jpg\"></p>\n<h1 id=\"SpringBoot跨域请求处理方式\"><a href=\"#SpringBoot跨域请求处理方式\" class=\"headerlink\" title=\"SpringBoot跨域请求处理方式\"></a>SpringBoot跨域请求处理方式</h1><h2 id=\"方法一-直接采用SpringBoot的注解-CrossOrigin（也支持SpringMVC）\"><a href=\"#方法一-直接采用SpringBoot的注解-CrossOrigin（也支持SpringMVC）\" class=\"headerlink\" title=\"方法一  直接采用SpringBoot的注解@CrossOrigin（也支持SpringMVC）\"></a>方法一  直接采用SpringBoot的注解@CrossOrigin（也支持SpringMVC）</h2><p>简单粗暴的方式，Controller层在需要跨域的类或者方法上加上该注解即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Created with IDEA</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @Author Chensj</span><br><span class=\"line\"> * @Date 2020&#x2F;5&#x2F;8 10:28</span><br><span class=\"line\"> * @Description xxxx控制层</span><br><span class=\"line\"> * @Version 1.0</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">@CrossOrigin</span><br><span class=\"line\">@RequestMapping(&quot;&#x2F;situation&quot;)</span><br><span class=\"line\">public class SituationController extends PublicUtilController &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private SituationService situationService;</span><br><span class=\"line\">    &#x2F;&#x2F; log日志信息</span><br><span class=\"line\">    private static Logger LOGGER &#x3D; Logger.getLogger(SituationController.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但每个Controller都得加，太麻烦了，怎么办呢，加在Controller公共父类（PublicUtilController）中，所有Controller继承即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Created with IDEA</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @Author Chensj</span><br><span class=\"line\"> * @Date 2020&#x2F;5&#x2F;6 10:01</span><br><span class=\"line\"> * @Description</span><br><span class=\"line\"> * @Version 1.0</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@CrossOrigin</span><br><span class=\"line\">public class PublicUtilController &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 公共分页参数整理接口</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param currentPage</span><br><span class=\"line\">     * @param pageSize</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    public PageInfoUtil proccedPageInfo(String currentPage, String pageSize) &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        &#x2F;* 分页 *&#x2F;</span><br><span class=\"line\">        PageInfoUtil pageInfoUtil &#x3D; new PageInfoUtil();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            &#x2F;*</span><br><span class=\"line\">             * 将字符串转换成整数,有风险, 字符串为a,转换不成整数</span><br><span class=\"line\">             *&#x2F;</span><br><span class=\"line\">            pageInfoUtil.setCurrentPage(Integer.valueOf(currentPage));</span><br><span class=\"line\">            pageInfoUtil.setPageSize(Integer.valueOf(pageSize));</span><br><span class=\"line\">        &#125; catch (NumberFormatException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return pageInfoUtil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，这里虽然指SpringBoot，SpringMVC也是同样的，但要求在Spring4.2及以上的版本。</p>\n<h2 id=\"方法二-处理跨域请求的Configuration\"><a href=\"#方法二-处理跨域请求的Configuration\" class=\"headerlink\" title=\"方法二 处理跨域请求的Configuration\"></a>方法二 处理跨域请求的Configuration</h2><p>增加一个配置类，CrossOriginConfig.java。继承WebMvcConfigurerAdapter或者实现WebMvcConfigurer接口，其他都不用管，项目启动时，会自动读取配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\">import org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class=\"line\">import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * AJAX请求跨域</span><br><span class=\"line\"> * @author Mr.W</span><br><span class=\"line\"> * @time 2018-08-13</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class CorsConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\">    static final String ORIGINS[] &#x3D; new String[] &#123; &quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot; &#125;;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class=\"line\">        registry.addMapping(&quot;&#x2F;**&quot;).allowedOrigins(&quot;*&quot;).allowCredentials(true).allowedMethods(ORIGINS).maxAge(3600);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法三-采用过滤器（filter）的方式\"><a href=\"#方法三-采用过滤器（filter）的方式\" class=\"headerlink\" title=\"方法三  采用过滤器（filter）的方式\"></a>方法三  采用过滤器（filter）的方式</h2><p>同方法二加配置类，增加一个CORSFilter 类，并实现Filter接口即可，其他都不用管，接口调用时，会过滤跨域的拦截。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> @Component</span><br><span class=\"line\">public class CORSFilter implements Filter &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class=\"line\">            throws IOException, ServletException &#123;</span><br><span class=\"line\">        HttpServletResponse res &#x3D; (HttpServletResponse) response;</span><br><span class=\"line\">        res.addHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class=\"line\">        res.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class=\"line\">        res.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, DELETE, PUT&quot;);</span><br><span class=\"line\">        res.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-CAF-Authorization-Token,sessionToken,X-TOKEN&quot;);</span><br><span class=\"line\">        if (((HttpServletRequest) request).getMethod().equals(&quot;OPTIONS&quot;)) &#123;</span><br><span class=\"line\">            response.getWriter().println(&quot;ok&quot;);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        chain.doFilter(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void destroy() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["框架"],"tags":["Spring","Web"]},{"title":"Swagger","url":"/2021/07/31/Swagger/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h1 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h1><ol>\n<li>springfox-swagger-ui</li>\n<li>springfox-swagger2</li>\n</ol>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"swagger配置类\"><a href=\"#swagger配置类\" class=\"headerlink\" title=\"swagger配置类\"></a>swagger配置类</h2><ol>\n<li>写配置类SwaggerConfig</li>\n<li>注解@EnableSwagger2</li>\n</ol>\n<h2 id=\"Swagger的实例Docket\"><a href=\"#Swagger的实例Docket\" class=\"headerlink\" title=\"Swagger的实例Docket\"></a>Swagger的实例Docket</h2><ol>\n<li>@Bean注册Docket文档类型</li>\n<li>apiInfo配置</li>\n<li>扫描接口<br>Docket.select()</li>\n</ol>\n<h3 id=\"指定包扫描\"><a href=\"#指定包扫描\" class=\"headerlink\" title=\"指定包扫描\"></a>指定包扫描</h3><p>RequestHandlerSelectors.basePackage(“com.xxx.xxx”)</p>\n<h3 id=\"指定路径扫描（访问路径）\"><a href=\"#指定路径扫描（访问路径）\" class=\"headerlink\" title=\"指定路径扫描（访问路径）\"></a>指定路径扫描（访问路径）</h3><p>path(PathSelectors.ant(“/xx/xx/xx”))</p>\n<h3 id=\"扫描全部（不常用）\"><a href=\"#扫描全部（不常用）\" class=\"headerlink\" title=\"扫描全部（不常用）\"></a>扫描全部（不常用）</h3><p>RequestHandlerSelectors.any()</p>\n<h3 id=\"不扫描（不常用）\"><a href=\"#不扫描（不常用）\" class=\"headerlink\" title=\"不扫描（不常用）\"></a>不扫描（不常用）</h3><h3 id=\"扫描类注解\"><a href=\"#扫描类注解\" class=\"headerlink\" title=\"扫描类注解\"></a>扫描类注解</h3><h3 id=\"扫描方法注解\"><a href=\"#扫描方法注解\" class=\"headerlink\" title=\"扫描方法注解\"></a>扫描方法注解</h3><p>build()</p>\n<h2 id=\"配置是否启动swagger\"><a href=\"#配置是否启动swagger\" class=\"headerlink\" title=\"配置是否启动swagger\"></a>配置是否启动swagger</h2><p>enable(boolean);</p>\n<h3 id=\"应用：Swagger开发时使用，发布时候关闭\"><a href=\"#应用：Swagger开发时使用，发布时候关闭\" class=\"headerlink\" title=\"应用：Swagger开发时使用，发布时候关闭\"></a>应用：Swagger开发时使用，发布时候关闭</h3><h2 id=\"获取环境\"><a href=\"#获取环境\" class=\"headerlink\" title=\"获取环境\"></a>获取环境</h2><p>Environment环境类<br>Profiles类</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>groupName(“xxx”)</p>\n<h2 id=\"ApiModel\"><a href=\"#ApiModel\" class=\"headerlink\" title=\"ApiModel\"></a>ApiModel</h2><p>如果扫描的类中，有返回对应的类，该类会被扫描到model里<br>使用@ApiModel(xxx)可以配置注释</p>\n<h2 id=\"ApiOperation\"><a href=\"#ApiOperation\" class=\"headerlink\" title=\"ApiOperation\"></a>ApiOperation</h2><p>用在方法上</p>\n<h2 id=\"Api-tags-”xxx”\"><a href=\"#Api-tags-”xxx”\" class=\"headerlink\" title=\"Api(tags=”xxx”)\"></a>Api(tags=”xxx”)</h2><h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>在页面上可以执行测试</p>\n","categories":["框架"],"tags":["API文档"]},{"title":"Tomcat","url":"/2021/04/06/Tomcat/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"对外\"><a href=\"#对外\" class=\"headerlink\" title=\"对外\"></a>对外</h2><p>对外接受http请求，封装并解析报文，分发请求。</p>\n<h2 id=\"对内\"><a href=\"#对内\" class=\"headerlink\" title=\"对内\"></a>对内</h2><p>对War包解析，生成一系列对象，并管理这些对象，将外部请求对接到对应的对象中去。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h2><h2 id=\"动态资源\"><a href=\"#动态资源\" class=\"headerlink\" title=\"动态资源\"></a>动态资源</h2><h1 id=\"安装和配置\"><a href=\"#安装和配置\" class=\"headerlink\" title=\"安装和配置\"></a>安装和配置</h1><h1 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h1><h1 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h1><h2 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h2><h2 id=\"conf\"><a href=\"#conf\" class=\"headerlink\" title=\"conf\"></a>conf</h2><h2 id=\"lib\"><a href=\"#lib\" class=\"headerlink\" title=\"lib\"></a>lib</h2><h2 id=\"logs\"><a href=\"#logs\" class=\"headerlink\" title=\"logs\"></a>logs</h2><h2 id=\"temp\"><a href=\"#temp\" class=\"headerlink\" title=\"temp\"></a>temp</h2><h2 id=\"webapps\"><a href=\"#webapps\" class=\"headerlink\" title=\"webapps\"></a>webapps</h2><p>服务器应用，每一个文件夹, 都表示一个应用。</p>\n<div class=\"note info\">\n            <p>文件夹的名字, 就是该应用的应用名。特殊的是ROOT，表示默认项目</p>\n          </div>\n\n<h2 id=\"work\"><a href=\"#work\" class=\"headerlink\" title=\"work\"></a>work</h2><h1 id=\"Vue打包\"><a href=\"#Vue打包\" class=\"headerlink\" title=\"Vue打包\"></a>Vue打包</h1><h1 id=\"项目部署\"><a href=\"#项目部署\" class=\"headerlink\" title=\"项目部署\"></a>项目部署</h1><h2 id=\"部署WAR包\"><a href=\"#部署WAR包\" class=\"headerlink\" title=\"部署WAR包\"></a>部署WAR包</h2><h3 id=\"WEB-INF（必含）\"><a href=\"#WEB-INF（必含）\" class=\"headerlink\" title=\"WEB-INF（必含）\"></a>WEB-INF（必含）</h3><ol>\n<li>Web.xml        整个java项目的描述配置文件</li>\n<li>Classes          java的class文件</li>\n<li>Lib              这个项目所依赖的第三方包</li>\n</ol>\n<h3 id=\"Index-jsp（可选-首页）\"><a href=\"#Index-jsp（可选-首页）\" class=\"headerlink\" title=\"Index.jsp（可选, 首页）\"></a>Index.jsp（可选, 首页）</h3><h3 id=\"METAINF（maven的相关配置文件）\"><a href=\"#METAINF（maven的相关配置文件）\" class=\"headerlink\" title=\"METAINF（maven的相关配置文件）\"></a>METAINF（maven的相关配置文件）</h3><h3 id=\"可选文件\"><a href=\"#可选文件\" class=\"headerlink\" title=\"可选文件\"></a>可选文件</h3><div class=\"note info\">\n            <p>maven：帮我们在java服务器开发项目中自动导包的工具，不仅能自动导包，打包java项目。</p>\n          </div>\n<div class=\"note warning\">\n            <p>不要在tomcat运行期间修改文件</p>\n          </div>\n\n<h1 id=\"Tomcat组成结构\"><a href=\"#Tomcat组成结构\" class=\"headerlink\" title=\"Tomcat组成结构\"></a>Tomcat组成结构</h1><p>…/conf/server.xml<br><img src=\"/2021/04/06/Tomcat/%E5%9B%BE%E7%89%871.png\"></p>\n<h2 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h2><h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><h2 id=\"Connector\"><a href=\"#Connector\" class=\"headerlink\" title=\"Connector\"></a>Connector</h2><h2 id=\"Engine\"><a href=\"#Engine\" class=\"headerlink\" title=\"Engine\"></a>Engine</h2><h2 id=\"Host\"><a href=\"#Host\" class=\"headerlink\" title=\"Host\"></a>Host</h2><h2 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h2><p>一个Context就是一个应用</p>\n<h1 id=\"虚拟路径映射\"><a href=\"#虚拟路径映射\" class=\"headerlink\" title=\"虚拟路径映射\"></a>虚拟路径映射</h1><p>在server.xml里的host下新增context。<br><img src=\"/2021/04/06/Tomcat/%E8%99%9A%E6%8B%9F%E6%98%A0%E5%B0%841.png\"><br>在/conf/catalina/localhost中新增 “应用名.xml”。<br><img src=\"/2021/04/06/Tomcat/%E8%99%9A%E6%8B%9F%E6%98%A0%E5%B0%842.png\"></p>\n<h1 id=\"tomcat默认首页配置\"><a href=\"#tomcat默认首页配置\" class=\"headerlink\" title=\"tomcat默认首页配置\"></a>tomcat默认首页配置</h1><p>tomcat的首页是手动配置的。</p>\n","categories":["Web服务器"],"tags":["Web"]},{"title":"UNIX环境编程-疑问集","url":"/2023/03/16/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E7%96%91%E9%97%AE%E9%9B%86/","content":"<h1 id=\"UNIX系统编程\"><a href=\"#UNIX系统编程\" class=\"headerlink\" title=\"UNIX系统编程\"></a>UNIX系统编程</h1><h2 id=\"什么是EINTR错误？什么时候会产生？\"><a href=\"#什么是EINTR错误？什么时候会产生？\" class=\"headerlink\" title=\"什么是EINTR错误？什么时候会产生？\"></a>什么是EINTR错误？什么时候会产生？</h2><p>EINTR是慢系统调用的中断错误代码，定义在&lt;error.h&gt;里</p>\n<p>产生：如果某进程捕获到一个信号并且该信号处理函数返回，那么此次慢系统调用可能会被中断，并返回EINTR错误。</p>\n<h2 id=\"文件和目录\"><a href=\"#文件和目录\" class=\"headerlink\" title=\"文件和目录\"></a>文件和目录</h2><ol>\n<li>DIR 和 struct dirent的区别是什么？<br> DIR：是一个目录流<br> struct dirent是一个目录项结构，存放目录的具体信息。</li>\n</ol>\n<h1 id=\"UNIX网络编程\"><a href=\"#UNIX网络编程\" class=\"headerlink\" title=\"UNIX网络编程\"></a>UNIX网络编程</h1><h2 id=\"socket是阻塞还是非阻塞IO？\"><a href=\"#socket是阻塞还是非阻塞IO？\" class=\"headerlink\" title=\"socket是阻塞还是非阻塞IO？\"></a>socket是阻塞还是非阻塞IO？</h2><p>取决底层file的配置：fcntl函数。默认是阻塞的</p>\n<h2 id=\"为什么accept函数要传入一个sizelen-t的指针？\"><a href=\"#为什么accept函数要传入一个sizelen-t的指针？\" class=\"headerlink\" title=\"为什么accept函数要传入一个sizelen_t的指针？\"></a>为什么accept函数要传入一个sizelen_t的指针？</h2><p>因为accept会根据对方实际的内容，修改addr的内容，并可能修改大小。所以这个size需要是个指针。</p>\n<h2 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><ol>\n<li>底层原理</li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/552580039\">https://zhuanlan.zhihu.com/p/552580039</a></p>\n<ol start=\"2\">\n<li>为什么epfd是个int?</li>\n</ol>\n<p>实际上, 那个int只是个指针值, 指向了红黑树的根节点. 参考上面内容</p>\n<ol start=\"3\">\n<li>epoll_wait是不是非阻塞IO？</li>\n</ol>\n<p>不是</p>\n<ol start=\"4\">\n<li>epoll_wait如果有超过MAX_EVENTS的数量时候，会怎么处理？</li>\n</ol>\n<h2 id=\"网络中的大小端\"><a href=\"#网络中的大小端\" class=\"headerlink\" title=\"网络中的大小端\"></a>网络中的大小端</h2><ol>\n<li><p>大端</p>\n</li>\n<li><p>小端</p>\n</li>\n</ol>\n<h2 id=\"互联网是使用大端来存储的\"><a href=\"#互联网是使用大端来存储的\" class=\"headerlink\" title=\"互联网是使用大端来存储的\"></a>互联网是使用大端来存储的</h2><h1 id=\"TCP连接的流程\"><a href=\"#TCP连接的流程\" class=\"headerlink\" title=\"TCP连接的流程\"></a>TCP连接的流程</h1><p><img src=\"/2023/03/16/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E7%96%91%E9%97%AE%E9%9B%86/Share\\日志\\内化\\编程相关\\C\\Unix网络编程\\TCP连接.png\" alt=\"TCP连接\"></p>\n<h2 id=\"代码例程\"><a href=\"#代码例程\" class=\"headerlink\" title=\"代码例程\"></a>代码例程</h2><p>socket：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">domain</th>\n<th align=\"center\">type</th>\n<th align=\"center\">protocol</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\">AF_INET(IPV4)</td>\n<td align=\"center\">SOCK_STREAM(TCP)</td>\n<td align=\"center\">IPPROTO_TCP</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">AF_INET6(IPV6)</td>\n<td align=\"center\">SOCK_DGRAM(UDP)</td>\n<td align=\"center\">IPPROTP_UDP</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>bind：进行端口的绑定，服务端需要执行该操作。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tARGS_CHECK(argc,<span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sfd = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</span><br><span class=\"line\">    ERROR_CHECK(sfd,<span class=\"number\">-1</span>,<span class=\"string\">&quot;socket&quot;</span>);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serAddr</span>;</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;serAddr,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(serAddr));</span><br><span class=\"line\">    serAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    serAddr.sin_port = htons(atoi(argv[<span class=\"number\">2</span>]));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(sfd,(struct sockaddr*)&amp;serAddr,<span class=\"keyword\">sizeof</span>(serAddr));\t<span class=\"comment\">// bind</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ERROR_CHECK(ret,<span class=\"number\">-1</span>,<span class=\"string\">&quot;bind&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​   struct sockaddr_in:</p>\n<p>listen：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>​    backlog:</p>\n<p>connect：connect不需要bind，因为会自动选择一个临时端口作为该连接。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ARGS_CHECK(argc,<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sfd = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</span><br><span class=\"line\">    ERROR_CHECK(sfd,<span class=\"number\">-1</span>,<span class=\"string\">&quot;socket&quot;</span>);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serAddr</span>;</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;serAddr,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(serAddr));</span><br><span class=\"line\">    serAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    serAddr.sin_port = htons(atoi(argv[<span class=\"number\">2</span>]));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = connect(sfd,(struct sockaddr*)&amp;serAddr,<span class=\"keyword\">sizeof</span>(serAddr));\t<span class=\"comment\">// connect</span></span><br><span class=\"line\">    ERROR_CHECK(ret,<span class=\"number\">-1</span>,<span class=\"string\">&quot;connect&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["UNIX"],"tags":["疑问集","UNIX","Linux系统编程"]},{"title":"axios","url":"/2021/08/04/axios/","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>axios是独立于vue的项目，可以用于浏览器和node.js中发送ajax请求</p>\n<h2 id=\"axios实例\"><a href=\"#axios实例\" class=\"headerlink\" title=\"axios实例\"></a>axios实例</h2><h3 id=\"引入axios文件\"><a href=\"#引入axios文件\" class=\"headerlink\" title=\"引入axios文件\"></a>引入axios文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写具体代码\"><a href=\"#编写具体代码\" class=\"headerlink\" title=\"编写具体代码\"></a>编写具体代码</h3><p>axios异步请求，返回promise，then进行回调<br>axios.get(“xxx”).then().catch()<br>then成功后执行内容<br>catch失败后执行内容</p>\n","categories":["框架"],"tags":["前端"]},{"title":"Zookeeper","url":"/2020/09/22/Zookeeper/","content":"<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h1 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h1><p>/etc/zookeeper/zoo.cfg</p>\n","categories":["框架"],"tags":["分布式","微服务","注册中心"]},{"title":"enum","url":"/2021/07/14/enum/","content":"<h1 id=\"枚举简介\"><a href=\"#枚举简介\" class=\"headerlink\" title=\"枚举简介\"></a>枚举简介</h1><p>枚举是静态的</p>\n<h1 id=\"枚举的使用\"><a href=\"#枚举的使用\" class=\"headerlink\" title=\"枚举的使用\"></a>枚举的使用</h1><h1 id=\"枚举的进阶\"><a href=\"#枚举的进阶\" class=\"headerlink\" title=\"枚举的进阶\"></a>枚举的进阶</h1><h2 id=\"枚举的属性、方法和构造函数\"><a href=\"#枚举的属性、方法和构造函数\" class=\"headerlink\" title=\"枚举的属性、方法和构造函数\"></a>枚举的属性、方法和构造函数</h2><h2 id=\"EnumSet和EnumMap\"><a href=\"#EnumSet和EnumMap\" class=\"headerlink\" title=\"EnumSet和EnumMap\"></a>EnumSet和EnumMap</h2><h3 id=\"EnumSet\"><a href=\"#EnumSet\" class=\"headerlink\" title=\"EnumSet\"></a>EnumSet</h3><p>EnumSet 是一个专为枚举设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定。<br>EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。<br>EnumSet在内部以位向量的形式存储，这种存储形式非常紧凑、高效,因此EnumSet对象占用内存很小，而且运行效率很好。尤其是进行批量操作（如调用containsAll()和retainAll()方法）时，如果其参数也是EnumSet集合，则该批量操作的执行速度也非常快。<br>EnumSet集合不允许加入null元素，如果试图插入null元素，EnumSet将抛出NullPointerException异常。<br>EnumSet类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的类方法来创建EnumSet对象。<br>如果只是想判断EnumSet是否包含null元素或试图删除null元素都不会抛出异常，只是删除操作将返回false，因为没有任何null元素被删除。</p>\n<p>方法：</p>\n<ol>\n<li>EnumSet allOf(Class elementType): 创建一个包含指定枚举类里所有枚举值的EnumSet集合。</li>\n<li>EnumSet complementOf(EnumSet e): 创建一个其元素类型与指定EnumSet里元素类型相同的</li>\n<li>EnumSet集合，新EnumSet集合包含原EnumSet集合所不包含的、此类枚举类剩下的枚举值（即新EnumSet集合和原EnumSet集合的集合元素加起来是该枚举类的所有枚举值）。</li>\n<li>EnumSet copyOf(Collection c): 使用一个普通集合来创建EnumSet集合。</li>\n<li>EnumSet copyOf(EnumSet e): 创建一个指定EnumSet具有相同元素类型、相同集合元素的EnumSet集合。</li>\n<li>EnumSet noneOf(Class elementType): 创建一个元素类型为指定枚举类型的空EnumSet。</li>\n<li>EnumSet of(E first,E…rest): 创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举值必I 须属于同一个枚举类。</li>\n<li>EnumSet range(E from,E to): 创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合。</li>\n</ol>\n<h3 id=\"EnumMap\"><a href=\"#EnumMap\" class=\"headerlink\" title=\"EnumMap\"></a>EnumMap</h3><p>Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。</p>\n<h1 id=\"枚举的比较\"><a href=\"#枚举的比较\" class=\"headerlink\" title=\"枚举的比较\"></a>枚举的比较</h1><h1 id=\"使用枚举实现的设计模式\"><a href=\"#使用枚举实现的设计模式\" class=\"headerlink\" title=\"使用枚举实现的设计模式\"></a>使用枚举实现的设计模式</h1><h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">PizzaDeliverySystemConfiguration</span> </span>&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    PizzaDeliverySystemConfiguration() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Initialization configuration which involves</span></span><br><span class=\"line\">        <span class=\"comment\">// overriding defaults like delivery strategy</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> PizzaDeliveryStrategy deliveryStrategy = PizzaDeliveryStrategy.NORMAL;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PizzaDeliverySystemConfiguration <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PizzaDeliveryStrategy <span class=\"title\">getDeliveryStrategy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> deliveryStrategy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PizzaDeliveryStrategy deliveryStrategy = PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy();</span><br></pre></td></tr></table></figure>\n<h2 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><h1 id=\"Java8和枚举\"><a href=\"#Java8和枚举\" class=\"headerlink\" title=\"Java8和枚举\"></a>Java8和枚举</h1><p>枚举可以配合Java8的lambda表达式来进行操作</p>\n","categories":["编程语言"],"tags":["Java"]},{"title":"node-js","url":"/2021/08/04/node-js/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>基于chrome v8引擎的JavaScript运行环境，<br>脱离浏览器也可以运行JavaScript</p>\n<ol>\n<li>运行JavaScript</li>\n<li>模拟服务端效果</li>\n</ol>\n<h1 id=\"BFF\"><a href=\"#BFF\" class=\"headerlink\" title=\"BFF\"></a>BFF</h1><p>作用是让前端有能力自由组装后台数据，减少大量的业务沟通成本，加快业务的迭代速度。</p>\n<p>一个前端页面向 Service A、Service B 以及 Service C发送请求，不同的微服务返回的值用于渲染页面中不同的组件。此时，每次访问该页面都需要发送 3 个请求。我们需要一个服务来聚合Service A、Service B 以及 Service C响应的数据，这个服务层叫做BFF。</p>\n<h1 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h1><p>node package manager<br>Node.js包管理工具，相当于前端的maven<br>node.js自动集成了Npm</p>\n<h2 id=\"使用npm管理项目\"><a href=\"#使用npm管理项目\" class=\"headerlink\" title=\"使用npm管理项目\"></a>使用npm管理项目</h2><h3 id=\"创建项目初始化\"><a href=\"#创建项目初始化\" class=\"headerlink\" title=\"创建项目初始化\"></a>创建项目初始化</h3><p>npm init</p>\n<ol>\n<li>package name</li>\n<li>version</li>\n<li>descrtion</li>\n<li>entry point</li>\n<li>test command</li>\n<li>git</li>\n<li>keywords</li>\n<li>author</li>\n<li>license</li>\n</ol>\n<h3 id=\"设置淘宝镜像仓库\"><a href=\"#设置淘宝镜像仓库\" class=\"headerlink\" title=\"设置淘宝镜像仓库\"></a>设置淘宝镜像仓库</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"下载依赖\"><a href=\"#下载依赖\" class=\"headerlink\" title=\"下载依赖\"></a>下载依赖</h3><p>npm install xxx<br>npm install：可以根据配置文件，自动下载对应的依赖。</p>\n<h3 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h3><ol>\n<li>更新：npm update</li>\n<li>全局更新：npm update -g</li>\n<li>卸载：npm uninstall</li>\n<li>全局卸载: npm uninstall -g</li>\n</ol>\n<h1 id=\"前端和后端开发区别\"><a href=\"#前端和后端开发区别\" class=\"headerlink\" title=\"前端和后端开发区别\"></a>前端和后端开发区别</h1><p>前端之间是js相互调用<br>后端之间是方法互相调用</p>\n<h1 id=\"ES6模块化代码\"><a href=\"#ES6模块化代码\" class=\"headerlink\" title=\"ES6模块化代码\"></a>ES6模块化代码</h1><h2 id=\"导出模块\"><a href=\"#导出模块\" class=\"headerlink\" title=\"导出模块\"></a>导出模块</h2><p><code>export default &#123;&#125;</code></p>\n<h2 id=\"导入模块\"><a href=\"#导入模块\" class=\"headerlink\" title=\"导入模块\"></a>导入模块</h2><p>import </p>\n<h1 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h1><p>node.js无法直接执行ES6的模块化，需要用babel编辑成ES5再执行。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>npm install -g babel-cli</p>\n<h2 id=\"配置babel配置文件\"><a href=\"#配置babel配置文件\" class=\"headerlink\" title=\"配置babel配置文件\"></a>配置babel配置文件</h2><p>.babelrc 放在根目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;: [&quot;es2015&quot;],</span><br><span class=\"line\">    &quot;plugins&quot;: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装转码器\"><a href=\"#安装转码器\" class=\"headerlink\" title=\"安装转码器\"></a>安装转码器</h2><p>npm install -D babel-preset-es2015<br>-D 是局部安装</p>\n<h2 id=\"使用命令转码\"><a href=\"#使用命令转码\" class=\"headerlink\" title=\"使用命令转码\"></a>使用命令转码</h2><p>babel src -d [dist]</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><h2 id=\"ES6的不同写法\"><a href=\"#ES6的不同写法\" class=\"headerlink\" title=\"ES6的不同写法\"></a>ES6的不同写法</h2>","tags":["前端"]},{"title":"webpack","url":"/2021/08/05/webpack/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>前端打包工具<br>可以打包多种js、css、less等文件为一个静态文件，减少页面的请求。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"JS打包\"><a href=\"#JS打包\" class=\"headerlink\" title=\"JS打包\"></a>JS打包</h2><h3 id=\"创建js文件\"><a href=\"#创建js文件\" class=\"headerlink\" title=\"创建js文件\"></a>创建js文件</h3><h3 id=\"创建打包配置文件\"><a href=\"#创建打包配置文件\" class=\"headerlink\" title=\"创建打包配置文件\"></a>创建打包配置文件</h3><p>webpack.config.js 放置在根目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const path &#x3D; require(&quot;path&quot;)    &#x2F;&#x2F;node.js内置模块</span><br><span class=\"line\">module.exports&#x3D; &#123;</span><br><span class=\"line\">    entry: &quot;.&#x2F;src&#x2F;main.js&quot;,     &#x2F;&#x2F;入口文件</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;),    &#x2F;&#x2F;输出路径</span><br><span class=\"line\">        filename: &#39;bundle.js&#39;   &#x2F;&#x2F;输出后的打包文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行编译指令\"><a href=\"#执行编译指令\" class=\"headerlink\" title=\"执行编译指令\"></a>执行编译指令</h3><p>webpack –mode=development</p>\n<h2 id=\"CSS打包\"><a href=\"#CSS打包\" class=\"headerlink\" title=\"CSS打包\"></a>CSS打包</h2><h3 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const path &#x3D; require(&quot;path&quot;)    &#x2F;&#x2F;node.js内置模块</span><br><span class=\"line\">module.exports&#x3D; &#123;</span><br><span class=\"line\">    entry: &quot;.&#x2F;src-es5&#x2F;main.js&quot;,     &#x2F;&#x2F;入口文件</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;),    &#x2F;&#x2F;输出路径</span><br><span class=\"line\">        filename: &#39;bundle.js&#39;   &#x2F;&#x2F;输出后的打包文件</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;新增配置</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [&#123;</span><br><span class=\"line\">            test: &#x2F;\\.css$&#x2F;,\t\t\t&#x2F;&#x2F;打包规则应用到css文件后缀上</span><br><span class=\"line\">            use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建CSS文件\"><a href=\"#创建CSS文件\" class=\"headerlink\" title=\"创建CSS文件\"></a>创建CSS文件</h3><h3 id=\"安装对应loader\"><a href=\"#安装对应loader\" class=\"headerlink\" title=\"安装对应loader\"></a>安装对应loader</h3><p>npm install css-loader style-loader –save-dev</p>\n<h2 id=\"执行打包\"><a href=\"#执行打包\" class=\"headerlink\" title=\"执行打包\"></a>执行打包</h2><h1 id=\"配置文件结构\"><a href=\"#配置文件结构\" class=\"headerlink\" title=\"配置文件结构\"></a>配置文件结构</h1><h2 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h2><p><img src=\"/2021/08/05/webpack/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png\"></p>\n","categories":["前端"],"tags":["webpack"]},{"title":"vue","url":"/2021/08/03/vue/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>JavaScript框架，用来简化web开发，核心是MVC的视图层。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"vue-js\"><a href=\"#vue-js\" class=\"headerlink\" title=\"vue.js\"></a>vue.js</h2><p>在vue官网下载vue.js，然后放到开发文件中，并在代码中引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src &#x3D; vue.js&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<p>声明式渲染：使用简洁的模板语法声明式的将数据渲染进DOM里</p>\n<ol>\n<li>定义div</li>\n<li>使用Vue绑定div</li>\n<li>编写Vue的内容<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;!-- &#123;&#123;&#125;&#125; 插值表达式，绑定vue的data数据--&gt;</span><br><span class=\"line\">        &#123;&#123;message&#125;&#125;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;script src &#x3D; vue.js&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        new Vue(&#123;</span><br><span class=\"line\">            el: &#39;#app&#39;,     &#x2F;&#x2F;绑定vue作用范围</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                message: &#39;Hello, Vue&#39;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n            <p>代码片段</p>\n          </div>\n<h2 id=\"单向绑定v-bind\"><a href=\"#单向绑定v-bind\" class=\"headerlink\" title=\"单向绑定v-bind\"></a>单向绑定v-bind</h2>把Vue里的值绑定到对应属性中<br>v-bind:[属性]=”绑定对象”<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;div v-bind:style&#x3D;&quot;message&quot;&gt;涨涨涨&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        new Vue(&#123;</span><br><span class=\"line\">            el: &#39;#app&#39;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                message: &#39;color:red;&#39;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n简写 :[属性]=“绑定对象”</li>\n</ol>\n<h2 id=\"双向绑定-v-model\"><a href=\"#双向绑定-v-model\" class=\"headerlink\" title=\"双向绑定 v-model\"></a>双向绑定 v-model</h2><h2 id=\"绑定事件-v-on\"><a href=\"#绑定事件-v-on\" class=\"headerlink\" title=\"绑定事件 v-on\"></a>绑定事件 v-on</h2><p>简写：@事件名=”函数”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;button v-on:click&#x3D;&quot;show()&quot;&gt;展示&lt;&#x2F;button&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        new Vue(&#123;</span><br><span class=\"line\">            el: &#39;#app&#39;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                show() &#123;</span><br><span class=\"line\">                    console.log(&quot;展示！&quot;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件指令-v-if\"><a href=\"#条件指令-v-if\" class=\"headerlink\" title=\"条件指令 v-if\"></a>条件指令 v-if</h2><p>v-if<br>v-else</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;ok&quot;&gt;点我！&lt;&#x2F;input&gt;</span><br><span class=\"line\">        &lt;br&#x2F;&gt;</span><br><span class=\"line\">        &lt;!--如果ok为true--&gt;</span><br><span class=\"line\">        &lt;div v-if&#x3D;&quot;ok&quot;&gt;选中了！&lt;&#x2F;div&gt;</span><br><span class=\"line\">        &lt;div v-else&gt;没选中...&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        new Vue(&#123;</span><br><span class=\"line\">            el: &#39;#app&#39;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                ok:false</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环指令v-for\"><a href=\"#循环指令v-for\" class=\"headerlink\" title=\"循环指令v-for\"></a>循环指令v-for</h2><p>v-for=”user in userList”</p>\n  //注意是点\n\n<p>附带索引 v-for=“(user, index)” in userList”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;div v-for&#x3D;&quot;user in userList&quot;&gt;</span><br><span class=\"line\">            &#123;&#123;user.name&#125;&#125; 年龄: &#123;&#123;user.age&#125;&#125;</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        new Vue(&#123;</span><br><span class=\"line\">            el: &#39;#app&#39;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                userList:[</span><br><span class=\"line\">                    &#123;&quot;name&quot;:&quot;tian&quot;, &quot;age&quot;: 18&#125;,</span><br><span class=\"line\">                    &#123;&quot;name&quot;:&quot;my&quot;, &quot;age&quot;: 18&#125;</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Vue生命周期\"><a href=\"#Vue生命周期\" class=\"headerlink\" title=\"Vue生命周期\"></a>Vue生命周期</h1><h2 id=\"created方法\"><a href=\"#created方法\" class=\"headerlink\" title=\"created方法\"></a>created方法</h2><p>页面渲染之前执行</p>\n<h2 id=\"mounted方法\"><a href=\"#mounted方法\" class=\"headerlink\" title=\"mounted方法\"></a>mounted方法</h2><p>页面渲染之后执行</p>\n<h2 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h2>","categories":["前端"],"tags":["VUE"]},{"title":"优先队列","url":"/2023/03/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>优先队列，顾名思义是个队列，然后保持“优先性”。<br>优先性：根据自定义优先逻辑，决定了哪个元素在前，哪个元素在后</p>\n<span id=\"more\"></span>\n<h1 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h1><h2 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h2><p>堆：大顶堆/小顶堆，满足这样的逻辑定义</p>\n<h2 id=\"物理结构\"><a href=\"#物理结构\" class=\"headerlink\" title=\"物理结构\"></a>物理结构</h2><p>采用数组的形式：</p>\n<ol>\n<li>双亲结点为array[n/2]</li>\n<li>左孩子：2n</li>\n<li>右孩子：2n+1</li>\n</ol>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h1 id=\"Java的实现\"><a href=\"#Java的实现\" class=\"headerlink\" title=\"Java的实现\"></a>Java的实现</h1><h2 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h2><h3 id=\"offer\"><a href=\"#offer\" class=\"headerlink\" title=\"offer\"></a>offer</h3><h3 id><a href=\"#\" class=\"headerlink\" title></a></h3>","categories":["数据结构与算法"],"tags":["算法、数据结构"]},{"title":"函数指针","url":"/2023/07/12/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","content":"<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>函数指针就是一个指向函数的指针。在Java层面，比较类似于runnable接口。<br>作用：函数指针可以通过传递指针的方式，传递函数操作，从而更加灵活的使用函数。<br>一些应用实现：线程池</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2>","categories":["编程语言"],"tags":["C/C++"]},{"title":"分布式理论","url":"/2022/07/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/","content":"","categories":["分布式"],"tags":["分布式"]},{"title":"分布式锁","url":"/2022/07/14/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","content":"","categories":["分布式"],"tags":["分布式","锁"]},{"title":"定时任务","url":"/2022/08/15/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>很多时候有些业务需要定时的执行，或者定时检查等，所以需要使用定时任务。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"定时任务方案\"><a href=\"#定时任务方案\" class=\"headerlink\" title=\"定时任务方案\"></a>定时任务方案</h1><ol>\n<li>while(true) + Thread.sleep (X)</li>\n<li>java.util.Timer + java.util.TimerTask (X)</li>\n<li>ScheduledExecutorService</li>\n<li>Spring Scheduling</li>\n<li>Quartz</li>\n<li>Elastic-Job</li>\n<li>XXL-JOB</li>\n</ol>\n<p>5-7的方案可用于集群</p>\n<h1 id=\"Spring-Scheduling实现\"><a href=\"#Spring-Scheduling实现\" class=\"headerlink\" title=\"Spring Scheduling实现\"></a>Spring Scheduling实现</h1><p>Spring 3.0 提供，基于注解方式</p>\n<h2 id=\"Scheduled\"><a href=\"#Scheduled\" class=\"headerlink\" title=\"@Scheduled\"></a>@Scheduled</h2><p>属性：必须指定cron、fixedDelay、fixedRate中的一个</p>\n<ol>\n<li>cron：定时任务表达式 [顺序按照 秒 分 时 日 月 星期几）</li>\n<li>zone：时区</li>\n<li>fixedDelay：固定毫秒时间</li>\n<li>fixedDelayString：固定毫秒时间（String模式）<br>可以使用占位符号，读取配置</li>\n<li>fixedRate：两次调用之间固定毫秒时间</li>\n</ol>\n","categories":["解决方案"],"tags":["方案"]},{"title":"幂等性","url":"/2022/07/20/%E5%B9%82%E7%AD%89%E6%80%A7/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><span id=\"more\"></span>\n\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><p>本质是针对重复：</p>\n<ol>\n<li>可能引起的重复请求（网络、用户重复操作）</li>\n<li>应用重试机制</li>\n<li>第三方接口的异步回调</li>\n<li>中间件导致的重复请求问题</li>\n<li>定时任务</li>\n<li>等等….</li>\n</ol>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><h2 id=\"前端控制\"><a href=\"#前端控制\" class=\"headerlink\" title=\"前端控制\"></a>前端控制</h2><ol>\n<li>按钮置灰</li>\n<li>token机制</li>\n<li>PRG模式（Post-Redirect-Get）</li>\n<li>Session中存储特殊标志</li>\n</ol>\n<h2 id=\"后端控制\"><a href=\"#后端控制\" class=\"headerlink\" title=\"后端控制\"></a>后端控制</h2><p>根据业务选择合适的方案</p>\n<ol>\n<li>唯一索引</li>\n<li>Token + Redis</li>\n<li>状态机幂等</li>\n<li>乐观锁实现</li>\n<li>防重表</li>\n<li>select + insect</li>\n<li>分布式锁</li>\n<li>缓冲队列</li>\n<li>全局唯一实现幂等</li>\n</ol>\n<h1 id=\"Token-Redis的实现\"><a href=\"#Token-Redis的实现\" class=\"headerlink\" title=\"Token + Redis的实现\"></a>Token + Redis的实现</h1><h2 id=\"适用于\"><a href=\"#适用于\" class=\"headerlink\" title=\"适用于\"></a>适用于</h2><p>增 删 改 幂等性场景</p>\n<h2 id=\"业务流程\"><a href=\"#业务流程\" class=\"headerlink\" title=\"业务流程\"></a>业务流程</h2><ol>\n<li>申请Token（生成Token，并放到Redis）</li>\n<li>取Token</li>\n<li>做支付（验证Token，支付成功则删除Token）</li>\n</ol>\n<p>缺点：需要跟系统做两次交互，性能有所不佳</p>\n<h2 id=\"代理逻辑\"><a href=\"#代理逻辑\" class=\"headerlink\" title=\"代理逻辑\"></a>代理逻辑</h2><p>AOP来实现</p>\n<ol>\n<li>AOP生成Token，并放入Redis</li>\n<li>tokenService：对特定的API方法获取Redis里的Token值</li>\n<li>AOP实现Token验证及删除（保证原子性）</li>\n</ol>\n","categories":["解决方案"],"tags":["解决方案"]},{"title":"支付-alipay当面付","url":"/2022/02/21/%E6%94%AF%E4%BB%98-alipay%E5%BD%93%E9%9D%A2%E4%BB%98/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>社区团购项目，需要做支付集成，采用alipay的当面付。</p>\n<span id=\"more\"></span>\n<h1 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h1><p>maven:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alipay.sdk<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>alipay-sdk-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.22.37.ALL<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h1><p>zfbinfo.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 支付宝网关名、partnerId和appId</span><br><span class=\"line\">open_api_domain &#x3D; https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do</span><br><span class=\"line\">mcloud_api_domain &#x3D; http:&#x2F;&#x2F;mcloudmonitor.com&#x2F;gateway.do</span><br><span class=\"line\">pid &#x3D; 此处请填写你的PID</span><br><span class=\"line\">appid &#x3D; 此处请填写你当面付的APPID</span><br><span class=\"line\"></span><br><span class=\"line\"># RSA私钥、公钥和支付宝公钥</span><br><span class=\"line\">private_key &#x3D; 此处请填写你的商户私钥且转PKCS8格式</span><br><span class=\"line\">public_key &#x3D; 此处请填写你的商户公钥</span><br><span class=\"line\"></span><br><span class=\"line\">#SHA1withRsa对应支付宝公钥</span><br><span class=\"line\">#alipay_public_key &#x3D; MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi&#x2F;fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI&#x2F;FCEa3&#x2F;cNMW0QIDAQAB</span><br><span class=\"line\"></span><br><span class=\"line\">#SHA256withRsa对应支付宝公钥</span><br><span class=\"line\">alipay_public_key &#x3D; MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjrEVFMOSiNJXaRNKicQuQdsREraftDA9Tua3WNZwcpeXeh8Wrt+V9JilLqSa7N7sVqwpvv8zWChgXhX&#x2F;A96hEg97Oxe6GKUmzaZRNh0cZZ88vpkn5tlgL4mH&#x2F;dhSr3Ip00kvM4rHq9PwuT4k7z1DpZAf1eghK8Q5BgxL88d0X07m9X96Ijd0yMkXArzD7jg+noqfbztEKoH3kPMRJC2w4ByVdweWUT2PwrlATpZZtYLmtDvUKG&#x2F;sOkNAIKEMg3Rut1oKWpjyYanzDgS7Cg3awr1KPTl9rHCazk15aNYowmYtVabKwbGVToCAGK+qQ1gT3ELhkGnf3+h53fukNqRH+wIDAQAB</span><br><span class=\"line\"></span><br><span class=\"line\"># 签名类型: RSA-&gt;SHA1withRsa,RSA2-&gt;SHA256withRsa</span><br><span class=\"line\">sign_type &#x3D; RSA2</span><br><span class=\"line\"># 当面付最大查询次数和查询间隔（毫秒）</span><br><span class=\"line\">max_query_retry &#x3D; 5</span><br><span class=\"line\">query_duration &#x3D; 5000</span><br><span class=\"line\"></span><br><span class=\"line\"># 当面付最大撤销次数和撤销间隔（毫秒）</span><br><span class=\"line\">max_cancel_retry &#x3D; 3</span><br><span class=\"line\">cancel_duration &#x3D; 2000</span><br><span class=\"line\"></span><br><span class=\"line\"># 交易保障线程第一次调度延迟和调度间隔（秒）</span><br><span class=\"line\">heartbeat_delay &#x3D; 5</span><br><span class=\"line\">heartbeat_duration &#x3D; 900</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"读取配置\"><a href=\"#读取配置\" class=\"headerlink\" title=\"读取配置\"></a>读取配置</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> learn.myproject.order.alipay;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Properties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@auther</span> tian</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2022/2/21 2:25 下午</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@JDK</span>_version JDK1.8</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlipayConfigReader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getConfig</span><span class=\"params\">(String configKey)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\tProperties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">\t\tproperties.load(getClass().getResourceAsStream(<span class=\"string\">&quot;/zfbinfo.properties&quot;</span>));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> properties.getProperty(configKey);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["框架"],"tags":["开发记录","Java"]},{"title":"快速排序","url":"/2021/09/07/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","content":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ol>\n<li>选择一个作为Pivot（一般是第一个）</li>\n<li>选择左右边界L、R，L向右扫描，R向左扫描。如果有扫描没有移动，则继续移动当前移动的。</li>\n<li>大于Pivot的放在Pivot右边</li>\n<li>小于Pivot的放在Pivot左边</li>\n<li>直到L与R相遇</li>\n<li>此时把Pivot放置在相遇处，分出两个左右子序列</li>\n<li>递归操作左右子序列</li>\n<li>直到子序列长度为1，不用排序</li>\n</ol>\n","categories":["数据结构与算法"],"tags":["算法"]},{"title":"数据结构与算法","url":"/2021/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>算法是程序的计算方法</p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>掌握数据结构和算法，对于阅读框架源码，或者理解背后的设计思想，都是极其有用的。一切实际都是以用为目的，对于程序来讲，除了可读性、健壮性等，<strong>性能的好坏是个至关重要的标准</strong>。</p>\n<h2 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h2><p>数据通过一定的组织方式存在，这种结构就叫数据结构。数据结构是服务算法的，而算法是作用在数据结构上的，两者相辅相承。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"事后统计法\"><a href=\"#事后统计法\" class=\"headerlink\" title=\"事后统计法\"></a>事后统计法</h2><h2 id=\"大O复杂度表示法\"><a href=\"#大O复杂度表示法\" class=\"headerlink\" title=\"大O复杂度表示法\"></a>大O复杂度表示法</h2><p>所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。</p>\n<h2 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析\"></a>时间复杂度分析</h2><p>表示算法的执行时间与数据规模之间的增长关系。</p>\n<ol>\n<li>只关注循环执行次数最多的一段代码</li>\n<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>\n<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>\n</ol>\n<h2 id=\"几种常见的时间复杂度\"><a href=\"#几种常见的时间复杂度\" class=\"headerlink\" title=\"几种常见的时间复杂度\"></a>几种常见的时间复杂度</h2><ol>\n<li>O(1)</li>\n<li>O(logn)</li>\n<li>O(nlogn)</li>\n<li>O(n)</li>\n<li>O(m+n)</li>\n<li>O(m*n)</li>\n</ol>\n<h2 id=\"空间复杂度分析\"><a href=\"#空间复杂度分析\" class=\"headerlink\" title=\"空间复杂度分析\"></a>空间复杂度分析</h2><p>表示算法的存储空间与数据规模之间的增长关系。</p>\n<h2 id=\"最好时间复杂度\"><a href=\"#最好时间复杂度\" class=\"headerlink\" title=\"最好时间复杂度\"></a>最好时间复杂度</h2><p>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。</p>\n<h2 id=\"最坏时间复杂度\"><a href=\"#最坏时间复杂度\" class=\"headerlink\" title=\"最坏时间复杂度\"></a>最坏时间复杂度</h2><p>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。</p>\n<h2 id=\"平均时间复杂度\"><a href=\"#平均时间复杂度\" class=\"headerlink\" title=\"平均时间复杂度\"></a>平均时间复杂度</h2><p>最坏情况时间复杂度就是，在平均情况下，执行这段代码的时间复杂度。</p>\n<div class=\"note info\">\n            <p>很多时候，我们使用最基础的大O分析复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。</p>\n          </div>\n\n<h2 id=\"均摊时间复杂度（amortized-time-complexity）\"><a href=\"#均摊时间复杂度（amortized-time-complexity）\" class=\"headerlink\" title=\"均摊时间复杂度（amortized time complexity）\"></a>均摊时间复杂度（amortized time complexity）</h2><p>平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p>\n<div class=\"note info\">\n            <p>把一次数量大的操作，均摊到各个操作上之后，会显著降低时间复杂度的情况。（基本不会碰到）</p>\n          </div>\n\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><ol>\n<li>是个线性表</li>\n<li>连续的内存空间和相同的数据类型</li>\n</ol>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><h3 id=\"随机访问（核心优点）\"><a href=\"#随机访问（核心优点）\" class=\"headerlink\" title=\"随机访问（核心优点）\"></a>随机访问（核心优点）</h3><p>数组可以做到对任何内部数据访问时间为O(1)。</p>\n<div class=\"note info\">\n            <p>不能说数组更适合查找，链表更适合插入和删除。如果是个有序数组，查找最快也要logn。因此数组的优点是访问数据时间为O(1)。</p>\n          </div>\n\n<h3 id=\"“低效”的插入和删除\"><a href=\"#“低效”的插入和删除\" class=\"headerlink\" title=\"“低效”的插入和删除\"></a>“低效”的插入和删除</h3><div class=\"note info\">\n            <p>在JVM中，数组的删除，不是真正的删除，而是先标记为删除，如果数组满了，才进行一次真正的删除。</p>\n          </div>\n\n<h2 id=\"主要优点\"><a href=\"#主要优点\" class=\"headerlink\" title=\"主要优点\"></a>主要优点</h2><ol>\n<li>简单易用</li>\n<li>可以借用缓存：因为数组是连续的空间，因此可以借助缓存技术，使得访问效率更高。而链表则不行。</li>\n</ol>\n<h2 id=\"主要缺点\"><a href=\"#主要缺点\" class=\"headerlink\" title=\"主要缺点\"></a>主要缺点</h2><ol>\n<li>大小固定，扩容开销大</li>\n</ol>\n<h2 id=\"警惕数组越界\"><a href=\"#警惕数组越界\" class=\"headerlink\" title=\"警惕数组越界\"></a>警惕数组越界</h2><h2 id=\"容器和数组\"><a href=\"#容器和数组\" class=\"headerlink\" title=\"容器和数组\"></a>容器和数组</h2><p>比如ArrayList容器把很多数组操作细节进行了封装，并且支持动态扩容。（但是扩容的开销很大，所以最好初始确定容器大小。）<br>但是ArrayList无法存储基本数据类型，需要使用包装类，开箱会有性能消耗；数组则可以。<br>已知数组大小，用数组可能更方便。</p>\n<div class=\"note info\">\n            <p>为什么数组是以0为下标？因为早期最代码性能的要求比较高。 a[k]_address = base_address + k * type_size ，这样可以少一次减法运算。</p>\n          </div>\n\n\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。<br>链表可分为：</p>\n<ol>\n<li>单链表</li>\n<li>双链表</li>\n<li>循环链表</li>\n</ol>\n<p>对链表进行频繁插入和删除，会造成大量内存碎片，Java会导致频繁GC，损耗性能。</p>\n<div class=\"note info\">\n            <p>如何实现LRU缓存淘汰算法：</p><ol><li>单链表，规定链的长度</li><li>Hash表定位链表内容</li><li>新访问的放置在链头，超出长度，则删除链尾</li></ol>\n          </div>\n\n<p>单链表回文如何判断？<br>「看了大家的评论学习到了快慢指针法，看语言描述没太懂，自己用代码写了下才明白。<br>大致思路如下<br>由于回文串最重要的就是对称，那么最重要的问题就是找到那个中心，用快指针每步两格走，当他到达链表末端的时候，慢指针刚好到达中心，慢指针在过来的这趟路上还做了一件事，他把走过的节点反向了，在中心点再开辟一个新的指针用于往回走，而慢指针继续向前，当慢指针扫完整个链表，就可以判断这是回文串，否则就提前退出，总的来说时间复杂度按慢指针遍历一遍来算是O(n),空间复杂度因为只开辟了3个额外的辅助，所以是o(1)」</p>\n<h2 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h2><p>故名思义，单链表就是单向的一个链表，每个结点包含了 {当前值元素，下一个结点的地址}<br>结尾指向null</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class node &#123;</span><br><span class=\"line\">  data value;</span><br><span class=\"line\">  node next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优点：实现简单、在明确位置的结点处插入和删除方便。<br>缺点：访问需要遍历整条链，消耗性能。<br><img src=\"/2021/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%93%BE%E8%A1%A8.jpg\"></p>\n<h2 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h2><p>双向链表，即有向前和向后指的两个指针的链表，结尾也是指向null</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class node &#123;</span><br><span class=\"line\">  node prev;</span><br><span class=\"line\">  data value;</span><br><span class=\"line\">  node next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2021/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg\"></p>\n<h2 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h2><p>循环链表，即特殊的单链表，头结点指向了尾结点，而尾结点指向了头结点。</p>\n<h2 id=\"理念：用时间换空间\"><a href=\"#理念：用时间换空间\" class=\"headerlink\" title=\"理念：用时间换空间\"></a>理念：用时间换空间</h2><p>双向链表比单向链表更费空间，但是使用效率上缺高出很多。比如Java中的LinkedHashMap，所使用的就是双向链表。</p>\n<h2 id=\"如何基于链表实现LRU\"><a href=\"#如何基于链表实现LRU\" class=\"headerlink\" title=\"如何基于链表实现LRU\"></a>如何基于链表实现LRU</h2><ol>\n<li>采用限定长度的单链表</li>\n<li>每次需要使用数据时，遍历该链表（或者使用Hash做映射，看链表是否有该数据）。</li>\n<li>将该数据在缓存中，将该结点从位置删除，并移动至链表头部</li>\n<li>如果不在缓存中<br>1）缓存未满，直接在头部插入该数据<br>2）缓存已满，删除尾部数据，并在头部插入该数据</li>\n</ol>\n<h2 id=\"如何轻松写出正确的链表代码\"><a href=\"#如何轻松写出正确的链表代码\" class=\"headerlink\" title=\"如何轻松写出正确的链表代码\"></a>如何轻松写出正确的链表代码</h2><h3 id=\"理解指针（引用）的含义\"><a href=\"#理解指针（引用）的含义\" class=\"headerlink\" title=\"理解指针（引用）的含义\"></a>理解指针（引用）的含义</h3><h3 id=\"警惕指针丢失和内存泄漏\"><a href=\"#警惕指针丢失和内存泄漏\" class=\"headerlink\" title=\"警惕指针丢失和内存泄漏\"></a>警惕指针丢失和内存泄漏</h3><h3 id=\"利用哨兵简化难度\"><a href=\"#利用哨兵简化难度\" class=\"headerlink\" title=\"利用哨兵简化难度\"></a>利用哨兵简化难度</h3><h3 id=\"留意边界条件处理\"><a href=\"#留意边界条件处理\" class=\"headerlink\" title=\"留意边界条件处理\"></a>留意边界条件处理</h3><h3 id=\"举例画图辅助思考\"><a href=\"#举例画图辅助思考\" class=\"headerlink\" title=\"举例画图辅助思考\"></a>举例画图辅助思考</h3><h3 id=\"多写多练\"><a href=\"#多写多练\" class=\"headerlink\" title=\"多写多练\"></a>多写多练</h3><ol>\n<li>单链表反转</li>\n<li>链表中环的检测</li>\n<li>两个有序的链表合并</li>\n<li>删除链表倒数第 n 个结点</li>\n<li>求链表的中间结点</li>\n</ol>\n","categories":["数据结构与算法"],"tags":["Java","算法"]},{"title":"邮件发送服务","url":"/2022/02/18/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E6%9C%8D%E5%8A%A1/","content":"<h1 id=\"邮箱概念\"><a href=\"#邮箱概念\" class=\"headerlink\" title=\"邮箱概念\"></a>邮箱概念</h1><p>如果要发送邮件服务，需要启用一个账户在各大邮件平台的SMTP服务。<br>SpringBoot2.x版本开始内部整合Mail的模块。</p>\n<h1 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h1><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-mail<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>xxx<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h1><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mail:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"string\">smtp.163.com</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">25</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">xxxxxxxxxxx@163.com</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">对应的SMTP密码</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>写一个类，使用JavaMailSender来进行邮件发送<br>使用的类：</p>\n<ol>\n<li>JavaMailSender</li>\n<li>SimpleMailMessage</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String FROMADDRESS = <span class=\"string\">&quot;xxxxx@163.com&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">final</span> JavaMailSender javaMailSender;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MailUtil</span><span class=\"params\">(JavaMailSender javaMailSender)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.javaMailSender = javaMailSender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//参数自定</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMail</span><span class=\"params\">(UserVerify userVerify, String email)</span> </span>&#123;</span><br><span class=\"line\">\t\tSimpleMailMessage message = <span class=\"keyword\">new</span> SimpleMailMessage();</span><br><span class=\"line\">\t\tString url = <span class=\"string\">&quot;https://domain:port/user/verify?uuid=&quot;</span> + userVerify.getUuid() + <span class=\"string\">&quot;&amp;username=&quot;</span> + userVerify.getUsername();</span><br><span class=\"line\">\t\tmessage.setFrom(FROMADDRESS);</span><br><span class=\"line\">\t\tmessage.setSubject(<span class=\"string\">&quot;欢迎您注册&quot;</span>);</span><br><span class=\"line\">\t\tmessage.setText(<span class=\"string\">&quot;请点击该链接完成注册确认: &quot;</span> + verifcation);</span><br><span class=\"line\">\t\tmessage.setTo(email);</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tjavaMailSender.send(message);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\tlog.error(<span class=\"string\">&quot;邮件发送失败：&quot;</span> + e.getMessage());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["框架"],"tags":["Spring","开发记录","Java"]},{"title":"设计模式","url":"/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"学习设计模式之前\"><a href=\"#学习设计模式之前\" class=\"headerlink\" title=\"学习设计模式之前\"></a>学习设计模式之前</h2><h3 id=\"设计模式并非类库\"><a href=\"#设计模式并非类库\" class=\"headerlink\" title=\"设计模式并非类库\"></a>设计模式并非类库</h3><p>与类库相比，设计模式是一个更为普遍的概念。类库是由程序组合而成的组件，而设计模式是用来表现内部组件是如何被组装的，以及每一个组件是如何通过相互关联而构成一个庞大系统的。</p>\n<h3 id=\"类库中使用了设计模式\"><a href=\"#类库中使用了设计模式\" class=\"headerlink\" title=\"类库中使用了设计模式\"></a>类库中使用了设计模式</h3><p>但是Java标准库使用了许多设计模式，掌握设计模式可以帮助我们理解这些类库所扮演的角色。</p>\n<h3 id=\"思考设计模式能带来什么\"><a href=\"#思考设计模式能带来什么\" class=\"headerlink\" title=\"思考设计模式能带来什么\"></a>思考设计模式能带来什么</h3><ol>\n<li>有哪些功能可以被拓展</li>\n<li>拓展功能时必须修改哪些地方</li>\n<li>哪些类不需要修改</li>\n</ol>\n<h2 id=\"适应设计模式\"><a href=\"#适应设计模式\" class=\"headerlink\" title=\"适应设计模式\"></a>适应设计模式</h2><h3 id=\"迭代模式（Iterator模式）\"><a href=\"#迭代模式（Iterator模式）\" class=\"headerlink\" title=\"迭代模式（Iterator模式）\"></a>迭代模式（Iterator模式）</h3><h4 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h4><ol>\n<li>Iterator（迭代器）<br> 定义了按顺序遍历元素的接口，定义了hasNext和next两个方法。</li>\n<li>ConcreteIterator（具体的迭代器）<br> 实现了按顺序遍历元素的接口，实现hasNext和next两个方法。</li>\n<li>Aggregate（集合）<br> 定义了创建迭代器的接口，创造出一个可以被迭代的集合。</li>\n<li>ConcreteAggregate（具体的集合）<br> 实现了Aggregate角色所定义的接口，即实现Aggregate的类，是可以被迭代的，可以创建具体的迭代器。</li>\n</ol>\n<h4 id=\"UML图\"><a href=\"#UML图\" class=\"headerlink\" title=\"UML图\"></a>UML图</h4><h4 id=\"代码案例\"><a href=\"#代码案例\" class=\"headerlink\" title=\"代码案例\"></a>代码案例</h4><h5 id=\"Aggregate接口\"><a href=\"#Aggregate接口\" class=\"headerlink\" title=\"Aggregate接口\"></a>Aggregate接口</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Aggregate</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//抽象一个迭代器方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Iterator <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Iterator接口\"><a href=\"#Iterator接口\" class=\"headerlink\" title=\"Iterator接口\"></a>Iterator接口</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//抽象两个迭代方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hanNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Object <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"BookShelf类\"><a href=\"#BookShelf类\" class=\"headerlink\" title=\"BookShelf类\"></a>BookShelf类</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookShelf</span> <span class=\"keyword\">implements</span> <span class=\"title\">Aggregate</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Book[] books;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> last;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Book <span class=\"title\">getBookAt</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(index &lt; books.length);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> books[index];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">appendBook</span><span class=\"params\">(Book book)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.books[last] = book;</span><br><span class=\"line\">    last++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getLength</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.last;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Iteraotr <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个图书架迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BookShelfIterator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"BookShelfIterator类\"><a href=\"#BookShelfIterator类\" class=\"headerlink\" title=\"BookShelfIterator类\"></a>BookShelfIterator类</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookShelfIterator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Bookshelf bookShelf;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BookshelfIterator</span><span class=\"params\">(BookShelf bookShelf)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bookShelf = bookShelf;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.index = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(index &lt; bookShelf.length)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Book book = bookShelf.getBookAt(index);</span><br><span class=\"line\">    index++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> book;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Book类\"><a href=\"#Book类\" class=\"headerlink\" title=\"Book类\"></a>Book类</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> string name;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Book</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"拓展思路的要点\"><a href=\"#拓展思路的要点\" class=\"headerlink\" title=\"拓展思路的要点\"></a>拓展思路的要点</h4><h5 id=\"不管实现如何变化，都可以使用Iterator\"><a href=\"#不管实现如何变化，都可以使用Iterator\" class=\"headerlink\" title=\"不管实现如何变化，都可以使用Iterator\"></a>不管实现如何变化，都可以使用Iterator</h5><p>就是为什么不用for循环来进行遍历。因为使用Iterator并没有调用BookShelf的方法，并不依赖于BookShelf的实现。<br>如果BookShelf的开发人员决定放弃用数组来管理图书。不管BookShelf如何变化，只要BookShelf的iterator的方法能正确地返回Iterator实例，迭代代码就能正常工作。<br>这就理解为什么Iterator方法的返回不是BookShelfIterator类型，而是Iterator类型。</p>\n<h5 id=\"难以理解抽象类和接口\"><a href=\"#难以理解抽象类和接口\" class=\"headerlink\" title=\"难以理解抽象类和接口\"></a>难以理解抽象类和接口</h5><p>如果只使用具体的类来解决问题，很容易导致类之间的强耦合，从而这些类难以作为组件再次被使用。<br>所以要弱化类之间的耦合，需要引入抽象类和接口。</p>\n<div class=\"note info\">\n            <p>核心思想：不要只使用具体类来编程，要优先使用抽象类和接口来编程</p>\n          </div>\n\n<h5 id=\"Aggregate和Iterator的对应-ConcreteAggregate和ConcreteIterator对应\"><a href=\"#Aggregate和Iterator的对应-ConcreteAggregate和ConcreteIterator对应\" class=\"headerlink\" title=\"Aggregate和Iterator的对应/ConcreteAggregate和ConcreteIterator对应\"></a>Aggregate和Iterator的对应/ConcreteAggregate和ConcreteIterator对应</h5><p>在本例子中，BookShelfIterator类知道BookShelf如何实现的，因此才能调用getBookAt来获取下一本书。<br>所以，BookShelf的实现发生改变，getBookAt的实现也发生改变时，必须修改BookShelfIterator类，即如同接口一样，BookShelf和BookShelfIterator的对应（Concrete的对应）。</p>\n<h5 id=\"容易弄错“下一个”\"><a href=\"#容易弄错“下一个”\" class=\"headerlink\" title=\"容易弄错“下一个”\"></a>容易弄错“下一个”</h5><p>next()方法是返回指针的当前值，接着指针指向下一个。</p>\n<h5 id=\"容易弄错“最后一个”\"><a href=\"#容易弄错“最后一个”\" class=\"headerlink\" title=\"容易弄错“最后一个”\"></a>容易弄错“最后一个”</h5><p>hasNext方法在返回最后一个元素前会返回true，当返回最后一个元素的时候返回false。<br>所以把hasNext理解为，接下来时候可以调用next()方法。<br>访问最后一个元素的时候，是倒数第二个元素调用next()，输出最后一个元素。</p>\n<h5 id=\"多个迭代器\"><a href=\"#多个迭代器\" class=\"headerlink\" title=\"多个迭代器\"></a>多个迭代器</h5><p>将遍历功能置于Aggregate角色之外，是Iterator模式的一个特征。因此可以编写多个ConcreteIterator迭代器。</p>\n<h5 id=\"迭代器的种类多种多样\"><a href=\"#迭代器的种类多种多样\" class=\"headerlink\" title=\"迭代器的种类多种多样\"></a>迭代器的种类多种多样</h5><ol>\n<li>可以用最后向前遍历</li>\n<li>即包含从前向后，也包含从后向前</li>\n<li>指定下标，跳跃式前进</li>\n</ol>\n<h5 id=\"不需要deleteIterator\"><a href=\"#不需要deleteIterator\" class=\"headerlink\" title=\"不需要deleteIterator\"></a>不需要deleteIterator</h5><p>因为Java的独有内存管理机制，没有被使用的对象实例会自动被GC处理。所以不需要删除迭代器方法。</p>\n<h4 id=\"相关的设计模式\"><a href=\"#相关的设计模式\" class=\"headerlink\" title=\"相关的设计模式\"></a>相关的设计模式</h4><ol>\n<li>Vistor模式：在遍历元素集合的过程中，对元素进行相同的处理。</li>\n<li>Composite模式：具有递归结构的模式，在其中使用Iterator比较困难。</li>\n<li>Factory Method模式：Iterator方法中生成Iterator的实例时可能会使用Factory Method模式。</li>\n</ol>\n<h3 id=\"适配器模式（Adapter-Method）\"><a href=\"#适配器模式（Adapter-Method）\" class=\"headerlink\" title=\"适配器模式（Adapter Method）\"></a>适配器模式（Adapter Method）</h3><h4 id=\"核心组件-1\"><a href=\"#核心组件-1\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h4><h5 id=\"Target（对象）\"><a href=\"#Target（对象）\" class=\"headerlink\" title=\"Target（对象）\"></a>Target（对象）</h5><p>定义了所需的方法。简单而言就是定义了所需要转换的最终要求。</p>\n<h5 id=\"Client（请求者）\"><a href=\"#Client（请求者）\" class=\"headerlink\" title=\"Client（请求者）\"></a>Client（请求者）</h5><p>就是谁负责调用Target对象，使用转换后的对象来进行自己操作的对象。</p>\n<h5 id=\"Adaptee（被适配）\"><a href=\"#Adaptee（被适配）\" class=\"headerlink\" title=\"Adaptee（被适配）\"></a>Adaptee（被适配）</h5><p>被适配的对象，就是原先需要被转换的对象。拥有自己方法的对象。</p>\n<h5 id=\"Adapter（适配者）\"><a href=\"#Adapter（适配者）\" class=\"headerlink\" title=\"Adapter（适配者）\"></a>Adapter（适配者）</h5><p>适配者，利用被适配的对象方法，来实现转换为适配满足Target对象的需求。</p>\n<div class=\"note info\">\n            <p>Java的类要先继承再实现</p>\n          </div>\n\n<h4 id=\"UML图-1\"><a href=\"#UML图-1\" class=\"headerlink\" title=\"UML图\"></a>UML图</h4><h4 id=\"代码案例-1\"><a href=\"#代码案例-1\" class=\"headerlink\" title=\"代码案例\"></a>代码案例</h4><h4 id=\"拓展思路要点\"><a href=\"#拓展思路要点\" class=\"headerlink\" title=\"拓展思路要点\"></a>拓展思路要点</h4><h5 id=\"什么时候使用Adapter模式\"><a href=\"#什么时候使用Adapter模式\" class=\"headerlink\" title=\"什么时候使用Adapter模式\"></a>什么时候使用Adapter模式</h5><p>当有些类已经被测试过了，并且用于其他软件之中，我们更愿意将这些类作为组件重复使用。Adapter会对现有类进行适配，生成新的类。<br>也可以用来排查代码bug，调查扮演Adapter的类来进行排查。</p>\n<h5 id=\"如果没有现成的代码\"><a href=\"#如果没有现成的代码\" class=\"headerlink\" title=\"如果没有现成的代码\"></a>如果没有现成的代码</h5><p>让现有的类适配新的API时，常常会有“稍微改一下的”这样思想，从而修改了原有测试完成的代码。而如果使用Adapter模式，可以不修改原有代码，来适配新的API。</p>\n<h5 id=\"版本升级和兼容\"><a href=\"#版本升级和兼容\" class=\"headerlink\" title=\"版本升级和兼容\"></a>版本升级和兼容</h5><p>使用Adapter模式可以使新旧版本兼容，同时维护新旧版本。</p>\n<h5 id=\"功能完全不同的类（不能使用）\"><a href=\"#功能完全不同的类（不能使用）\" class=\"headerlink\" title=\"功能完全不同的类（不能使用）\"></a>功能完全不同的类（不能使用）</h5><p>当Adaptee类和Target类的功能完全不同的时候，是不能使用Adapter模式的。</p>\n<h2 id=\"交给子类\"><a href=\"#交给子类\" class=\"headerlink\" title=\"交给子类\"></a>交给子类</h2><h3 id=\"模版模式（Template-Method）\"><a href=\"#模版模式（Template-Method）\" class=\"headerlink\" title=\"模版模式（Template Method）\"></a>模版模式（Template Method）</h3><h4 id=\"核心组件-2\"><a href=\"#核心组件-2\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h4><h5 id=\"AbstractClass（抽象类）\"><a href=\"#AbstractClass（抽象类）\" class=\"headerlink\" title=\"AbstractClass（抽象类）\"></a>AbstractClass（抽象类）</h5><h5 id=\"ConcreteClass（具体类）\"><a href=\"#ConcreteClass（具体类）\" class=\"headerlink\" title=\"ConcreteClass（具体类）\"></a>ConcreteClass（具体类）</h5><h3 id=\"工厂模式（Factory-Method）\"><a href=\"#工厂模式（Factory-Method）\" class=\"headerlink\" title=\"工厂模式（Factory Method）\"></a>工厂模式（Factory Method）</h3><h3 id=\"策略设计模式\"><a href=\"#策略设计模式\" class=\"headerlink\" title=\"策略设计模式\"></a>策略设计模式</h3><h2 id=\"生成实例\"><a href=\"#生成实例\" class=\"headerlink\" title=\"生成实例\"></a>生成实例</h2><h3 id=\"单例模式（Singleton\"><a href=\"#单例模式（Singleton\" class=\"headerlink\" title=\"单例模式（Singleton)\"></a>单例模式（Singleton)</h3><h4 id=\"核心组件-3\"><a href=\"#核心组件-3\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h4><h5 id=\"Singleton\"><a href=\"#Singleton\" class=\"headerlink\" title=\"Singleton\"></a>Singleton</h5><p>Singleton只存在一个实例的类。</p>\n<h5 id=\"UML图-2\"><a href=\"#UML图-2\" class=\"headerlink\" title=\"UML图\"></a>UML图</h5><h5 id=\"代码案例-2\"><a href=\"#代码案例-2\" class=\"headerlink\" title=\"代码案例\"></a>代码案例</h5><h2 id=\"避免浪费\"><a href=\"#避免浪费\" class=\"headerlink\" title=\"避免浪费\"></a>避免浪费</h2><h3 id=\"代理模式（Proxy-Method）\"><a href=\"#代理模式（Proxy-Method）\" class=\"headerlink\" title=\"代理模式（Proxy Method）\"></a>代理模式（Proxy Method）</h3><h4 id=\"核心组件-4\"><a href=\"#核心组件-4\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h4><h5 id=\"主体\"><a href=\"#主体\" class=\"headerlink\" title=\"主体\"></a>主体</h5><h5 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h5><h4 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h4><p>需要提供代理类。</p>\n<h4 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h4><h5 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h5><p>被代理的类要有接口实现（生成的代理对象类型和接口相关），返回值必须用接口类来接收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取动态代理对象</span></span><br><span class=\"line\">HouseOwner houseOwner = <span class=\"keyword\">new</span> HouseOwner();</span><br><span class=\"line\">Proxy.newProxyInstance(houseOwner.getClass().getClassLoader(), </span><br><span class=\"line\">  houseOwner.getClass().getInterface(),</span><br><span class=\"line\">  <span class=\"keyword\">new</span> InvocationHandler&#123;</span><br><span class=\"line\">  <span class=\"comment\">//使用代理对象调用方法时，就会调用这个invoke方法。</span></span><br><span class=\"line\">  <span class=\"comment\">//1.proxy：代理对象</span></span><br><span class=\"line\">  <span class=\"comment\">//2.method：代理对象所使用的方法</span></span><br><span class=\"line\">  <span class=\"comment\">//3.args：method对应的参数</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//一定要传被代理类的对象（houseOwner），而不是代理对象。</span></span><br><span class=\"line\">    &#123;前代理操作...&#125;</span><br><span class=\"line\">    Object invoke = method.invoke(houseOwner, args);</span><br><span class=\"line\">    &#123;后代理操作...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"CGLIB动态代理\"><a href=\"#CGLIB动态代理\" class=\"headerlink\" title=\"CGLIB动态代理\"></a>CGLIB动态代理</h5><p>基于继承来实现。</p>\n<ol>\n<li>导入cglib包（Spring5.0之后已经将cglib导入）</li>\n<li>创建增强器</li>\n<li>设置父类（即代理目标）</li>\n<li>设置回调（回调是个接口）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">myProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    HouseOwner houseOwner = <span class=\"keyword\">new</span> HouseOwner();</span><br><span class=\"line\">    <span class=\"comment\">//创建代理类，cglib下的InvocationHandler</span></span><br><span class=\"line\">    HouseOwner houseOwnerProxy = (HouseOwner) Enhancer.create(HouseOwner.class, <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object o, Method method, Object[] objects)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;前调用...&quot;</span>);</span><br><span class=\"line\">        Object invoke = method.invoke(houseOwner, objects);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;后调用...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">//使用代理</span></span><br><span class=\"line\">    houseOwnerProxy.rent(<span class=\"number\">1500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["设计模式"],"tags":["Java"]},{"title":"酒精计划","url":"/2021/04/27/%E9%85%92%E7%B2%BE%E8%AE%A1%E5%88%92/","content":"<p><img src=\"/2021/04/27/%E9%85%92%E7%B2%BE%E8%AE%A1%E5%88%92/%E9%85%92%E7%B2%BE%E8%AE%A1%E5%88%92.jpg\"></p>\n<span id=\"more\"></span>\n<p>酒，既能欢庆，亦能浇愁。</p>\n<p>“Jeg tror Tommy hepper på os to” </p>\n<p>既是他最悲痛的一天，也是他最值得庆祝的一天。</p>\n<p>所有的情感纵横交错在一起（What a life），这就是人生，惊喜不断。</p>\n<p>“现在是时候了，让我们来跳支舞吧！”</p>\n<p>向上是飞翔，向下是死亡。</p>\n","tags":["随写"]},{"title":"锁升级.md","url":"/2023/03/07/%E9%94%81%E5%8D%87%E7%BA%A7/","content":"<h1 id=\"什么是锁升级\"><a href=\"#什么是锁升级\" class=\"headerlink\" title=\"什么是锁升级\"></a>什么是锁升级</h1><p>因为加锁/解锁依赖于操作系统底层，十分消耗资源，所以JVM对锁竞争进行了优化：</p>\n<p><strong>在同步代码竞争不激烈的时候，使用较轻的锁；而当同步代码块的线程竞争逐渐激烈的过程，JVM会把对象的锁变重。</strong></p>\n<p>以上从轻锁升级到重锁的过程，称为锁升级。<strong>且不可降级</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"名词概念\"><a href=\"#名词概念\" class=\"headerlink\" title=\"名词概念\"></a>名词概念</h1><h2 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h2><p>存储Java对象的描述信息。<strong>完整的Java对象：对象头 + 实例数据 + 对象填充</strong></p>\n<h2 id=\"锁记录\"><a href=\"#锁记录\" class=\"headerlink\" title=\"锁记录\"></a>锁记录</h2><p>存储在线程栈的记录，轻量级锁会使用，包括获取轻量级锁的对象的对象头复制(Displaced Header)，以及被锁住对象的元数据。</p>\n<p><strong>The lock record holds the original value of the object’s mark word and also contains metadata necessary to identify which object is locked.</strong></p>\n<h2 id=\"无锁\"><a href=\"#无锁\" class=\"headerlink\" title=\"无锁\"></a>无锁</h2><p>顾名思义</p>\n<h2 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h2><p>即对象只偏向于某一个线程，该线程操作该对象，无需加锁/解锁。</p>\n<h2 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h2><p>少量线程竞争某一个对象，通过CAS自旋获取到对应的锁。</p>\n<h2 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h2><p>大量竞争，Synchronize，几乎完全交给操作系统底层来处理。</p>\n<h1 id=\"锁升级过程\"><a href=\"#锁升级过程\" class=\"headerlink\" title=\"锁升级过程\"></a>锁升级过程</h1><h2 id=\"无锁-gt-偏向锁\"><a href=\"#无锁-gt-偏向锁\" class=\"headerlink\" title=\"无锁 -&gt; 偏向锁\"></a>无锁 -&gt; 偏向锁</h2><h2 id=\"偏向锁-gt-轻量级锁\"><a href=\"#偏向锁-gt-轻量级锁\" class=\"headerlink\" title=\"偏向锁 -&gt; 轻量级锁\"></a>偏向锁 -&gt; 轻量级锁</h2><h2 id=\"轻量级锁-gt-重量级锁\"><a href=\"#轻量级锁-gt-重量级锁\" class=\"headerlink\" title=\"轻量级锁 -&gt; 重量级锁\"></a>轻量级锁 -&gt; 重量级锁</h2>","categories":["编程语言"],"tags":["Java","锁","Java并发"]},{"title":"限流","url":"/2022/08/15/%E9%99%90%E6%B5%81/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>当服务突然经历过高流量冲击的时候，可能会出现瘫痪或者其他问题，所以要进行限流处理保护后台。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"限流方案\"><a href=\"#限流方案\" class=\"headerlink\" title=\"限流方案\"></a>限流方案</h1><p>多种多样</p>\n<ol>\n<li>Google 的Guava RateLimiter</li>\n<li>Nginx限流</li>\n<li>Openresty + Lua</li>\n<li>Sentinel限流</li>\n<li>Redis + Lua</li>\n<li>等等…..</li>\n</ol>\n<h1 id=\"Redis-Lua限流实现\"><a href=\"#Redis-Lua限流实现\" class=\"headerlink\" title=\"Redis + Lua限流实现\"></a>Redis + Lua限流实现</h1><p>使用AOP进行限制</p>\n<h2 id=\"Lua脚本\"><a href=\"#Lua脚本\" class=\"headerlink\" title=\"Lua脚本\"></a>Lua脚本</h2><ol>\n<li>Redis里每秒生成key（key规定数量）</li>\n<li>没超过数量，自增 + 1，返回特定值</li>\n<li>超过数量，则返回另个特定值</li>\n<li>过期设定为2秒</li>\n</ol>\n","categories":["框架"],"tags":["设计原理"]},{"title":"面向对象设计","url":"/2024/01/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/","content":"<h1 id=\"C-的面向对象设计\"><a href=\"#C-的面向对象设计\" class=\"headerlink\" title=\"C++的面向对象设计\"></a>C++的面向对象设计</h1><h2 id=\"一、基础概念\"><a href=\"#一、基础概念\" class=\"headerlink\" title=\"一、基础概念\"></a>一、基础概念</h2><h2 id=\"二、继承\"><a href=\"#二、继承\" class=\"headerlink\" title=\"二、继承\"></a>二、继承</h2><h3 id=\"1-继承之间的类型转换\"><a href=\"#1-继承之间的类型转换\" class=\"headerlink\" title=\"1. 继承之间的类型转换\"></a>1. 继承之间的类型转换</h3><h3 id=\"2-final\"><a href=\"#2-final\" class=\"headerlink\" title=\"2. final\"></a>2. final</h3><p>如果不希望某个成员类型或成员函数被重写，使用final关键字。</p>\n<h3 id=\"3-override\"><a href=\"#3-override\" class=\"headerlink\" title=\"3. override\"></a>3. override</h3><p>为了程序的清晰和可读性，已经编译器更好的通过和检查错误，C++ 11 建议使用override关键字重写虚函数。</p>\n<h3 id=\"4-多继承\"><a href=\"#4-多继承\" class=\"headerlink\" title=\"4. 多继承\"></a>4. 多继承</h3><ol>\n<li>注意默认访问</li>\n<li></li>\n</ol>\n<h2 id=\"三、多态\"><a href=\"#三、多态\" class=\"headerlink\" title=\"三、多态\"></a>三、多态</h2><h2 id=\"四、虚表\"><a href=\"#四、虚表\" class=\"headerlink\" title=\"四、虚表\"></a>四、虚表</h2><h3 id=\"虚表结构\"><a href=\"#虚表结构\" class=\"headerlink\" title=\"虚表结构\"></a>虚表结构</h3><p><img src=\"/2024/01/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/%E8%99%9A%E8%A1%A8.png\" alt=\"虚表\"> </p>\n<h3 id=\"如何访问到虚表？\"><a href=\"#如何访问到虚表？\" class=\"headerlink\" title=\"如何访问到虚表？\"></a>如何访问到虚表？</h3><p>对对象取地址，得到的内容第一个就是vfptr，再解引用，即可访问虚表。<br>如果再对该地址解引用，可以得到第一个虚函数的地址。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Derived <span class=\"title\">derived</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Derived的地址：%p\\n&quot;</span>, &amp;derived);\t<span class=\"comment\">// 方式1</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Derived的地址：%p\\n&quot;</span>, (<span class=\"keyword\">long</span> *)&amp;derived);\t<span class=\"comment\">// 方式2</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;虚表的地址：%p\\n&quot;</span>, (<span class=\"keyword\">long</span> *) * (<span class=\"keyword\">long</span> *)&amp;derived);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第一个虚函数的地址：%p\\n&quot;</span>, (<span class=\"keyword\">long</span> *) *(<span class=\"keyword\">long</span> *) *(<span class=\"keyword\">long</span> *)&amp;derived);\t<span class=\"comment\">// 方式1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*Function)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第一个虚函数的地址：%p\\n&quot;</span>, (Function) *(<span class=\"keyword\">long</span> *) *(<span class=\"keyword\">long</span> *)&amp;derived);\t<span class=\"comment\">// 方式2：用函数指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第二个虚函数的地址：%p\\n&quot;</span>, (Function) *(<span class=\"keyword\">long</span> *) *(<span class=\"keyword\">long</span> *)&amp;derived + <span class=\"number\">1</span>);\t</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"虚表有几个？\"><a href=\"#虚表有几个？\" class=\"headerlink\" title=\"虚表有几个？\"></a>虚表有几个？</h3><p>单继承，虚表只有一个。</p>\n<p>多继承，虚表就有多个。</p>\n<h3 id=\"同理，如何得到base和derived的地址？\"><a href=\"#同理，如何得到base和derived的地址？\" class=\"headerlink\" title=\"同理，如何得到base和derived的地址？\"></a>同理，如何得到base和derived的地址？</h3><h2 id=\"一些名词解释\"><a href=\"#一些名词解释\" class=\"headerlink\" title=\"一些名词解释\"></a>一些名词解释</h2><h3 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h3><p>发生在一个类的作用域内部，要求：名字相同，返回值相同，但是参数不同。</p>\n<h3 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h3><p>发生在基类和派生类之间，要求：名字、返回值、参数都相同</p>\n<h3 id=\"隐藏\"><a href=\"#隐藏\" class=\"headerlink\" title=\"隐藏\"></a>隐藏</h3><p>发生在基类和派生类之间，要求：在同一个作用域，名字、返回值相同，参数可以不同，派生类隐藏了基类的成员。</p>\n<h3 id=\"静态类型\"><a href=\"#静态类型\" class=\"headerlink\" title=\"静态类型\"></a>静态类型</h3><p>继承关系时候，如果在编译器编译时，表达式即可确定类型的，为静态类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Animal *pChild;\t</span><br><span class=\"line\"><span class=\"comment\">// pI的静态类型为Animal *</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p>继承关系时候，如果是在运行时，表达式才能确定其的类型，为动态类型。<br>是多态的保证</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Animal *pChild = <span class=\"keyword\">new</span> Human();\t</span><br><span class=\"line\"><span class=\"comment\">// 静态类型还是Animal *, 但是动态类型为Human *</span></span><br></pre></td></tr></table></figure>\n","categories":["编程语言"],"tags":["C++","Java"]}]